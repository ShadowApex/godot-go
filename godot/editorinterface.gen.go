package godot

import (
	"github.com/shadowapex/godot-go/gdnative"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

//func NewEditorInterfaceFromPointer(ptr gdnative.Pointer) EditorInterface {
func newEditorInterfaceFromPointer(ptr gdnative.Pointer) EditorInterface {
	owner := gdnative.NewObjectFromPointer(ptr)
	obj := EditorInterface{}
	obj.SetBaseObject(owner)

	return obj
}

/*
Editor interface. Allows saving and (re-)loading scenes, rendering mesh previews, inspecting and editing resources and objects and provides access to [EditorSettings], [EditorFileSystem], [EditorResourcePreview]\ er, [ScriptEditor], the editor viewport, as well as information about scenes. Also see [EditorPlugin] and [EditorScript].
*/
type EditorInterface struct {
	Node
	owner gdnative.Object
}

func (o *EditorInterface) BaseClass() string {
	return "EditorInterface"
}

/*
        Edits the given [Resource].
	Args: [{ false resource Resource}], Returns: void
*/
func (o *EditorInterface) EditResource(resource Resource) {
	//log.Println("Calling EditorInterface.EditResource()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(resource.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("EditorInterface", "edit_resource")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Returns the base [Control].
	Args: [], Returns: Control
*/
func (o *EditorInterface) GetBaseControl() ControlImplementer {
	//log.Println("Calling EditorInterface.GetBaseControl()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("EditorInterface", "get_base_control")

	// Call the parent method.
	// Control
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newControlFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(ControlImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Control" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(ControlImplementer)
	}

	return &ret
}

/*
        Returns the edited scene's root [Node].
	Args: [], Returns: Node
*/
func (o *EditorInterface) GetEditedSceneRoot() NodeImplementer {
	//log.Println("Calling EditorInterface.GetEditedSceneRoot()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("EditorInterface", "get_edited_scene_root")

	// Call the parent method.
	// Node
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newNodeFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(NodeImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Node" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(NodeImplementer)
	}

	return &ret
}

/*
        Returns the [EditorSettings].
	Args: [], Returns: EditorSettings
*/
func (o *EditorInterface) GetEditorSettings() EditorSettingsImplementer {
	//log.Println("Calling EditorInterface.GetEditorSettings()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("EditorInterface", "get_editor_settings")

	// Call the parent method.
	// EditorSettings
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newEditorSettingsFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(EditorSettingsImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "EditorSettings" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(EditorSettingsImplementer)
	}

	return &ret
}

/*
        Returns the editor [Viewport].
	Args: [], Returns: Control
*/
func (o *EditorInterface) GetEditorViewport() ControlImplementer {
	//log.Println("Calling EditorInterface.GetEditorViewport()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("EditorInterface", "get_editor_viewport")

	// Call the parent method.
	// Control
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newControlFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(ControlImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Control" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(ControlImplementer)
	}

	return &ret
}

/*
        Returns an [Array] of the currently opened scenes.
	Args: [], Returns: Array
*/
func (o *EditorInterface) GetOpenScenes() gdnative.Array {
	//log.Println("Calling EditorInterface.GetOpenScenes()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("EditorInterface", "get_open_scenes")

	// Call the parent method.
	// Array
	retPtr := gdnative.NewEmptyArray()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewArrayFromPointer(retPtr)
	return ret
}

/*
        Returns the [EditorFileSystem].
	Args: [], Returns: EditorFileSystem
*/
func (o *EditorInterface) GetResourceFilesystem() EditorFileSystemImplementer {
	//log.Println("Calling EditorInterface.GetResourceFilesystem()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("EditorInterface", "get_resource_filesystem")

	// Call the parent method.
	// EditorFileSystem
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newEditorFileSystemFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(EditorFileSystemImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "EditorFileSystem" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(EditorFileSystemImplementer)
	}

	return &ret
}

/*
        Returns the [EditorResourcePreview]\ er.
	Args: [], Returns: EditorResourcePreview
*/
func (o *EditorInterface) GetResourcePreviewer() EditorResourcePreviewImplementer {
	//log.Println("Calling EditorInterface.GetResourcePreviewer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("EditorInterface", "get_resource_previewer")

	// Call the parent method.
	// EditorResourcePreview
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newEditorResourcePreviewFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(EditorResourcePreviewImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "EditorResourcePreview" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(EditorResourcePreviewImplementer)
	}

	return &ret
}

/*
        Returns the [ScriptEditor].
	Args: [], Returns: ScriptEditor
*/
func (o *EditorInterface) GetScriptEditor() ScriptEditorImplementer {
	//log.Println("Calling EditorInterface.GetScriptEditor()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("EditorInterface", "get_script_editor")

	// Call the parent method.
	// ScriptEditor
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newScriptEditorFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(ScriptEditorImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "ScriptEditor" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(ScriptEditorImplementer)
	}

	return &ret
}

/*

	Args: [], Returns: String
*/
func (o *EditorInterface) GetSelectedPath() gdnative.String {
	//log.Println("Calling EditorInterface.GetSelectedPath()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("EditorInterface", "get_selected_path")

	// Call the parent method.
	// String
	retPtr := gdnative.NewEmptyString()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewStringFromPointer(retPtr)
	return ret
}

/*
        Returns the [EditorSelection].
	Args: [], Returns: EditorSelection
*/
func (o *EditorInterface) GetSelection() EditorSelectionImplementer {
	//log.Println("Calling EditorInterface.GetSelection()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("EditorInterface", "get_selection")

	// Call the parent method.
	// EditorSelection
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newEditorSelectionFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(EditorSelectionImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "EditorSelection" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(EditorSelectionImplementer)
	}

	return &ret
}

/*
        Shows the given property on the given [code]object[/code] in the Editor's Inspector dock.
	Args: [{ false object Object} { true for_property String}], Returns: void
*/
func (o *EditorInterface) InspectObject(object Object, forProperty gdnative.String) {
	//log.Println("Calling EditorInterface.InspectObject()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromString(forProperty)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("EditorInterface", "inspect_object")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Returns the enabled status of a plugin. The plugin name is the same as its directory name.
	Args: [{ false plugin String}], Returns: bool
*/
func (o *EditorInterface) IsPluginEnabled(plugin gdnative.String) gdnative.Bool {
	//log.Println("Calling EditorInterface.IsPluginEnabled()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(plugin)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("EditorInterface", "is_plugin_enabled")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns mesh previews rendered at the given size as an [Array] of [Texture]s.
	Args: [{ false meshes Array} { false preview_size int}], Returns: Array
*/
func (o *EditorInterface) MakeMeshPreviews(meshes gdnative.Array, previewSize gdnative.Int) gdnative.Array {
	//log.Println("Calling EditorInterface.MakeMeshPreviews()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromArray(meshes)
	ptrArguments[1] = gdnative.NewPointerFromInt(previewSize)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("EditorInterface", "make_mesh_previews")

	// Call the parent method.
	// Array
	retPtr := gdnative.NewEmptyArray()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewArrayFromPointer(retPtr)
	return ret
}

/*
        Opens the scene at the given path.
	Args: [{ false scene_filepath String}], Returns: void
*/
func (o *EditorInterface) OpenSceneFromPath(sceneFilepath gdnative.String) {
	//log.Println("Calling EditorInterface.OpenSceneFromPath()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(sceneFilepath)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("EditorInterface", "open_scene_from_path")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Reloads the scene at the given path.
	Args: [{ false scene_filepath String}], Returns: void
*/
func (o *EditorInterface) ReloadSceneFromPath(sceneFilepath gdnative.String) {
	//log.Println("Calling EditorInterface.ReloadSceneFromPath()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(sceneFilepath)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("EditorInterface", "reload_scene_from_path")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Saves the scene. Returns either OK or ERR_CANT_CREATE. See [@GlobalScope] constants.
	Args: [], Returns: enum.Error
*/

/*
        Saves the scene as a file at [code]path[/code].
	Args: [{ false path String} {True true with_preview bool}], Returns: void
*/
func (o *EditorInterface) SaveSceneAs(path gdnative.String, withPreview gdnative.Bool) {
	//log.Println("Calling EditorInterface.SaveSceneAs()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(path)
	ptrArguments[1] = gdnative.NewPointerFromBool(withPreview)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("EditorInterface", "save_scene_as")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*

	Args: [{ false p_file String}], Returns: void
*/
func (o *EditorInterface) SelectFile(pFile gdnative.String) {
	//log.Println("Calling EditorInterface.SelectFile()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(pFile)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("EditorInterface", "select_file")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the enabled status of a plugin. The plugin name is the same as its directory name.
	Args: [{ false plugin String} { false enabled bool}], Returns: void
*/
func (o *EditorInterface) SetPluginEnabled(plugin gdnative.String, enabled gdnative.Bool) {
	//log.Println("Calling EditorInterface.SetPluginEnabled()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(plugin)
	ptrArguments[1] = gdnative.NewPointerFromBool(enabled)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("EditorInterface", "set_plugin_enabled")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

// EditorInterfaceImplementer is an interface that implements the methods
// of the EditorInterface class.
type EditorInterfaceImplementer interface {
	NodeImplementer
	EditResource(resource Resource)
	GetBaseControl() ControlImplementer
	GetEditedSceneRoot() NodeImplementer
	GetEditorSettings() EditorSettingsImplementer
	GetEditorViewport() ControlImplementer
	GetOpenScenes() gdnative.Array
	GetResourceFilesystem() EditorFileSystemImplementer
	GetResourcePreviewer() EditorResourcePreviewImplementer
	GetScriptEditor() ScriptEditorImplementer
	GetSelectedPath() gdnative.String
	GetSelection() EditorSelectionImplementer
	InspectObject(object Object, forProperty gdnative.String)
	IsPluginEnabled(plugin gdnative.String) gdnative.Bool
	MakeMeshPreviews(meshes gdnative.Array, previewSize gdnative.Int) gdnative.Array
	OpenSceneFromPath(sceneFilepath gdnative.String)
	ReloadSceneFromPath(sceneFilepath gdnative.String)
	SaveSceneAs(path gdnative.String, withPreview gdnative.Bool)
	SelectFile(pFile gdnative.String)
	SetPluginEnabled(plugin gdnative.String, enabled gdnative.Bool)
}
