package godot

import (
	"github.com/shadowapex/godot-go/gdnative"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

// ControlAnchor is an enum for Anchor values.
type ControlAnchor int

const (
	ControlAnchorBegin ControlAnchor = 0
	ControlAnchorEnd   ControlAnchor = 1
)

// ControlCursorShape is an enum for CursorShape values.
type ControlCursorShape int

const (
	ControlCursorArrow        ControlCursorShape = 0
	ControlCursorBdiagsize    ControlCursorShape = 11
	ControlCursorBusy         ControlCursorShape = 5
	ControlCursorCanDrop      ControlCursorShape = 7
	ControlCursorCross        ControlCursorShape = 3
	ControlCursorDrag         ControlCursorShape = 6
	ControlCursorFdiagsize    ControlCursorShape = 12
	ControlCursorForbidden    ControlCursorShape = 8
	ControlCursorHelp         ControlCursorShape = 16
	ControlCursorHsize        ControlCursorShape = 10
	ControlCursorHsplit       ControlCursorShape = 15
	ControlCursorIbeam        ControlCursorShape = 1
	ControlCursorMove         ControlCursorShape = 13
	ControlCursorPointingHand ControlCursorShape = 2
	ControlCursorVsize        ControlCursorShape = 9
	ControlCursorVsplit       ControlCursorShape = 14
	ControlCursorWait         ControlCursorShape = 4
)

// ControlFocusMode is an enum for FocusMode values.
type ControlFocusMode int

const (
	ControlFocusAll   ControlFocusMode = 2
	ControlFocusClick ControlFocusMode = 1
	ControlFocusNone  ControlFocusMode = 0
)

// ControlGrowDirection is an enum for GrowDirection values.
type ControlGrowDirection int

const (
	ControlGrowDirectionBegin ControlGrowDirection = 0
	ControlGrowDirectionEnd   ControlGrowDirection = 1
)

// ControlLayoutPreset is an enum for LayoutPreset values.
type ControlLayoutPreset int

const (
	ControlPresetBottomLeft   ControlLayoutPreset = 2
	ControlPresetBottomRight  ControlLayoutPreset = 3
	ControlPresetBottomWide   ControlLayoutPreset = 12
	ControlPresetCenter       ControlLayoutPreset = 8
	ControlPresetCenterBottom ControlLayoutPreset = 7
	ControlPresetCenterLeft   ControlLayoutPreset = 4
	ControlPresetCenterRight  ControlLayoutPreset = 6
	ControlPresetCenterTop    ControlLayoutPreset = 5
	ControlPresetHcenterWide  ControlLayoutPreset = 14
	ControlPresetLeftWide     ControlLayoutPreset = 9
	ControlPresetRightWide    ControlLayoutPreset = 11
	ControlPresetTopLeft      ControlLayoutPreset = 0
	ControlPresetTopRight     ControlLayoutPreset = 1
	ControlPresetTopWide      ControlLayoutPreset = 10
	ControlPresetVcenterWide  ControlLayoutPreset = 13
	ControlPresetWide         ControlLayoutPreset = 15
)

// ControlLayoutPresetMode is an enum for LayoutPresetMode values.
type ControlLayoutPresetMode int

const (
	ControlPresetModeKeepHeight ControlLayoutPresetMode = 2
	ControlPresetModeKeepSize   ControlLayoutPresetMode = 3
	ControlPresetModeKeepWidth  ControlLayoutPresetMode = 1
	ControlPresetModeMinsize    ControlLayoutPresetMode = 0
)

// ControlMouseFilter is an enum for MouseFilter values.
type ControlMouseFilter int

const (
	ControlMouseFilterIgnore ControlMouseFilter = 2
	ControlMouseFilterPass   ControlMouseFilter = 1
	ControlMouseFilterStop   ControlMouseFilter = 0
)

// ControlSizeFlags is an enum for SizeFlags values.
type ControlSizeFlags int

const (
	ControlSizeExpand       ControlSizeFlags = 2
	ControlSizeExpandFill   ControlSizeFlags = 3
	ControlSizeFill         ControlSizeFlags = 1
	ControlSizeShrinkCenter ControlSizeFlags = 4
	ControlSizeShrinkEnd    ControlSizeFlags = 8
)

//func NewControlFromPointer(ptr gdnative.Pointer) Control {
func newControlFromPointer(ptr gdnative.Pointer) Control {
	owner := gdnative.NewObjectFromPointer(ptr)
	obj := Control{}
	obj.SetBaseObject(owner)

	return obj
}

/*
Base class for all User Interface or [i]UI[/i] related nodes. [code]Control[/code] features a bounding rectangle that defines its extents, an anchor position relative to its parent and margins that represent an offset to the anchor. The margins update automatically when the node, any of its parents, or the screen size change. For more information on Godot's UI system, anchors, margins, and containers, see the related tutorials in the manual. To build flexible UIs, you'll need a mix of UI elements that inherit from [code]Control[/code] and [Container] nodes. [b]User Interface nodes and input[/b] Godot sends input events to the scene's root node first, by calling [method Node._input]. [method Node._input] forwards the event down the node tree to the nodes under the mouse cursor, or on keyboard focus. To do so, it calls [method MainLoop._input_event]. Call [method accept_event] so no other node receives the event. Once you accepted an input, it becomes handled so [method Node._unhandled_input] will not process it. Only one [code]Control[/code] node can be in keyboard focus. Only the node in focus will receive keyboard events. To get the focus, call [method grab_focus]. [code]Control[/code] nodes lose focus when another node grabs it, or if you hide the node in focus. Set [member mouse_filter] to MOUSE_FILTER_IGNORE to tell a [code]Control[/code] node to ignore mouse or touch events. You'll need it if you place an icon on top of a button. [Theme] resources change the Control's appearance. If you change the [Theme] on a [code]Control[/code] node, it affects all of its children. To override some of the theme's parameters, call one of the [code]add_*_override[/code] methods, like [method add_font_override]. You can override the theme with the inspector.
*/
type Control struct {
	CanvasItem
	owner gdnative.Object
}

func (o *Control) BaseClass() string {
	return "Control"
}

/*
        Undocumented
	Args: [], Returns: void
*/
func (o *Control) X_FontChanged() {
	//log.Println("Calling Control.X_FontChanged()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_font_changed")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Returns the minimum size this Control can shrink to. The node can never be smaller than this minimum size.
	Args: [], Returns: Vector2
*/
func (o *Control) X_GetMinimumSize() gdnative.Vector2 {
	//log.Println("Calling Control.X_GetMinimumSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_get_minimum_size")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: String
*/
func (o *Control) X_GetTooltip() gdnative.String {
	//log.Println("Calling Control.X_GetTooltip()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_get_tooltip")

	// Call the parent method.
	// String
	retPtr := gdnative.NewEmptyString()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewStringFromPointer(retPtr)
	return ret
}

/*
        The node's parent forwards input events to this method. Use it to process and accept inputs on UI elements. See [method accept_event]. Replaces Godot 2's [code]_input_event[/code].
	Args: [{ false event InputEvent}], Returns: void
*/
func (o *Control) X_GuiInput(event InputEvent) {
	//log.Println("Calling Control.X_GuiInput()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(event.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_gui_input")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false margin int} { false anchor float}], Returns: void
*/
func (o *Control) X_SetAnchor(margin gdnative.Int, anchor gdnative.Float) {
	//log.Println("Calling Control.X_SetAnchor()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(margin)
	ptrArguments[1] = gdnative.NewPointerFromFloat(anchor)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_set_anchor")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [], Returns: void
*/
func (o *Control) X_SizeChanged() {
	//log.Println("Calling Control.X_SizeChanged()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_size_changed")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [], Returns: void
*/
func (o *Control) X_ThemeChanged() {
	//log.Println("Calling Control.X_ThemeChanged()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_theme_changed")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [], Returns: void
*/
func (o *Control) X_UpdateMinimumSize() {
	//log.Println("Calling Control.X_UpdateMinimumSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_update_minimum_size")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Marks an input event as handled. Once you accept an input event, it stops propagating, even to nodes listening to [method Node._unhandled_input] or [method Node._unhandled_key_input].
	Args: [], Returns: void
*/
func (o *Control) AcceptEvent() {
	//log.Println("Calling Control.AcceptEvent()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "accept_event")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Overrides the color in the [theme] resource the node uses.
	Args: [{ false name String} { false color Color}], Returns: void
*/
func (o *Control) AddColorOverride(name gdnative.String, color gdnative.Color) {
	//log.Println("Calling Control.AddColorOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromColor(color)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "add_color_override")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Overrides an integer constant in the [Theme] resource the node uses. If the [code]constant[/code] is invalid, Godot clears the override. See [member Theme.INVALID_CONSTANT] for more information.
	Args: [{ false name String} { false constant int}], Returns: void
*/
func (o *Control) AddConstantOverride(name gdnative.String, constant gdnative.Int) {
	//log.Println("Calling Control.AddConstantOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromInt(constant)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "add_constant_override")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Overrides the [code]name[/code] font in the [theme] resource the node uses. If [code]font[/code] is empty, Godot clears the override.
	Args: [{ false name String} { false font Font}], Returns: void
*/
func (o *Control) AddFontOverride(name gdnative.String, font Font) {
	//log.Println("Calling Control.AddFontOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromObject(font.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "add_font_override")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Overrides the [code]name[/code] icon in the [theme] resource the node uses. If [code]icon[/code] is empty, Godot clears the override.
	Args: [{ false name String} { false texture Texture}], Returns: void
*/
func (o *Control) AddIconOverride(name gdnative.String, texture Texture) {
	//log.Println("Calling Control.AddIconOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromObject(texture.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "add_icon_override")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Overrides the [code]name[/code] shader in the [theme] resource the node uses. If [code]shader[/code] is empty, Godot clears the override.
	Args: [{ false name String} { false shader Shader}], Returns: void
*/
func (o *Control) AddShaderOverride(name gdnative.String, shader Shader) {
	//log.Println("Calling Control.AddShaderOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromObject(shader.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "add_shader_override")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Overrides the [code]name[/code] [Stylebox] in the [theme] resource the node uses. If [code]stylebox[/code] is empty, Godot clears the override.
	Args: [{ false name String} { false stylebox StyleBox}], Returns: void
*/
func (o *Control) AddStyleboxOverride(name gdnative.String, stylebox StyleBox) {
	//log.Println("Calling Control.AddStyleboxOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromObject(stylebox.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "add_stylebox_override")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Godot calls this method to test if [code]data[/code] from a control's [method get_drag_data] can be dropped at [code]position[/code]. [code]position[/code] is local to this control. This method should only be used to test the data. Process the data in [method drop_data]. [codeblock] extends Control func can_drop_data(position, data): # check position if it is relevant to you # otherwise just check data return typeof(data) == TYPE_DICTIONARY and data.has('expected') [/codeblock]
	Args: [{ false position Vector2} { false data Variant}], Returns: bool
*/
func (o *Control) CanDropData(position gdnative.Vector2, data gdnative.Variant) gdnative.Bool {
	//log.Println("Calling Control.CanDropData()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)
	ptrArguments[1] = gdnative.NewPointerFromVariant(data)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "can_drop_data")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Godot calls this method to pass you the [code]data[/code] from a control's [method get_drag_data] result. Godot first calls [method can_drop_data] to test if [code]data[/code] is allowed to drop at [code]position[/code] where [code]position[/code] is local to this control. [codeblock] extends ColorRect func can_drop_data(position, data): return typeof(data) == TYPE_DICTIONARY and data.has('color') func drop_data(position, data): color = data['color'] [/codeblock]
	Args: [{ false position Vector2} { false data Variant}], Returns: void
*/
func (o *Control) DropData(position gdnative.Vector2, data gdnative.Variant) {
	//log.Println("Calling Control.DropData()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)
	ptrArguments[1] = gdnative.NewPointerFromVariant(data)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "drop_data")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Forces drag and bypasses [method get_drag_data] and [method set_drag_preview] by passing [code]data[/code] and [code]preview[/code]. Drag will start even if the mouse is neither over nor pressed on this control. The methods [method can_drop_data] and [method drop_data] must be implemented on controls that want to recieve drop data.
	Args: [{ false data Variant} { false preview Object}], Returns: void
*/
func (o *Control) ForceDrag(data gdnative.Variant, preview Object) {
	//log.Println("Calling Control.ForceDrag()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromVariant(data)
	ptrArguments[1] = gdnative.NewPointerFromObject(preview.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "force_drag")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false margin int}], Returns: float
*/
func (o *Control) GetAnchor(margin gdnative.Int) gdnative.Float {
	//log.Println("Calling Control.GetAnchor()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(margin)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_anchor")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyFloat()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewFloatFromPointer(retPtr)
	return ret
}

/*

	Args: [], Returns: Vector2
*/
func (o *Control) GetBegin() gdnative.Vector2 {
	//log.Println("Calling Control.GetBegin()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_begin")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String} { true type String}], Returns: Color
*/
func (o *Control) GetColor(name gdnative.String, aType gdnative.String) gdnative.Color {
	//log.Println("Calling Control.GetColor()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_color")

	// Call the parent method.
	// Color
	retPtr := gdnative.NewEmptyColor()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewColorFromPointer(retPtr)
	return ret
}

/*

	Args: [], Returns: Vector2
*/
func (o *Control) GetCombinedMinimumSize() gdnative.Vector2 {
	//log.Println("Calling Control.GetCombinedMinimumSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_combined_minimum_size")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String} { true type String}], Returns: int
*/
func (o *Control) GetConstant(name gdnative.String, aType gdnative.String) gdnative.Int {
	//log.Println("Calling Control.GetConstant()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_constant")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Returns the mouse cursor shape the control displays on mouse hover, one of the [code]CURSOR_*[/code] constants.
	Args: [{(0, 0) true position Vector2}], Returns: enum.Control::CursorShape
*/
func (o *Control) GetCursorShape(position gdnative.Vector2) ControlCursorShape {
	//log.Println("Calling Control.GetCursorShape()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_cursor_shape")

	// Call the parent method.
	// enum.Control::CursorShape
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ControlCursorShape(ret)
}

/*
        Undocumented
	Args: [], Returns: Vector2
*/
func (o *Control) GetCustomMinimumSize() gdnative.Vector2 {
	//log.Println("Calling Control.GetCustomMinimumSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_custom_minimum_size")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: enum.Control::CursorShape
*/
func (o *Control) GetDefaultCursorShape() ControlCursorShape {
	//log.Println("Calling Control.GetDefaultCursorShape()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_default_cursor_shape")

	// Call the parent method.
	// enum.Control::CursorShape
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ControlCursorShape(ret)
}

/*
        Godot calls this method to get data that can be dragged and dropped onto controls that expect drop data. Return null if there is no data to drag. Controls that want to recieve drop data should implement [method can_drop_data] and [method drop_data]. [code]position[/code] is local to this control. Drag may be forced with [method force_drag]. A preview that will follow the mouse that should represent the data can be set with [method set_drag_preview]. A good time to set the preview is in this method. [codeblock] extends Control func get_drag_data(position): var mydata = make_data() set_drag_preview(make_preview(mydata)) return mydata [/codeblock]
	Args: [{ false position Vector2}], Returns: Object
*/
func (o *Control) GetDragData(position gdnative.Vector2) ObjectImplementer {
	//log.Println("Calling Control.GetDragData()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_drag_data")

	// Call the parent method.
	// Object
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newObjectFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(ObjectImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Object" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(ObjectImplementer)
	}

	return &ret
}

/*
        Returns MARGIN_LEFT and MARGIN_TOP at the same time. This is a helper (see [method set_margin]).
	Args: [], Returns: Vector2
*/
func (o *Control) GetEnd() gdnative.Vector2 {
	//log.Println("Calling Control.GetEnd()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_end")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: enum.Control::FocusMode
*/
func (o *Control) GetFocusMode() ControlFocusMode {
	//log.Println("Calling Control.GetFocusMode()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_focus_mode")

	// Call the parent method.
	// enum.Control::FocusMode
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ControlFocusMode(ret)
}

/*
        Undocumented
	Args: [{ false margin int}], Returns: NodePath
*/
func (o *Control) GetFocusNeighbour(margin gdnative.Int) gdnative.NodePath {
	//log.Println("Calling Control.GetFocusNeighbour()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(margin)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_focus_neighbour")

	// Call the parent method.
	// NodePath
	retPtr := gdnative.NewEmptyNodePath()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewNodePathFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: NodePath
*/
func (o *Control) GetFocusNext() gdnative.NodePath {
	//log.Println("Calling Control.GetFocusNext()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_focus_next")

	// Call the parent method.
	// NodePath
	retPtr := gdnative.NewEmptyNodePath()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewNodePathFromPointer(retPtr)
	return ret
}

/*
        Return which control is owning the keyboard focus, or null if no one.
	Args: [], Returns: Control
*/
func (o *Control) GetFocusOwner() ControlImplementer {
	//log.Println("Calling Control.GetFocusOwner()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_focus_owner")

	// Call the parent method.
	// Control
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newControlFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(ControlImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Control" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(ControlImplementer)
	}

	return &ret
}

/*
        Undocumented
	Args: [], Returns: NodePath
*/
func (o *Control) GetFocusPrevious() gdnative.NodePath {
	//log.Println("Calling Control.GetFocusPrevious()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_focus_previous")

	// Call the parent method.
	// NodePath
	retPtr := gdnative.NewEmptyNodePath()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewNodePathFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String} { true type String}], Returns: Font
*/
func (o *Control) GetFont(name gdnative.String, aType gdnative.String) FontImplementer {
	//log.Println("Calling Control.GetFont()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_font")

	// Call the parent method.
	// Font
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newFontFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(FontImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Font" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(FontImplementer)
	}

	return &ret
}

/*
        Undocumented
	Args: [], Returns: Vector2
*/
func (o *Control) GetGlobalPosition() gdnative.Vector2 {
	//log.Println("Calling Control.GetGlobalPosition()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_global_position")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Return position and size of the Control, relative to the top-left corner of the [i]window[/i] Control. This is a helper (see [method get_global_position], [method get_size]).
	Args: [], Returns: Rect2
*/
func (o *Control) GetGlobalRect() gdnative.Rect2 {
	//log.Println("Calling Control.GetGlobalRect()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_global_rect")

	// Call the parent method.
	// Rect2
	retPtr := gdnative.NewEmptyRect2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRect2FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: enum.Control::GrowDirection
*/
func (o *Control) GetHGrowDirection() ControlGrowDirection {
	//log.Println("Calling Control.GetHGrowDirection()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_h_grow_direction")

	// Call the parent method.
	// enum.Control::GrowDirection
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ControlGrowDirection(ret)
}

/*
        Undocumented
	Args: [], Returns: int
*/
func (o *Control) GetHSizeFlags() gdnative.Int {
	//log.Println("Calling Control.GetHSizeFlags()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_h_size_flags")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String} { true type String}], Returns: Texture
*/
func (o *Control) GetIcon(name gdnative.String, aType gdnative.String) TextureImplementer {
	//log.Println("Calling Control.GetIcon()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_icon")

	// Call the parent method.
	// Texture
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newTextureFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(TextureImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Texture" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(TextureImplementer)
	}

	return &ret
}

/*
        Undocumented
	Args: [{ false margin int}], Returns: float
*/
func (o *Control) GetMargin(margin gdnative.Int) gdnative.Float {
	//log.Println("Calling Control.GetMargin()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(margin)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_margin")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyFloat()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewFloatFromPointer(retPtr)
	return ret
}

/*
        Return the minimum size this Control can shrink to. A control will never be displayed or resized smaller than its minimum size.
	Args: [], Returns: Vector2
*/
func (o *Control) GetMinimumSize() gdnative.Vector2 {
	//log.Println("Calling Control.GetMinimumSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_minimum_size")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: enum.Control::MouseFilter
*/
func (o *Control) GetMouseFilter() ControlMouseFilter {
	//log.Println("Calling Control.GetMouseFilter()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_mouse_filter")

	// Call the parent method.
	// enum.Control::MouseFilter
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ControlMouseFilter(ret)
}

/*

	Args: [], Returns: Vector2
*/
func (o *Control) GetParentAreaSize() gdnative.Vector2 {
	//log.Println("Calling Control.GetParentAreaSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_parent_area_size")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*

	Args: [], Returns: Control
*/
func (o *Control) GetParentControl() ControlImplementer {
	//log.Println("Calling Control.GetParentControl()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_parent_control")

	// Call the parent method.
	// Control
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newControlFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(ControlImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Control" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(ControlImplementer)
	}

	return &ret
}

/*
        Undocumented
	Args: [], Returns: Vector2
*/
func (o *Control) GetPivotOffset() gdnative.Vector2 {
	//log.Println("Calling Control.GetPivotOffset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_pivot_offset")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: Vector2
*/
func (o *Control) GetPosition() gdnative.Vector2 {
	//log.Println("Calling Control.GetPosition()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_position")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Return position and size of the Control, relative to the top-left corner of the parent Control. This is a helper (see [method get_position], [method get_size]).
	Args: [], Returns: Rect2
*/
func (o *Control) GetRect() gdnative.Rect2 {
	//log.Println("Calling Control.GetRect()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_rect")

	// Call the parent method.
	// Rect2
	retPtr := gdnative.NewEmptyRect2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRect2FromPointer(retPtr)
	return ret
}

/*
        Return the rotation (in radians)
	Args: [], Returns: float
*/
func (o *Control) GetRotation() gdnative.Float {
	//log.Println("Calling Control.GetRotation()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_rotation")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyFloat()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewFloatFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: float
*/
func (o *Control) GetRotationDegrees() gdnative.Float {
	//log.Println("Calling Control.GetRotationDegrees()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_rotation_degrees")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyFloat()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewFloatFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: Vector2
*/
func (o *Control) GetScale() gdnative.Vector2 {
	//log.Println("Calling Control.GetScale()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_scale")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: Vector2
*/
func (o *Control) GetSize() gdnative.Vector2 {
	//log.Println("Calling Control.GetSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_size")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: float
*/
func (o *Control) GetStretchRatio() gdnative.Float {
	//log.Println("Calling Control.GetStretchRatio()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_stretch_ratio")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyFloat()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewFloatFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String} { true type String}], Returns: StyleBox
*/
func (o *Control) GetStylebox(name gdnative.String, aType gdnative.String) StyleBoxImplementer {
	//log.Println("Calling Control.GetStylebox()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_stylebox")

	// Call the parent method.
	// StyleBox
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newStyleBoxFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(StyleBoxImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "StyleBox" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(StyleBoxImplementer)
	}

	return &ret
}

/*
        Undocumented
	Args: [], Returns: Theme
*/
func (o *Control) GetTheme() ThemeImplementer {
	//log.Println("Calling Control.GetTheme()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_theme")

	// Call the parent method.
	// Theme
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newThemeFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(ThemeImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Theme" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(ThemeImplementer)
	}

	return &ret
}

/*
        Return the tooltip, which will appear when the cursor is resting over this control.
	Args: [{(0, 0) true at_position Vector2}], Returns: String
*/
func (o *Control) GetTooltip(atPosition gdnative.Vector2) gdnative.String {
	//log.Println("Calling Control.GetTooltip()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(atPosition)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_tooltip")

	// Call the parent method.
	// String
	retPtr := gdnative.NewEmptyString()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewStringFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: enum.Control::GrowDirection
*/
func (o *Control) GetVGrowDirection() ControlGrowDirection {
	//log.Println("Calling Control.GetVGrowDirection()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_v_grow_direction")

	// Call the parent method.
	// enum.Control::GrowDirection
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ControlGrowDirection(ret)
}

/*
        Undocumented
	Args: [], Returns: int
*/
func (o *Control) GetVSizeFlags() gdnative.Int {
	//log.Println("Calling Control.GetVSizeFlags()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_v_size_flags")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*

	Args: [], Returns: void
*/
func (o *Control) GrabClickFocus() {
	//log.Println("Calling Control.GrabClickFocus()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "grab_click_focus")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Steal the focus from another control and become the focused control (see [method set_focus_mode]).
	Args: [], Returns: void
*/
func (o *Control) GrabFocus() {
	//log.Println("Calling Control.GrabFocus()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "grab_focus")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*

	Args: [{ false name String} { true type String}], Returns: bool
*/
func (o *Control) HasColor(name gdnative.String, aType gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasColor()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_color")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String}], Returns: bool
*/
func (o *Control) HasColorOverride(name gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasColorOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(name)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_color_override")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String} { true type String}], Returns: bool
*/
func (o *Control) HasConstant(name gdnative.String, aType gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasConstant()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_constant")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String}], Returns: bool
*/
func (o *Control) HasConstantOverride(name gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasConstantOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(name)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_constant_override")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Return whether the Control is the current focused control (see [method set_focus_mode]).
	Args: [], Returns: bool
*/
func (o *Control) HasFocus() gdnative.Bool {
	//log.Println("Calling Control.HasFocus()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_focus")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String} { true type String}], Returns: bool
*/
func (o *Control) HasFont(name gdnative.String, aType gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasFont()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_font")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String}], Returns: bool
*/
func (o *Control) HasFontOverride(name gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasFontOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(name)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_font_override")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String} { true type String}], Returns: bool
*/
func (o *Control) HasIcon(name gdnative.String, aType gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasIcon()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_icon")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String}], Returns: bool
*/
func (o *Control) HasIconOverride(name gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasIconOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(name)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_icon_override")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false point Vector2}], Returns: bool
*/
func (o *Control) HasPoint(point gdnative.Vector2) gdnative.Bool {
	//log.Println("Calling Control.HasPoint()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(point)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_point")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String}], Returns: bool
*/
func (o *Control) HasShaderOverride(name gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasShaderOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(name)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_shader_override")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String} { true type String}], Returns: bool
*/
func (o *Control) HasStylebox(name gdnative.String, aType gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasStylebox()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_stylebox")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String}], Returns: bool
*/
func (o *Control) HasStyleboxOverride(name gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasStyleboxOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(name)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_stylebox_override")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: bool
*/
func (o *Control) IsClippingContents() gdnative.Bool {
	//log.Println("Calling Control.IsClippingContents()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "is_clipping_contents")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*

	Args: [], Returns: void
*/
func (o *Control) MinimumSizeChanged() {
	//log.Println("Calling Control.MinimumSizeChanged()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "minimum_size_changed")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Give up the focus, no other control will be able to receive keyboard input.
	Args: [], Returns: void
*/
func (o *Control) ReleaseFocus() {
	//log.Println("Calling Control.ReleaseFocus()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "release_focus")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*

	Args: [{ false margin int} { false anchor float} {False true keep_margin bool} {True true push_opposite_anchor bool}], Returns: void
*/
func (o *Control) SetAnchor(margin gdnative.Int, anchor gdnative.Float, keepMargin gdnative.Bool, pushOppositeAnchor gdnative.Bool) {
	//log.Println("Calling Control.SetAnchor()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 4, 4)
	ptrArguments[0] = gdnative.NewPointerFromInt(margin)
	ptrArguments[1] = gdnative.NewPointerFromFloat(anchor)
	ptrArguments[2] = gdnative.NewPointerFromBool(keepMargin)
	ptrArguments[3] = gdnative.NewPointerFromBool(pushOppositeAnchor)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_anchor")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*

	Args: [{ false margin int} { false anchor float} { false offset float} {False true push_opposite_anchor bool}], Returns: void
*/
func (o *Control) SetAnchorAndMargin(margin gdnative.Int, anchor gdnative.Float, offset gdnative.Float, pushOppositeAnchor gdnative.Bool) {
	//log.Println("Calling Control.SetAnchorAndMargin()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 4, 4)
	ptrArguments[0] = gdnative.NewPointerFromInt(margin)
	ptrArguments[1] = gdnative.NewPointerFromFloat(anchor)
	ptrArguments[2] = gdnative.NewPointerFromFloat(offset)
	ptrArguments[3] = gdnative.NewPointerFromBool(pushOppositeAnchor)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_anchor_and_margin")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*

	Args: [{ false preset int} {0 true resize_mode int} {0 true margin int}], Returns: void
*/
func (o *Control) SetAnchorsAndMarginsPreset(preset gdnative.Int, resizeMode gdnative.Int, margin gdnative.Int) {
	//log.Println("Calling Control.SetAnchorsAndMarginsPreset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(preset)
	ptrArguments[1] = gdnative.NewPointerFromInt(resizeMode)
	ptrArguments[2] = gdnative.NewPointerFromInt(margin)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_anchors_and_margins_preset")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*

	Args: [{ false preset int} {False true keep_margin bool}], Returns: void
*/
func (o *Control) SetAnchorsPreset(preset gdnative.Int, keepMargin gdnative.Bool) {
	//log.Println("Calling Control.SetAnchorsPreset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(preset)
	ptrArguments[1] = gdnative.NewPointerFromBool(keepMargin)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_anchors_preset")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets MARGIN_LEFT and MARGIN_TOP at the same time. This is a helper (see [method set_margin]).
	Args: [{ false position Vector2}], Returns: void
*/
func (o *Control) SetBegin(position gdnative.Vector2) {
	//log.Println("Calling Control.SetBegin()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_begin")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false enable bool}], Returns: void
*/
func (o *Control) SetClipContents(enable gdnative.Bool) {
	//log.Println("Calling Control.SetClipContents()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(enable)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_clip_contents")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false size Vector2}], Returns: void
*/
func (o *Control) SetCustomMinimumSize(size gdnative.Vector2) {
	//log.Println("Calling Control.SetCustomMinimumSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(size)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_custom_minimum_size")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false shape int}], Returns: void
*/
func (o *Control) SetDefaultCursorShape(shape gdnative.Int) {
	//log.Println("Calling Control.SetDefaultCursorShape()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(shape)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_default_cursor_shape")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Forwards the handling of this control's drag and drop to [code]target[/code] control. Forwarding can be implemented in the target control similar to the methods [method get_drag_data], [method can_drop_data], and [method drop_data] but with two differences: 1. The function name must be suffixed with [b]_fw[/b] 2. The function must take an extra argument that is the control doing the forwarding [codeblock] # ThisControl.gd extends Control func _ready(): set_drag_forwarding(target_control) # TargetControl.gd extends Control func can_drop_data_fw(position, data, from_control): return true func drop_data_fw(position, data, from_control): my_handle_data(data) func get_drag_data_fw(position, from_control): set_drag_preview(my_preview) return my_data() [/codeblock]
	Args: [{ false target Object}], Returns: void
*/
func (o *Control) SetDragForwarding(target Object) {
	//log.Println("Calling Control.SetDragForwarding()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(target.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_drag_forwarding")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Shows the given control at the mouse pointer. A good time to call this method is in [method get_drag_data].
	Args: [{ false control Object}], Returns: void
*/
func (o *Control) SetDragPreview(control Object) {
	//log.Println("Calling Control.SetDragPreview()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(control.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_drag_preview")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets MARGIN_RIGHT and MARGIN_BOTTOM at the same time. This is a helper (see [method set_margin]).
	Args: [{ false position Vector2}], Returns: void
*/
func (o *Control) SetEnd(position gdnative.Vector2) {
	//log.Println("Calling Control.SetEnd()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_end")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false mode int}], Returns: void
*/
func (o *Control) SetFocusMode(mode gdnative.Int) {
	//log.Println("Calling Control.SetFocusMode()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(mode)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_focus_mode")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false margin int} { false neighbour NodePath}], Returns: void
*/
func (o *Control) SetFocusNeighbour(margin gdnative.Int, neighbour gdnative.NodePath) {
	//log.Println("Calling Control.SetFocusNeighbour()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(margin)
	ptrArguments[1] = gdnative.NewPointerFromNodePath(neighbour)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_focus_neighbour")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false next NodePath}], Returns: void
*/
func (o *Control) SetFocusNext(next gdnative.NodePath) {
	//log.Println("Calling Control.SetFocusNext()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromNodePath(next)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_focus_next")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false previous NodePath}], Returns: void
*/
func (o *Control) SetFocusPrevious(previous gdnative.NodePath) {
	//log.Println("Calling Control.SetFocusPrevious()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromNodePath(previous)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_focus_previous")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false position Vector2}], Returns: void
*/
func (o *Control) SetGlobalPosition(position gdnative.Vector2) {
	//log.Println("Calling Control.SetGlobalPosition()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_global_position")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false direction int}], Returns: void
*/
func (o *Control) SetHGrowDirection(direction gdnative.Int) {
	//log.Println("Calling Control.SetHGrowDirection()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(direction)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_h_grow_direction")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false flags int}], Returns: void
*/
func (o *Control) SetHSizeFlags(flags gdnative.Int) {
	//log.Println("Calling Control.SetHSizeFlags()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(flags)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_h_size_flags")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false margin int} { false offset float}], Returns: void
*/
func (o *Control) SetMargin(margin gdnative.Int, offset gdnative.Float) {
	//log.Println("Calling Control.SetMargin()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(margin)
	ptrArguments[1] = gdnative.NewPointerFromFloat(offset)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_margin")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*

	Args: [{ false preset int} {0 true resize_mode int} {0 true margin int}], Returns: void
*/
func (o *Control) SetMarginsPreset(preset gdnative.Int, resizeMode gdnative.Int, margin gdnative.Int) {
	//log.Println("Calling Control.SetMarginsPreset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(preset)
	ptrArguments[1] = gdnative.NewPointerFromInt(resizeMode)
	ptrArguments[2] = gdnative.NewPointerFromInt(margin)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_margins_preset")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false filter int}], Returns: void
*/
func (o *Control) SetMouseFilter(filter gdnative.Int) {
	//log.Println("Calling Control.SetMouseFilter()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(filter)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_mouse_filter")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false pivot_offset Vector2}], Returns: void
*/
func (o *Control) SetPivotOffset(pivotOffset gdnative.Vector2) {
	//log.Println("Calling Control.SetPivotOffset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(pivotOffset)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_pivot_offset")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false position Vector2}], Returns: void
*/
func (o *Control) SetPosition(position gdnative.Vector2) {
	//log.Println("Calling Control.SetPosition()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_position")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Set the rotation (in radians).
	Args: [{ false radians float}], Returns: void
*/
func (o *Control) SetRotation(radians gdnative.Float) {
	//log.Println("Calling Control.SetRotation()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromFloat(radians)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_rotation")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false degrees float}], Returns: void
*/
func (o *Control) SetRotationDegrees(degrees gdnative.Float) {
	//log.Println("Calling Control.SetRotationDegrees()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromFloat(degrees)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_rotation_degrees")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false scale Vector2}], Returns: void
*/
func (o *Control) SetScale(scale gdnative.Vector2) {
	//log.Println("Calling Control.SetScale()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(scale)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_scale")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false size Vector2}], Returns: void
*/
func (o *Control) SetSize(size gdnative.Vector2) {
	//log.Println("Calling Control.SetSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(size)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_size")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false ratio float}], Returns: void
*/
func (o *Control) SetStretchRatio(ratio gdnative.Float) {
	//log.Println("Calling Control.SetStretchRatio()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromFloat(ratio)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_stretch_ratio")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false theme Theme}], Returns: void
*/
func (o *Control) SetTheme(theme Theme) {
	//log.Println("Calling Control.SetTheme()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(theme.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_theme")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false tooltip String}], Returns: void
*/
func (o *Control) SetTooltip(tooltip gdnative.String) {
	//log.Println("Calling Control.SetTooltip()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(tooltip)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_tooltip")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false direction int}], Returns: void
*/
func (o *Control) SetVGrowDirection(direction gdnative.Int) {
	//log.Println("Calling Control.SetVGrowDirection()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(direction)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_v_grow_direction")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false flags int}], Returns: void
*/
func (o *Control) SetVSizeFlags(flags gdnative.Int) {
	//log.Println("Calling Control.SetVSizeFlags()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(flags)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_v_size_flags")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Display a Control as modal. Control must be a subwindow. Modal controls capture the input signals until closed or the area outside them is accessed. When a modal control loses focus, or the ESC key is pressed, they automatically hide. Modal controls are used extensively for popup dialogs and menus.
	Args: [{False true exclusive bool}], Returns: void
*/
func (o *Control) ShowModal(exclusive gdnative.Bool) {
	//log.Println("Calling Control.ShowModal()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(exclusive)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "show_modal")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*

	Args: [{ false to_position Vector2}], Returns: void
*/
func (o *Control) WarpMouse(toPosition gdnative.Vector2) {
	//log.Println("Calling Control.WarpMouse()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(toPosition)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "warp_mouse")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

// ControlImplementer is an interface that implements the methods
// of the Control class.
type ControlImplementer interface {
	CanvasItemImplementer
	X_FontChanged()
	X_GetMinimumSize() gdnative.Vector2
	X_GetTooltip() gdnative.String
	X_GuiInput(event InputEvent)
	X_SetAnchor(margin gdnative.Int, anchor gdnative.Float)
	X_SizeChanged()
	X_ThemeChanged()
	X_UpdateMinimumSize()
	AcceptEvent()
	AddColorOverride(name gdnative.String, color gdnative.Color)
	AddConstantOverride(name gdnative.String, constant gdnative.Int)
	AddFontOverride(name gdnative.String, font Font)
	AddIconOverride(name gdnative.String, texture Texture)
	AddShaderOverride(name gdnative.String, shader Shader)
	AddStyleboxOverride(name gdnative.String, stylebox StyleBox)
	CanDropData(position gdnative.Vector2, data gdnative.Variant) gdnative.Bool
	DropData(position gdnative.Vector2, data gdnative.Variant)
	ForceDrag(data gdnative.Variant, preview Object)
	GetAnchor(margin gdnative.Int) gdnative.Float
	GetBegin() gdnative.Vector2
	GetColor(name gdnative.String, aType gdnative.String) gdnative.Color
	GetCombinedMinimumSize() gdnative.Vector2
	GetConstant(name gdnative.String, aType gdnative.String) gdnative.Int
	GetCustomMinimumSize() gdnative.Vector2
	GetDragData(position gdnative.Vector2) ObjectImplementer
	GetEnd() gdnative.Vector2
	GetFocusNeighbour(margin gdnative.Int) gdnative.NodePath
	GetFocusNext() gdnative.NodePath
	GetFocusOwner() ControlImplementer
	GetFocusPrevious() gdnative.NodePath
	GetFont(name gdnative.String, aType gdnative.String) FontImplementer
	GetGlobalPosition() gdnative.Vector2
	GetGlobalRect() gdnative.Rect2
	GetHSizeFlags() gdnative.Int
	GetIcon(name gdnative.String, aType gdnative.String) TextureImplementer
	GetMargin(margin gdnative.Int) gdnative.Float
	GetMinimumSize() gdnative.Vector2
	GetParentAreaSize() gdnative.Vector2
	GetParentControl() ControlImplementer
	GetPivotOffset() gdnative.Vector2
	GetPosition() gdnative.Vector2
	GetRect() gdnative.Rect2
	GetRotation() gdnative.Float
	GetRotationDegrees() gdnative.Float
	GetScale() gdnative.Vector2
	GetSize() gdnative.Vector2
	GetStretchRatio() gdnative.Float
	GetStylebox(name gdnative.String, aType gdnative.String) StyleBoxImplementer
	GetTheme() ThemeImplementer
	GetTooltip(atPosition gdnative.Vector2) gdnative.String
	GetVSizeFlags() gdnative.Int
	GrabClickFocus()
	GrabFocus()
	HasColor(name gdnative.String, aType gdnative.String) gdnative.Bool
	HasColorOverride(name gdnative.String) gdnative.Bool
	HasConstant(name gdnative.String, aType gdnative.String) gdnative.Bool
	HasConstantOverride(name gdnative.String) gdnative.Bool
	HasFocus() gdnative.Bool
	HasFont(name gdnative.String, aType gdnative.String) gdnative.Bool
	HasFontOverride(name gdnative.String) gdnative.Bool
	HasIcon(name gdnative.String, aType gdnative.String) gdnative.Bool
	HasIconOverride(name gdnative.String) gdnative.Bool
	HasPoint(point gdnative.Vector2) gdnative.Bool
	HasShaderOverride(name gdnative.String) gdnative.Bool
	HasStylebox(name gdnative.String, aType gdnative.String) gdnative.Bool
	HasStyleboxOverride(name gdnative.String) gdnative.Bool
	IsClippingContents() gdnative.Bool
	MinimumSizeChanged()
	ReleaseFocus()
	SetAnchor(margin gdnative.Int, anchor gdnative.Float, keepMargin gdnative.Bool, pushOppositeAnchor gdnative.Bool)
	SetAnchorAndMargin(margin gdnative.Int, anchor gdnative.Float, offset gdnative.Float, pushOppositeAnchor gdnative.Bool)
	SetAnchorsAndMarginsPreset(preset gdnative.Int, resizeMode gdnative.Int, margin gdnative.Int)
	SetAnchorsPreset(preset gdnative.Int, keepMargin gdnative.Bool)
	SetBegin(position gdnative.Vector2)
	SetClipContents(enable gdnative.Bool)
	SetCustomMinimumSize(size gdnative.Vector2)
	SetDefaultCursorShape(shape gdnative.Int)
	SetDragForwarding(target Object)
	SetDragPreview(control Object)
	SetEnd(position gdnative.Vector2)
	SetFocusMode(mode gdnative.Int)
	SetFocusNeighbour(margin gdnative.Int, neighbour gdnative.NodePath)
	SetFocusNext(next gdnative.NodePath)
	SetFocusPrevious(previous gdnative.NodePath)
	SetGlobalPosition(position gdnative.Vector2)
	SetHGrowDirection(direction gdnative.Int)
	SetHSizeFlags(flags gdnative.Int)
	SetMargin(margin gdnative.Int, offset gdnative.Float)
	SetMarginsPreset(preset gdnative.Int, resizeMode gdnative.Int, margin gdnative.Int)
	SetMouseFilter(filter gdnative.Int)
	SetPivotOffset(pivotOffset gdnative.Vector2)
	SetPosition(position gdnative.Vector2)
	SetRotation(radians gdnative.Float)
	SetRotationDegrees(degrees gdnative.Float)
	SetScale(scale gdnative.Vector2)
	SetSize(size gdnative.Vector2)
	SetStretchRatio(ratio gdnative.Float)
	SetTheme(theme Theme)
	SetTooltip(tooltip gdnative.String)
	SetVGrowDirection(direction gdnative.Int)
	SetVSizeFlags(flags gdnative.Int)
	ShowModal(exclusive gdnative.Bool)
	WarpMouse(toPosition gdnative.Vector2)
}
