package godot

//------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "templates/classes.go.template" so they can be included in the generated
//   code.
//------------------------------------------------------------------------------

/*
#include <stdio.h>
#include <stdlib.h>
#include <godot/gdnative.h>
#include <godot_nativescript.h>

void **build_array(int length);
void **build_array(int length) {
	void *ptr;
	void **arr = malloc(sizeof(void *) * length);
	for (int i = 0; i < length; i++) {
	    arr[i] = ptr;
	}

	return arr;
}

void add_element(void**, void*, int);
void add_element(void **array, void *element, int index) {
	printf("CGO: Array %p %p %p %p %p\n", &array, array, &array[index], *array, array[index]);
    array[index] = element;
	printf("CGO: Index %i %p\n", index, element);
	printf("CGO: Array %p %p %p %p %p\n", &array, array, &array[index], *array, array[index]);
}
*/
import "C"

import (
	"log"
	"reflect"
	"unsafe"
)

// Class is an interface for any objects that can have Godot
// inheritance.
type Class interface {
	baseClass() string
	setOwner(object *C.godot_object)
	getOwner() *C.godot_object
}

/*
   Base class for all non built-in types. Everything not a built-in type starts the inheritance chain from this class. Objects do not manage memory, if inheriting from one the object will most likely have to be deleted manually (call the [method free] function from the script or delete from C++). Some derivates add memory management, such as [Reference] (which keeps a reference count and deletes itself automatically when no longer referenced) and [Node], which deletes the children tree when deleted. Objects export properties, which are mainly useful for storage and editing, but not really so much in programming. Properties are exported in [method _get_property_list] and handled in [method _get] and [method _set]. However, scripting languages and C++ have simpler means to export them. Objects also receive notifications ([method _notification]). Notifications are a simple way to notify the object about simple events, so they can all be handled together.
*/
type Object struct {
	owner *C.godot_object
}

func (o *Object) baseClass() string {
	return "Object"
}

/*

 */
func (o *Object) Free() {
	log.Println("Calling Object.Free()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "free", goArguments, "")

	log.Println("Got return value!")

}

/*
   Notification request, the notification id is received.
*/
func (o *Object) X_Notification(what int64) {
	log.Println("Calling Object.X_Notification()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(what)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_notification", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set a property. Return true if the property was found.
*/
func (o *Object) X_Set(property string, value *Variant) bool {
	log.Println("Calling Object.X_Set()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(property)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_set", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return a property, return null if the property does not exist.
*/
func (o *Object) X_Get(property string) {
	log.Println("Calling Object.X_Get()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(property)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_get", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the property list, array of dictionaries, dictionaries must contain: name:String, type:int (see TYPE_* enum in [@Global Scope]) and optionally: hint:int (see PROPERTY_HINT_* in [@Global Scope]), hint_string:String, usage:int (see PROPERTY_USAGE_* in [@Global Scope]).
*/
func (o *Object) X_GetPropertyList() *Array {
	log.Println("Calling Object.X_GetPropertyList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_property_list", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *Object) X_Init() {
	log.Println("Calling Object.X_Init()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_init", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the class of the object as a string.
*/
func (o *Object) GetClass() string {
	log.Println("Calling Object.GetClass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_class", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Check the class of the object against a string (including inheritance).
*/
func (o *Object) IsClass(aType string) bool {
	log.Println("Calling Object.IsClass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_class", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set property into the object.
*/
func (o *Object) Set(property string, value *Variant) {
	log.Println("Calling Object.Set()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(property)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get a property from the object.
*/
func (o *Object) Get(property string) *Variant {
	log.Println("Calling Object.Get()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(property)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Return the list of properties as an array of dictionaries, dictionaries contain: name:String, type:int (see TYPE_* enum in [@Global Scope]) and optionally: hint:int (see PROPERTY_HINT_* in [@Global Scope]), hint_string:String, usage:int (see PROPERTY_USAGE_* in [@Global Scope]).
*/
func (o *Object) GetPropertyList() *Array {
	log.Println("Calling Object.GetPropertyList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_property_list", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *Object) GetMethodList() *Array {
	log.Println("Calling Object.GetMethodList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_method_list", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Notify the object of something.
*/
func (o *Object) Notification(what int64, reversed bool) {
	log.Println("Calling Object.Notification()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(what)
	goArguments[1] = reflect.ValueOf(reversed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "notification", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the instance ID. All objects have a unique instance ID.
*/
func (o *Object) GetInstanceId() int64 {
	log.Println("Calling Object.GetInstanceId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_instance_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set a script into the object, scripts extend the object functionality.
*/
func (o *Object) SetScript(script *Reference) {
	log.Println("Calling Object.SetScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(script)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_script", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the object script (or null if it doesn't have one).
*/
func (o *Object) GetScript() *Reference {
	log.Println("Calling Object.GetScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_script", goArguments, "*Reference")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Reference)

	return returnValue

}

/*
   Set a metadata into the object. Metadata is serialized. Metadata can be [i]anything[/i].
*/
func (o *Object) SetMeta(name string, value *Variant) {
	log.Println("Calling Object.SetMeta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_meta", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return a metadata from the object.
*/
func (o *Object) GetMeta(name string) *Variant {
	log.Println("Calling Object.GetMeta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_meta", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Return true if a metadata is found with the requested name.
*/
func (o *Object) HasMeta(name string) bool {
	log.Println("Calling Object.HasMeta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_meta", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return the list of metadata in the object.
*/
func (o *Object) GetMetaList() *PoolStringArray {
	log.Println("Calling Object.GetMetaList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_meta_list", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Add a user signal (can be added anytime). Arguments are optional, but can be added as an array of dictionaries, each containing "name" and "type" (from [@Global Scope] TYPE_*).
*/
func (o *Object) AddUserSignal(signal string, arguments *Array) {
	log.Println("Calling Object.AddUserSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(signal)
	goArguments[1] = reflect.ValueOf(arguments)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_user_signal", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Object) HasUserSignal(signal string) bool {
	log.Println("Calling Object.HasUserSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(signal)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_user_signal", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Object) EmitSignal(signal string) *Variant {
	log.Println("Calling Object.EmitSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(signal)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "emit_signal", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *Object) Call(method string) *Variant {
	log.Println("Calling Object.Call()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "call", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *Object) CallDeferred(method string) *Variant {
	log.Println("Calling Object.CallDeferred()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "call_deferred", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *Object) Callv(method string, argArray *Array) *Variant {
	log.Println("Calling Object.Callv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(method)
	goArguments[1] = reflect.ValueOf(argArray)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "callv", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *Object) HasMethod(method string) bool {
	log.Println("Calling Object.HasMethod()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_method", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return the list of signals as an array of dictionaries.
*/
func (o *Object) GetSignalList() *Array {
	log.Println("Calling Object.GetSignalList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_signal_list", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *Object) GetSignalConnectionList(signal string) *Array {
	log.Println("Calling Object.GetSignalConnectionList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(signal)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_signal_connection_list", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Returns an [Array] of dictionaries with informations about signals that are connected to this object. Inside each [Dictionary] there are 3 fields: - "source" is a reference to signal emitter. - "signal_name" is name of connected signal. - "method_name" is a name of method to which signal is connected.
*/
func (o *Object) GetIncomingConnections() *Array {
	log.Println("Calling Object.GetIncomingConnections()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_incoming_connections", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Connect a signal to a method at a target (member function). Binds are optional and are passed as extra arguments to the call. Flags specify optional deferred or one shot connections, see enum CONNECT_*. A signal can only be connected once to a method, and it will throw an error if already connected. If you want to avoid this, use [method is_connected] to check.
*/
func (o *Object) Connect(signal string, target *Object, method string, binds *Array, flags int64) int64 {
	log.Println("Calling Object.Connect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(signal)
	goArguments[1] = reflect.ValueOf(target)
	goArguments[2] = reflect.ValueOf(method)
	goArguments[3] = reflect.ValueOf(binds)
	goArguments[4] = reflect.ValueOf(flags)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "connect", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Disconnect a signal from a method.
*/
func (o *Object) Disconnect(signal string, target *Object, method string) {
	log.Println("Calling Object.Disconnect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(signal)
	goArguments[1] = reflect.ValueOf(target)
	goArguments[2] = reflect.ValueOf(method)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "disconnect", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if a connection exists for a given signal and target/method.
*/
func (o *Object) IsConnected(signal string, target *Object, method string) bool {
	log.Println("Calling Object.IsConnected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(signal)
	goArguments[1] = reflect.ValueOf(target)
	goArguments[2] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_connected", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   If set to true, signal emission is blocked.
*/
func (o *Object) SetBlockSignals(enable bool) {
	log.Println("Calling Object.SetBlockSignals()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_block_signals", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if signal emission blocking is enabled.
*/
func (o *Object) IsBlockingSignals() bool {
	log.Println("Calling Object.IsBlockingSignals()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_blocking_signals", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Object) PropertyListChangedNotify() {
	log.Println("Calling Object.PropertyListChangedNotify()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "property_list_changed_notify", goArguments, "")

	log.Println("Got return value!")

}

/*
   Define whether this object can translate strings (with calls to [method tr]). Default is true.
*/
func (o *Object) SetMessageTranslation(enable bool) {
	log.Println("Calling Object.SetMessageTranslation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_message_translation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if this object can translate strings.
*/
func (o *Object) CanTranslateMessages() bool {
	log.Println("Calling Object.CanTranslateMessages()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "can_translate_messages", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Translate a message. Only works if message translation is enabled (which it is by default). See [method set_message_translation].
*/
func (o *Object) Tr(message string) string {
	log.Println("Calling Object.Tr()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(message)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tr", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *Object) IsQueuedForDeletion() bool {
	log.Println("Calling Object.IsQueuedForDeletion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_queued_for_deletion", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

// SetOwner will internally set the Godot object inside the struct.
// This is used to call parent methods.
func (o *Object) setOwner(object *C.godot_object) {
	o.owner = object
}

func (o *Object) getOwner() *C.godot_object {
	return o.owner
}

// callParentMethod will call this object's method with the given method name.
func (o *Object) callParentMethod(baseClass, methodName string, args []reflect.Value, returns string) reflect.Value {
	log.Println("Calling parent method!")

	// Convert the base class and method names to C strings.
	log.Println("  Using base class: ", baseClass)
	classCString := C.CString(baseClass)
	log.Println("  Using method name: ", methodName)
	methodCString := C.CString(methodName)

	// Get the Godot method bind pointer so we can pass it to godot_method_bind_ptrcall.
	log.Println("  Using godot object:", o.owner)
	var methodBind *C.godot_method_bind
	methodBind = C.godot_method_bind_get_method(classCString, methodCString)
	log.Println("  Using method bind pointer: ", methodBind)

	// Loop through the given arguments and see what type they are. When we know what
	// type it is, we need to convert them to the correct godot objects.
	// TODO: Probably pull this out into its own function?
	variantArgs := []unsafe.Pointer{}
	for _, arg := range args {
		log.Println("  Argument type: ", arg.Type().String())

		// Look up our conversion function in our map of conversion functions
		// based on the Go type. This is essentially a more optimal case/switch
		// statement on the type of Go object, so we can know how to convert it
		// to a Godot object.
		if convert, ok := goToGodotConversionMap[arg.Type().String()]; ok {
			argValue := convert(arg.Interface())
			variantArgs = append(variantArgs, argValue)
		} else {
			err := "Unknown type of argument value when calling parent method: " + arg.Type().String()
			Log.Error(err)
			panic(err)
		}
	}
	log.Println("  Built variant arguments: ", variantArgs)

	// Construct a C array that will contain pointers to our arguments.
	log.Println("  Allocating argument array in C.")
	cArgsArray := C.build_array(C.int(len(variantArgs)))
	log.Println("    C Array: ", cArgsArray)

	// Loop through and add each argument to our C args array.
	for i, arg := range variantArgs {
		C.add_element(cArgsArray, arg, C.int(i))
	}
	log.Println("  Built argument array from variant arguments: ", cArgsArray)

	// Construct our return object that will be populated by the method call.
	// Here we're just using a CString
	log.Println("  Building return value.")
	ret := unsafe.Pointer(C.CString(""))

	// Call the parent method. "ret" will be populated with the return value.
	log.Println("  Calling bind_ptrcall...")
	C.godot_method_bind_ptrcall(
		methodBind,
		unsafe.Pointer(o.owner),
		cArgsArray, // void**
		ret,        // void*
	)
	log.Println("  Finished calling method")

	// Convert the return value based on the type.
	var retValue reflect.Value
	if _, ok := godotToGoConversionMap[returns]; ok {
		retValue = godotToGoConversionMap[returns](ret)
	}
	// TODO: Panic if type not found?

	// Return the converted variant.
	return retValue
}

/*
   ObjectImplementer is an interface for Object objects.
*/
type ObjectImplementer interface {
	Class
}

/*
   Base class for anything that keeps a reference count. Resource and many other helper objects inherit this. References keep an internal reference counter so they are only released when no longer in use.
*/
type Reference struct {
	Object
}

func (o *Reference) baseClass() string {
	return "Reference"
}

/*

 */
func (o *Reference) InitRef() bool {
	log.Println("Calling Reference.InitRef()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "init_ref", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Increase the internal reference counter. Use this only if you really know what you are doing.
*/
func (o *Reference) Reference() bool {
	log.Println("Calling Reference.Reference()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "reference", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Decrease the internal reference counter. Use this only if you really know what you are doing.
*/
func (o *Reference) Unreference() bool {
	log.Println("Calling Reference.Unreference()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "unreference", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   ReferenceImplementer is an interface for Reference objects.
*/
type ReferenceImplementer interface {
	Class
}

/*
   A weakref can hold a [Reference], without contributing to the reference counter. A weakref can be created from an [Object] using [method @GDScript.weakref]. If this object is not a reference, weakref still works, however, it does not have any effect on the object. Weakrefs are useful in cases where multiple classes have variables that refer to eachother. Without weakrefs, using these classes could lead to memory leaks, since both references keep eachother from being released. Making part of the variables a weakref can prevent this cyclic dependency, and allows the references to be released.
*/
type WeakRef struct {
	Reference
}

func (o *WeakRef) baseClass() string {
	return "WeakRef"
}

/*
   Returns the [Object] this weakref is referring to.
*/
func (o *WeakRef) GetRef() *Variant {
	log.Println("Calling WeakRef.GetRef()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ref", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   WeakRefImplementer is an interface for WeakRef objects.
*/
type WeakRefImplementer interface {
	Class
}

/*
   Resource is the base class for all resource types. Resources are primarily data containers. They are reference counted and freed when no longer in use. They are also loaded only once from disk, and further attempts to load the resource will return the same reference (all this in contrast to a [Node], which is not reference counted and can be instanced from disk as many times as desired). Resources can be saved externally on disk or bundled into another object, such as a [Node] or another resource.
*/
type Resource struct {
	Reference
}

func (o *Resource) baseClass() string {
	return "Resource"
}

/*

 */
func (o *Resource) X_SetupLocalToScene() {
	log.Println("Calling Resource.X_SetupLocalToScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_setup_local_to_scene", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the path of the resource. This is useful mainly for editors when saving/loading, and shouldn't be changed by anything else. Fails if another [Resource] already has path "path".
*/
func (o *Resource) SetPath(path string) {
	log.Println("Calling Resource.SetPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_path", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the path of the resource. Differs from set_path(), if another [Resource] exists with "path" it over-takes it, instead of failing.
*/
func (o *Resource) TakeOverPath(path string) {
	log.Println("Calling Resource.TakeOverPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "take_over_path", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the path of the resource. This is useful mainly for editors when saving/loading, and shouldn't be changed by anything else.
*/
func (o *Resource) GetPath() string {
	log.Println("Calling Resource.GetPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Set the name of the resources, any name is valid (it doesn't have to be unique). Name is for descriptive purposes only.
*/
func (o *Resource) SetName(name string) {
	log.Println("Calling Resource.SetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_name", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the name of the resources, any name is valid (it doesn't have to be unique). Name is for descriptive purposes only.
*/
func (o *Resource) GetName() string {
	log.Println("Calling Resource.GetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the RID of the resource (or an empty RID). Many resources (such as [Texture], [Mesh], etc) are high level abstractions of resources stored in a server, so this function will return the original RID.
*/
func (o *Resource) GetRid() *RID {
	log.Println("Calling Resource.GetRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rid", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *Resource) SetLocalToScene(enable bool) {
	log.Println("Calling Resource.SetLocalToScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_local_to_scene", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Resource) IsLocalToScene() bool {
	log.Println("Calling Resource.IsLocalToScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_local_to_scene", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Resource) GetLocalScene() *Node {
	log.Println("Calling Resource.GetLocalScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_local_scene", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*

 */
func (o *Resource) SetupLocalToScene() {
	log.Println("Calling Resource.SetupLocalToScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "setup_local_to_scene", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Resource) Duplicate(subresources bool) *Resource {
	log.Println("Calling Resource.Duplicate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(subresources)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "duplicate", goArguments, "*Resource")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Resource)

	return returnValue

}

/*
   ResourceImplementer is an interface for Resource objects.
*/
type ResourceImplementer interface {
	Class
}

/*
   Native image datatype. Contains image data, which can be converted to a texture, and several functions to interact with it.
*/
type Image struct {
	Resource
}

func (o *Image) baseClass() string {
	return "Image"
}

/*
   Return the width of the [Image].
*/
func (o *Image) GetWidth() int64 {
	log.Println("Calling Image.GetWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_width", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the height of the [Image].
*/
func (o *Image) GetHeight() int64 {
	log.Println("Calling Image.GetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_height", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Image) GetSize() *Vector2 {
	log.Println("Calling Image.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Image) HasMipmaps() bool {
	log.Println("Calling Image.HasMipmaps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_mipmaps", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return the format of the [Image], one of [Image].FORMAT_*.
*/
func (o *Image) GetFormat() int64 {
	log.Println("Calling Image.GetFormat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_format", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the raw data of the [Image].
*/
func (o *Image) GetData() *PoolByteArray {
	log.Println("Calling Image.GetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_data", goArguments, "*PoolByteArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolByteArray)

	return returnValue

}

/*

 */
func (o *Image) Convert(format int64) {
	log.Println("Calling Image.Convert()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(format)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "convert", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) GetMipmapOffset(mipmap int64) int64 {
	log.Println("Calling Image.GetMipmapOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mipmap)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mipmap_offset", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Image) ResizeToPo2(square bool) {
	log.Println("Calling Image.ResizeToPo2()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(square)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "resize_to_po2", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) Resize(width int64, height int64, interpolation int64) {
	log.Println("Calling Image.Resize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(width)
	goArguments[1] = reflect.ValueOf(height)
	goArguments[2] = reflect.ValueOf(interpolation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "resize", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) ShrinkX2() {
	log.Println("Calling Image.ShrinkX2()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shrink_x2", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) ExpandX2Hq2X() {
	log.Println("Calling Image.ExpandX2Hq2X()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "expand_x2_hq2x", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) Crop(width int64, height int64) {
	log.Println("Calling Image.Crop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(width)
	goArguments[1] = reflect.ValueOf(height)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "crop", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) FlipX() {
	log.Println("Calling Image.FlipX()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "flip_x", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) FlipY() {
	log.Println("Calling Image.FlipY()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "flip_y", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) GenerateMipmaps() int64 {
	log.Println("Calling Image.GenerateMipmaps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "generate_mipmaps", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Image) ClearMipmaps() {
	log.Println("Calling Image.ClearMipmaps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_mipmaps", goArguments, "")

	log.Println("Got return value!")

}

/*
   Create an empty image of a specific size and format.
*/
func (o *Image) Create(width int64, height int64, useMipmaps bool, format int64) {
	log.Println("Calling Image.Create()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(width)
	goArguments[1] = reflect.ValueOf(height)
	goArguments[2] = reflect.ValueOf(useMipmaps)
	goArguments[3] = reflect.ValueOf(format)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) CreateFromData(width int64, height int64, useMipmaps bool, format int64, data *PoolByteArray) {
	log.Println("Calling Image.CreateFromData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(width)
	goArguments[1] = reflect.ValueOf(height)
	goArguments[2] = reflect.ValueOf(useMipmaps)
	goArguments[3] = reflect.ValueOf(format)
	goArguments[4] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create_from_data", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) IsEmpty() bool {
	log.Println("Calling Image.IsEmpty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_empty", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Load an [Image].
*/
func (o *Image) Load(path string) int64 {
	log.Println("Calling Image.Load()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "load", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Save this [Image] as a png.
*/
func (o *Image) SavePng(path string) int64 {
	log.Println("Calling Image.SavePng()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "save_png", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Image) DetectAlpha() int64 {
	log.Println("Calling Image.DetectAlpha()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "detect_alpha", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Image) IsInvisible() bool {
	log.Println("Calling Image.IsInvisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_invisible", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Image) Compress(mode int64, source int64, lossyQuality float64) int64 {
	log.Println("Calling Image.Compress()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(mode)
	goArguments[1] = reflect.ValueOf(source)
	goArguments[2] = reflect.ValueOf(lossyQuality)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "compress", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Image) Decompress() int64 {
	log.Println("Calling Image.Decompress()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "decompress", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Image) IsCompressed() bool {
	log.Println("Calling Image.IsCompressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_compressed", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Image) FixAlphaEdges() {
	log.Println("Calling Image.FixAlphaEdges()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "fix_alpha_edges", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) PremultiplyAlpha() {
	log.Println("Calling Image.PremultiplyAlpha()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "premultiply_alpha", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) SrgbToLinear() {
	log.Println("Calling Image.SrgbToLinear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "srgb_to_linear", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) NormalmapToXy() {
	log.Println("Calling Image.NormalmapToXy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "normalmap_to_xy", goArguments, "")

	log.Println("Got return value!")

}

/*
   Copy a "src_rect" [Rect2] from "src" [Image] to this [Image] on coordinates "dest".
*/
func (o *Image) BlitRect(src *Image, srcRect *Rect2, dst *Vector2) {
	log.Println("Calling Image.BlitRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(src)
	goArguments[1] = reflect.ValueOf(srcRect)
	goArguments[2] = reflect.ValueOf(dst)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "blit_rect", goArguments, "")

	log.Println("Got return value!")

}

/*
   Blits a "src_rect" [Rect2] from "src" [Image] to this [Image] using a "mask" [Image] on coordinates "dest". Alpha channel is required for "mask", will copy src pixel onto dest if the corresponding mask pixel's alpha value is not 0. "src" [Image] and "mask" [Image] *must* have the same size (width and height) but they can have different formats
*/
func (o *Image) BlitRectMask(src *Image, mask *Image, srcRect *Rect2, dst *Vector2) {
	log.Println("Calling Image.BlitRectMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(src)
	goArguments[1] = reflect.ValueOf(mask)
	goArguments[2] = reflect.ValueOf(srcRect)
	goArguments[3] = reflect.ValueOf(dst)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "blit_rect_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
   Alpha-blends a "src_rect" [Rect2] from "src" [Image] to this [Image] on coordinates "dest".
*/
func (o *Image) BlendRect(src *Image, srcRect *Rect2, dst *Vector2) {
	log.Println("Calling Image.BlendRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(src)
	goArguments[1] = reflect.ValueOf(srcRect)
	goArguments[2] = reflect.ValueOf(dst)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "blend_rect", goArguments, "")

	log.Println("Got return value!")

}

/*
   Alpha-blends a "src_rect" [Rect2] from "src" [Image] to this [Image] using a "mask" [Image] on coordinates "dest". Alpha channels are required for both "src" and "mask", dest pixels and src pixels will blend if the corresponding mask pixel's alpha value is not 0. "src" [Image] and "mask" [Image] *must* have the same size (width and height) but they can have different formats
*/
func (o *Image) BlendRectMask(src *Image, mask *Image, srcRect *Rect2, dst *Vector2) {
	log.Println("Calling Image.BlendRectMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(src)
	goArguments[1] = reflect.ValueOf(mask)
	goArguments[2] = reflect.ValueOf(srcRect)
	goArguments[3] = reflect.ValueOf(dst)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "blend_rect_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
   Fills an [Image] with a specified [Color]
*/
func (o *Image) Fill(color *Color) {
	log.Println("Calling Image.Fill()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "fill", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the area of this [Image] that is used/visibly colored/opaque.
*/
func (o *Image) GetUsedRect() *Rect2 {
	log.Println("Calling Image.GetUsedRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_used_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Return a new [Image] that is a copy of "area" in this [Image].
*/
func (o *Image) GetRect(rect *Rect2) *Image {
	log.Println("Calling Image.GetRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rect)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rect", goArguments, "*Image")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Image)

	return returnValue

}

/*

 */
func (o *Image) CopyFrom(src *Image) {
	log.Println("Calling Image.CopyFrom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(src)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "copy_from", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Image) X_SetData(data *Dictionary) {
	log.Println("Calling Image.X_SetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_data", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Image) X_GetData() *Dictionary {
	log.Println("Calling Image.X_GetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_data", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*

 */
func (o *Image) Lock() {
	log.Println("Calling Image.Lock()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "lock", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) Unlock() {
	log.Println("Calling Image.Unlock()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "unlock", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) SetPixel(x int64, y int64, color *Color) {
	log.Println("Calling Image.SetPixel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(x)
	goArguments[1] = reflect.ValueOf(y)
	goArguments[2] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pixel", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) GetPixel(x int64, y int64) *Color {
	log.Println("Calling Image.GetPixel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(x)
	goArguments[1] = reflect.ValueOf(y)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pixel", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   ImageImplementer is an interface for Image objects.
*/
type ImageImplementer interface {
	Class
}

/*

 */
type InputEvent struct {
	Resource
}

func (o *InputEvent) baseClass() string {
	return "InputEvent"
}

/*

 */
func (o *InputEvent) SetId(id int64) {
	log.Println("Calling InputEvent.SetId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_id", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the id of the event.
*/
func (o *InputEvent) GetId() int64 {
	log.Println("Calling InputEvent.GetId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *InputEvent) SetDevice(device int64) {
	log.Println("Calling InputEvent.SetDevice()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(device)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_device", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the id of the device that generated the event.
*/
func (o *InputEvent) GetDevice() int64 {
	log.Println("Calling InputEvent.GetDevice()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_device", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns true if this input event is pressed. Not relevant for the event types MOUSE_MOTION, SCREEN_DRAG and NONE.
*/
func (o *InputEvent) IsPressed() bool {
	log.Println("Calling InputEvent.IsPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_pressed", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns true if this input event matches a pre-defined action, no matter the type.
*/
func (o *InputEvent) IsAction(action string) bool {
	log.Println("Calling InputEvent.IsAction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_action", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns true if the given action is being pressed (and is not an echo event for KEY events). Not relevant for the event types MOUSE_MOTION, SCREEN_DRAG and NONE.
*/
func (o *InputEvent) IsActionPressed(action string) bool {
	log.Println("Calling InputEvent.IsActionPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_action_pressed", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns true if the given action is released (i.e. not pressed). Not relevant for the event types MOUSE_MOTION, SCREEN_DRAG and NONE.
*/
func (o *InputEvent) IsActionReleased(action string) bool {
	log.Println("Calling InputEvent.IsActionReleased()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_action_released", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns true if this input event is an echo event (only for events of type KEY, it will return false for other types).
*/
func (o *InputEvent) IsEcho() bool {
	log.Println("Calling InputEvent.IsEcho()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_echo", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns a [String] representation of the event.
*/
func (o *InputEvent) AsText() string {
	log.Println("Calling InputEvent.AsText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "as_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Returns true if this input event matches the event passed.
*/
func (o *InputEvent) ActionMatch(event *InputEvent) bool {
	log.Println("Calling InputEvent.ActionMatch()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(event)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "action_match", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *InputEvent) ShortcutMatch(event *InputEvent) bool {
	log.Println("Calling InputEvent.ShortcutMatch()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(event)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shortcut_match", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *InputEvent) IsActionType() bool {
	log.Println("Calling InputEvent.IsActionType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_action_type", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *InputEvent) XformedBy(xform *Transform2D, localOfs *Vector2) *InputEvent {
	log.Println("Calling InputEvent.XformedBy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(xform)
	goArguments[1] = reflect.ValueOf(localOfs)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "xformed_by", goArguments, "*InputEvent")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*InputEvent)

	return returnValue

}

/*
   InputEventImplementer is an interface for InputEvent objects.
*/
type InputEventImplementer interface {
	Class
}

/*

 */
type InputEventWithModifiers struct {
	InputEvent
}

func (o *InputEventWithModifiers) baseClass() string {
	return "InputEventWithModifiers"
}

/*

 */
func (o *InputEventWithModifiers) SetAlt(enable bool) {
	log.Println("Calling InputEventWithModifiers.SetAlt()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_alt", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventWithModifiers) GetAlt() bool {
	log.Println("Calling InputEventWithModifiers.GetAlt()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_alt", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *InputEventWithModifiers) SetShift(enable bool) {
	log.Println("Calling InputEventWithModifiers.SetShift()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shift", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventWithModifiers) GetShift() bool {
	log.Println("Calling InputEventWithModifiers.GetShift()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shift", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *InputEventWithModifiers) SetControl(enable bool) {
	log.Println("Calling InputEventWithModifiers.SetControl()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_control", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventWithModifiers) GetControl() bool {
	log.Println("Calling InputEventWithModifiers.GetControl()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_control", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *InputEventWithModifiers) SetMetakey(enable bool) {
	log.Println("Calling InputEventWithModifiers.SetMetakey()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_metakey", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventWithModifiers) GetMetakey() bool {
	log.Println("Calling InputEventWithModifiers.GetMetakey()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_metakey", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *InputEventWithModifiers) SetCommand(enable bool) {
	log.Println("Calling InputEventWithModifiers.SetCommand()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_command", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventWithModifiers) GetCommand() bool {
	log.Println("Calling InputEventWithModifiers.GetCommand()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_command", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   InputEventWithModifiersImplementer is an interface for InputEventWithModifiers objects.
*/
type InputEventWithModifiersImplementer interface {
	Class
}

/*

 */
type InputEventKey struct {
	InputEventWithModifiers
}

func (o *InputEventKey) baseClass() string {
	return "InputEventKey"
}

/*

 */
func (o *InputEventKey) SetPressed(pressed bool) {
	log.Println("Calling InputEventKey.SetPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pressed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pressed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventKey) SetScancode(scancode int64) {
	log.Println("Calling InputEventKey.SetScancode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scancode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scancode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventKey) GetScancode() int64 {
	log.Println("Calling InputEventKey.GetScancode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scancode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *InputEventKey) SetUnicode(unicode int64) {
	log.Println("Calling InputEventKey.SetUnicode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(unicode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_unicode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventKey) GetUnicode() int64 {
	log.Println("Calling InputEventKey.GetUnicode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_unicode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *InputEventKey) SetEcho(echo bool) {
	log.Println("Calling InputEventKey.SetEcho()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(echo)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_echo", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventKey) GetScancodeWithModifiers() int64 {
	log.Println("Calling InputEventKey.GetScancodeWithModifiers()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scancode_with_modifiers", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   InputEventKeyImplementer is an interface for InputEventKey objects.
*/
type InputEventKeyImplementer interface {
	Class
}

/*

 */
type InputEventMouse struct {
	InputEventWithModifiers
}

func (o *InputEventMouse) baseClass() string {
	return "InputEventMouse"
}

/*

 */
func (o *InputEventMouse) SetButtonMask(buttonMask int64) {
	log.Println("Calling InputEventMouse.SetButtonMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(buttonMask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_button_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventMouse) GetButtonMask() int64 {
	log.Println("Calling InputEventMouse.GetButtonMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_button_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *InputEventMouse) SetPosition(position *Vector2) {
	log.Println("Calling InputEventMouse.SetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_position", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventMouse) GetPosition() *Vector2 {
	log.Println("Calling InputEventMouse.GetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *InputEventMouse) SetGlobalPosition(globalPosition *Vector2) {
	log.Println("Calling InputEventMouse.SetGlobalPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(globalPosition)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_global_position", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventMouse) GetGlobalPosition() *Vector2 {
	log.Println("Calling InputEventMouse.GetGlobalPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_global_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   InputEventMouseImplementer is an interface for InputEventMouse objects.
*/
type InputEventMouseImplementer interface {
	Class
}

/*

 */
type InputEventMouseButton struct {
	InputEventMouse
}

func (o *InputEventMouseButton) baseClass() string {
	return "InputEventMouseButton"
}

/*

 */
func (o *InputEventMouseButton) SetFactor(factor float64) {
	log.Println("Calling InputEventMouseButton.SetFactor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(factor)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_factor", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventMouseButton) GetFactor() float64 {
	log.Println("Calling InputEventMouseButton.GetFactor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_factor", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *InputEventMouseButton) SetButtonIndex(buttonIndex int64) {
	log.Println("Calling InputEventMouseButton.SetButtonIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(buttonIndex)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_button_index", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventMouseButton) GetButtonIndex() int64 {
	log.Println("Calling InputEventMouseButton.GetButtonIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_button_index", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *InputEventMouseButton) SetPressed(pressed bool) {
	log.Println("Calling InputEventMouseButton.SetPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pressed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pressed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventMouseButton) SetDoubleclick(doubleclick bool) {
	log.Println("Calling InputEventMouseButton.SetDoubleclick()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(doubleclick)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_doubleclick", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventMouseButton) IsDoubleclick() bool {
	log.Println("Calling InputEventMouseButton.IsDoubleclick()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_doubleclick", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   InputEventMouseButtonImplementer is an interface for InputEventMouseButton objects.
*/
type InputEventMouseButtonImplementer interface {
	Class
}

/*

 */
type InputEventMouseMotion struct {
	InputEventMouse
}

func (o *InputEventMouseMotion) baseClass() string {
	return "InputEventMouseMotion"
}

/*

 */
func (o *InputEventMouseMotion) SetRelative(relative *Vector2) {
	log.Println("Calling InputEventMouseMotion.SetRelative()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(relative)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_relative", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventMouseMotion) GetRelative() *Vector2 {
	log.Println("Calling InputEventMouseMotion.GetRelative()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_relative", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *InputEventMouseMotion) SetSpeed(speed *Vector2) {
	log.Println("Calling InputEventMouseMotion.SetSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(speed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_speed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventMouseMotion) GetSpeed() *Vector2 {
	log.Println("Calling InputEventMouseMotion.GetSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_speed", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   InputEventMouseMotionImplementer is an interface for InputEventMouseMotion objects.
*/
type InputEventMouseMotionImplementer interface {
	Class
}

/*

 */
type InputEventJoypadButton struct {
	InputEvent
}

func (o *InputEventJoypadButton) baseClass() string {
	return "InputEventJoypadButton"
}

/*

 */
func (o *InputEventJoypadButton) SetButtonIndex(buttonIndex int64) {
	log.Println("Calling InputEventJoypadButton.SetButtonIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(buttonIndex)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_button_index", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventJoypadButton) GetButtonIndex() int64 {
	log.Println("Calling InputEventJoypadButton.GetButtonIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_button_index", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *InputEventJoypadButton) SetPressure(pressure float64) {
	log.Println("Calling InputEventJoypadButton.SetPressure()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pressure)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pressure", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventJoypadButton) GetPressure() float64 {
	log.Println("Calling InputEventJoypadButton.GetPressure()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pressure", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *InputEventJoypadButton) SetPressed(pressed bool) {
	log.Println("Calling InputEventJoypadButton.SetPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pressed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pressed", goArguments, "")

	log.Println("Got return value!")

}

/*
   InputEventJoypadButtonImplementer is an interface for InputEventJoypadButton objects.
*/
type InputEventJoypadButtonImplementer interface {
	Class
}

/*

 */
type InputEventJoypadMotion struct {
	InputEvent
}

func (o *InputEventJoypadMotion) baseClass() string {
	return "InputEventJoypadMotion"
}

/*

 */
func (o *InputEventJoypadMotion) SetAxis(axis int64) {
	log.Println("Calling InputEventJoypadMotion.SetAxis()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(axis)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_axis", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventJoypadMotion) GetAxis() int64 {
	log.Println("Calling InputEventJoypadMotion.GetAxis()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_axis", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *InputEventJoypadMotion) SetAxisValue(axisValue float64) {
	log.Println("Calling InputEventJoypadMotion.SetAxisValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(axisValue)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_axis_value", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventJoypadMotion) GetAxisValue() float64 {
	log.Println("Calling InputEventJoypadMotion.GetAxisValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_axis_value", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   InputEventJoypadMotionImplementer is an interface for InputEventJoypadMotion objects.
*/
type InputEventJoypadMotionImplementer interface {
	Class
}

/*

 */
type InputEventScreenDrag struct {
	InputEvent
}

func (o *InputEventScreenDrag) baseClass() string {
	return "InputEventScreenDrag"
}

/*

 */
func (o *InputEventScreenDrag) SetIndex(index int64) {
	log.Println("Calling InputEventScreenDrag.SetIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_index", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventScreenDrag) GetIndex() int64 {
	log.Println("Calling InputEventScreenDrag.GetIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_index", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *InputEventScreenDrag) SetPosition(position *Vector2) {
	log.Println("Calling InputEventScreenDrag.SetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_position", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventScreenDrag) GetPosition() *Vector2 {
	log.Println("Calling InputEventScreenDrag.GetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *InputEventScreenDrag) SetRelative(relative *Vector2) {
	log.Println("Calling InputEventScreenDrag.SetRelative()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(relative)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_relative", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventScreenDrag) GetRelative() *Vector2 {
	log.Println("Calling InputEventScreenDrag.GetRelative()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_relative", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *InputEventScreenDrag) SetSpeed(speed *Vector2) {
	log.Println("Calling InputEventScreenDrag.SetSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(speed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_speed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventScreenDrag) GetSpeed() *Vector2 {
	log.Println("Calling InputEventScreenDrag.GetSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_speed", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   InputEventScreenDragImplementer is an interface for InputEventScreenDrag objects.
*/
type InputEventScreenDragImplementer interface {
	Class
}

/*

 */
type InputEventScreenTouch struct {
	InputEvent
}

func (o *InputEventScreenTouch) baseClass() string {
	return "InputEventScreenTouch"
}

/*

 */
func (o *InputEventScreenTouch) SetIndex(index int64) {
	log.Println("Calling InputEventScreenTouch.SetIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_index", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventScreenTouch) GetIndex() int64 {
	log.Println("Calling InputEventScreenTouch.GetIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_index", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *InputEventScreenTouch) SetPosition(position *Vector2) {
	log.Println("Calling InputEventScreenTouch.SetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_position", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventScreenTouch) GetPosition() *Vector2 {
	log.Println("Calling InputEventScreenTouch.GetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *InputEventScreenTouch) SetPressed(pressed bool) {
	log.Println("Calling InputEventScreenTouch.SetPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pressed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pressed", goArguments, "")

	log.Println("Got return value!")

}

/*
   InputEventScreenTouchImplementer is an interface for InputEventScreenTouch objects.
*/
type InputEventScreenTouchImplementer interface {
	Class
}

/*

 */
type InputEventAction struct {
	InputEvent
}

func (o *InputEventAction) baseClass() string {
	return "InputEventAction"
}

/*

 */
func (o *InputEventAction) SetAction(action string) {
	log.Println("Calling InputEventAction.SetAction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_action", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventAction) GetAction() string {
	log.Println("Calling InputEventAction.GetAction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_action", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *InputEventAction) SetPressed(pressed bool) {
	log.Println("Calling InputEventAction.SetPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pressed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pressed", goArguments, "")

	log.Println("Got return value!")

}

/*
   InputEventActionImplementer is an interface for InputEventAction objects.
*/
type InputEventActionImplementer interface {
	Class
}

/*
   In GDScript, functions are not [i]first-class objects[/i]. This means it is impossible to store them directly as variables, return them from another function, or pass them as arguments. However, by creating a [FuncRef] using the [method @GDScript.funcref] function, a reference to a function in a given object can be created, passed around and called.
*/
type FuncRef struct {
	Reference
}

func (o *FuncRef) baseClass() string {
	return "FuncRef"
}

/*

 */
func (o *FuncRef) CallFunc() *Variant {
	log.Println("Calling FuncRef.CallFunc()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "call_func", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Set the object on which to call the referenced function. This object must be of a type actually inheriting from [Object], not a built-in type such as [int], [Vector2] or [Dictionary].
*/
func (o *FuncRef) SetInstance(instance *Object) {
	log.Println("Calling FuncRef.SetInstance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(instance)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_instance", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the name of the function to call on the object, without parentheses or any parameters.
*/
func (o *FuncRef) SetFunction(name string) {
	log.Println("Calling FuncRef.SetFunction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_function", goArguments, "")

	log.Println("Got return value!")

}

/*
   FuncRefImplementer is an interface for FuncRef objects.
*/
type FuncRefImplementer interface {
	Class
}

/*
   StreamPeer is an abstraction and base class for stream-based protocols (such as TCP or Unix Sockets). It provides an API for sending and receiving data through streams as raw data or strings.
*/
type StreamPeer struct {
	Reference
}

func (o *StreamPeer) baseClass() string {
	return "StreamPeer"
}

/*
   Send a chunk of data through the connection, blocking if necessary until the data is done sending. This function returns an Error code.
*/
func (o *StreamPeer) PutData(data *PoolByteArray) int64 {
	log.Println("Calling StreamPeer.PutData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(data)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "put_data", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Send a chunk of data through the connection, if all the data could not be sent at once, only part of it will. This function returns two values, an Error code and an integer, describing how much data was actually sent.
*/
func (o *StreamPeer) PutPartialData(data *PoolByteArray) *Array {
	log.Println("Calling StreamPeer.PutPartialData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(data)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "put_partial_data", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Return a chunk data with the received bytes. The amount of bytes to be received can be requested in the "bytes" argument. If not enough bytes are available, the function will block until the desired amount is received. This function returns two values, an Error code and a data array.
*/
func (o *StreamPeer) GetData(bytes int64) *Array {
	log.Println("Calling StreamPeer.GetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bytes)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_data", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Return a chunk data with the received bytes. The amount of bytes to be received can be requested in the "bytes" argument. If not enough bytes are available, the function will return how many were actually received. This function returns two values, an Error code, and a data array.
*/
func (o *StreamPeer) GetPartialData(bytes int64) *Array {
	log.Println("Calling StreamPeer.GetPartialData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bytes)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_partial_data", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Return the amount of bytes this [StreamPeer] has available.
*/
func (o *StreamPeer) GetAvailableBytes() int64 {
	log.Println("Calling StreamPeer.GetAvailableBytes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_available_bytes", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set this [StreamPeer] to use big-endian format. Default is false.
*/
func (o *StreamPeer) SetBigEndian(enable bool) {
	log.Println("Calling StreamPeer.SetBigEndian()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_big_endian", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether this [StreamPeer] is using big-endian format.
*/
func (o *StreamPeer) IsBigEndianEnabled() bool {
	log.Println("Calling StreamPeer.IsBigEndianEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_big_endian_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Put a signed byte into the stream.
*/
func (o *StreamPeer) Put8(val int64) {
	log.Println("Calling StreamPeer.Put8()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "put_8", goArguments, "")

	log.Println("Got return value!")

}

/*
   Put an unsigned byte into the stream.
*/
func (o *StreamPeer) PutU8(val int64) {
	log.Println("Calling StreamPeer.PutU8()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "put_u8", goArguments, "")

	log.Println("Got return value!")

}

/*
   Put a signed 16 bit value into the stream.
*/
func (o *StreamPeer) Put16(val int64) {
	log.Println("Calling StreamPeer.Put16()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "put_16", goArguments, "")

	log.Println("Got return value!")

}

/*
   Put an unsigned 16 bit value into the stream.
*/
func (o *StreamPeer) PutU16(val int64) {
	log.Println("Calling StreamPeer.PutU16()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "put_u16", goArguments, "")

	log.Println("Got return value!")

}

/*
   Put a signed 32 bit value into the stream.
*/
func (o *StreamPeer) Put32(val int64) {
	log.Println("Calling StreamPeer.Put32()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "put_32", goArguments, "")

	log.Println("Got return value!")

}

/*
   Put an unsigned 32 bit value into the stream.
*/
func (o *StreamPeer) PutU32(val int64) {
	log.Println("Calling StreamPeer.PutU32()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "put_u32", goArguments, "")

	log.Println("Got return value!")

}

/*
   Put a signed 64 bit value into the stream.
*/
func (o *StreamPeer) Put64(val int64) {
	log.Println("Calling StreamPeer.Put64()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "put_64", goArguments, "")

	log.Println("Got return value!")

}

/*
   Put an unsigned 64 bit value into the stream.
*/
func (o *StreamPeer) PutU64(val int64) {
	log.Println("Calling StreamPeer.PutU64()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "put_u64", goArguments, "")

	log.Println("Got return value!")

}

/*
   Put a single-precision float into the stream.
*/
func (o *StreamPeer) PutFloat(val float64) {
	log.Println("Calling StreamPeer.PutFloat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "put_float", goArguments, "")

	log.Println("Got return value!")

}

/*
   Put a double-precision float into the stream.
*/
func (o *StreamPeer) PutDouble(val float64) {
	log.Println("Calling StreamPeer.PutDouble()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "put_double", goArguments, "")

	log.Println("Got return value!")

}

/*
   Put a zero-terminated utf8 string into the stream.
*/
func (o *StreamPeer) PutUtf8String(val string) {
	log.Println("Calling StreamPeer.PutUtf8String()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "put_utf8_string", goArguments, "")

	log.Println("Got return value!")

}

/*
   Put a Variant into the stream.
*/
func (o *StreamPeer) PutVar(val *Variant) {
	log.Println("Calling StreamPeer.PutVar()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "put_var", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get a signed byte from the stream.
*/
func (o *StreamPeer) Get8() int64 {
	log.Println("Calling StreamPeer.Get8()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_8", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get an unsigned byte from the stream.
*/
func (o *StreamPeer) GetU8() int64 {
	log.Println("Calling StreamPeer.GetU8()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_u8", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get a signed 16 bit value from the stream.
*/
func (o *StreamPeer) Get16() int64 {
	log.Println("Calling StreamPeer.Get16()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_16", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get an unsigned 16 bit value from the stream.
*/
func (o *StreamPeer) GetU16() int64 {
	log.Println("Calling StreamPeer.GetU16()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_u16", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get a signed 32 bit value from the stream.
*/
func (o *StreamPeer) Get32() int64 {
	log.Println("Calling StreamPeer.Get32()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_32", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get an unsigned 32 bit value from the stream.
*/
func (o *StreamPeer) GetU32() int64 {
	log.Println("Calling StreamPeer.GetU32()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_u32", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get a signed 64 bit value from the stream.
*/
func (o *StreamPeer) Get64() int64 {
	log.Println("Calling StreamPeer.Get64()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_64", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get an unsigned 16 bit value from the stream.
*/
func (o *StreamPeer) GetU64() int64 {
	log.Println("Calling StreamPeer.GetU64()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_u64", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get a single-precision float from the stream.
*/
func (o *StreamPeer) GetFloat() float64 {
	log.Println("Calling StreamPeer.GetFloat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_float", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Get a double-precision float from the stream.
*/
func (o *StreamPeer) GetDouble() float64 {
	log.Println("Calling StreamPeer.GetDouble()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_double", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Get a string with byte-length "bytes" from the stream.
*/
func (o *StreamPeer) GetString(bytes int64) string {
	log.Println("Calling StreamPeer.GetString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bytes)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_string", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get a utf8 string with byte-length "bytes" from the stream (this decodes the string sent as utf8).
*/
func (o *StreamPeer) GetUtf8String(bytes int64) string {
	log.Println("Calling StreamPeer.GetUtf8String()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bytes)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_utf8_string", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get a Variant from the stream.
*/
func (o *StreamPeer) GetVar() *Variant {
	log.Println("Calling StreamPeer.GetVar()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_var", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   StreamPeerImplementer is an interface for StreamPeer objects.
*/
type StreamPeerImplementer interface {
	Class
}

/*

 */
type StreamPeerBuffer struct {
	StreamPeer
}

func (o *StreamPeerBuffer) baseClass() string {
	return "StreamPeerBuffer"
}

/*

 */
func (o *StreamPeerBuffer) Seek(position int64) {
	log.Println("Calling StreamPeerBuffer.Seek()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "seek", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StreamPeerBuffer) GetSize() int64 {
	log.Println("Calling StreamPeerBuffer.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *StreamPeerBuffer) GetPosition() int64 {
	log.Println("Calling StreamPeerBuffer.GetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_position", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *StreamPeerBuffer) Resize(size int64) {
	log.Println("Calling StreamPeerBuffer.Resize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "resize", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StreamPeerBuffer) SetDataArray(data *PoolByteArray) {
	log.Println("Calling StreamPeerBuffer.SetDataArray()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_data_array", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StreamPeerBuffer) GetDataArray() *PoolByteArray {
	log.Println("Calling StreamPeerBuffer.GetDataArray()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_data_array", goArguments, "*PoolByteArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolByteArray)

	return returnValue

}

/*

 */
func (o *StreamPeerBuffer) Clear() {
	log.Println("Calling StreamPeerBuffer.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StreamPeerBuffer) Duplicate() *StreamPeerBuffer {
	log.Println("Calling StreamPeerBuffer.Duplicate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "duplicate", goArguments, "*StreamPeerBuffer")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*StreamPeerBuffer)

	return returnValue

}

/*
   StreamPeerBufferImplementer is an interface for StreamPeerBuffer objects.
*/
type StreamPeerBufferImplementer interface {
	Class
}

/*
   TCP Stream peer. This object can be used to connect to TCP servers, or also is returned by a tcp server.
*/
type StreamPeerTCP struct {
	StreamPeer
}

func (o *StreamPeerTCP) baseClass() string {
	return "StreamPeerTCP"
}

/*
   Connect to the specified host:port pair. A hostname will be resolved if valid. Returns [OK] on success or [FAILED] on failure.
*/
func (o *StreamPeerTCP) ConnectToHost(host string, port int64) int64 {
	log.Println("Calling StreamPeerTCP.ConnectToHost()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(host)
	goArguments[1] = reflect.ValueOf(port)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "connect_to_host", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *StreamPeerTCP) IsConnectedToHost() bool {
	log.Println("Calling StreamPeerTCP.IsConnectedToHost()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_connected_to_host", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return the status of the connection, one of STATUS_* enum.
*/
func (o *StreamPeerTCP) GetStatus() int64 {
	log.Println("Calling StreamPeerTCP.GetStatus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_status", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the IP of this peer.
*/
func (o *StreamPeerTCP) GetConnectedHost() string {
	log.Println("Calling StreamPeerTCP.GetConnectedHost()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connected_host", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the port of this peer.
*/
func (o *StreamPeerTCP) GetConnectedPort() int64 {
	log.Println("Calling StreamPeerTCP.GetConnectedPort()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connected_port", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Disconnect from host.
*/
func (o *StreamPeerTCP) DisconnectFromHost() {
	log.Println("Calling StreamPeerTCP.DisconnectFromHost()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "disconnect_from_host", goArguments, "")

	log.Println("Got return value!")

}

/*
   StreamPeerTCPImplementer is an interface for StreamPeerTCP objects.
*/
type StreamPeerTCPImplementer interface {
	Class
}

/*
   TCP Server class. Listens to connections on a port and returns a [StreamPeerTCP] when got a connection.
*/
type TCP_Server struct {
	Reference
}

func (o *TCP_Server) baseClass() string {
	return "TCP_Server"
}

/*
   Listen on the "port" binding to "bind_address". If "bind_address" is set as "*" (default), the server will listen on all available addresses (both IPv4 and IPv6). If "bind_address" is set as "0.0.0.0" (for IPv4) or "::" (for IPv6), the server will listen on all available addresses matching that IP type. If "bind_address" is set to any valid address (e.g. "192.168.1.101", "::1", etc), the server will only listen on the interface with that addresses (or fail if no interface with the given address exists).
*/
func (o *TCP_Server) Listen(port int64, bindAddress string) int64 {
	log.Println("Calling TCP_Server.Listen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(port)
	goArguments[1] = reflect.ValueOf(bindAddress)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "listen", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return true if a connection is available for taking.
*/
func (o *TCP_Server) IsConnectionAvailable() bool {
	log.Println("Calling TCP_Server.IsConnectionAvailable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_connection_available", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   If a connection is available, return a StreamPeerTCP with the connection/
*/
func (o *TCP_Server) TakeConnection() *StreamPeerTCP {
	log.Println("Calling TCP_Server.TakeConnection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "take_connection", goArguments, "*StreamPeerTCP")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*StreamPeerTCP)

	return returnValue

}

/*
   Stop listening.
*/
func (o *TCP_Server) Stop() {
	log.Println("Calling TCP_Server.Stop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "stop", goArguments, "")

	log.Println("Got return value!")

}

/*
   TCP_ServerImplementer is an interface for TCP_Server objects.
*/
type TCP_ServerImplementer interface {
	Class
}

/*
   PacketPeer is an abstraction and base class for packet-based protocols (such as UDP). It provides an API for sending and receiving packets both as raw data or variables. This makes it easy to transfer data over a protocol, without having to encode data as low level bytes or having to worry about network ordering.
*/
type PacketPeer struct {
	Reference
}

func (o *PacketPeer) baseClass() string {
	return "PacketPeer"
}

/*
   Get a Variant.
*/
func (o *PacketPeer) GetVar() *Variant {
	log.Println("Calling PacketPeer.GetVar()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_var", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Send a Variant as a packet.
*/
func (o *PacketPeer) PutVar(variable *Variant) int64 {
	log.Println("Calling PacketPeer.PutVar()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(variable)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "put_var", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get a raw packet.
*/
func (o *PacketPeer) GetPacket() *PoolByteArray {
	log.Println("Calling PacketPeer.GetPacket()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_packet", goArguments, "*PoolByteArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolByteArray)

	return returnValue

}

/*
   Send a raw packet.
*/
func (o *PacketPeer) PutPacket(buffer *PoolByteArray) int64 {
	log.Println("Calling PacketPeer.PutPacket()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(buffer)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "put_packet", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the error state of the last packet received (via [method get_packet] and [method get_var]).
*/
func (o *PacketPeer) GetPacketError() int64 {
	log.Println("Calling PacketPeer.GetPacketError()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_packet_error", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the number of packets currently available in the ring-buffer.
*/
func (o *PacketPeer) GetAvailablePacketCount() int64 {
	log.Println("Calling PacketPeer.GetAvailablePacketCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_available_packet_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PacketPeer) SetAllowObjectDecoding(enable bool) {
	log.Println("Calling PacketPeer.SetAllowObjectDecoding()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_allow_object_decoding", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PacketPeer) IsObjectDecodingAllowed() bool {
	log.Println("Calling PacketPeer.IsObjectDecodingAllowed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_object_decoding_allowed", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   PacketPeerImplementer is an interface for PacketPeer objects.
*/
type PacketPeerImplementer interface {
	Class
}

/*
   UDP packet peer. Can be used to send raw UDP packets as well as [Variant]\ s.
*/
type PacketPeerUDP struct {
	PacketPeer
}

func (o *PacketPeerUDP) baseClass() string {
	return "PacketPeerUDP"
}

/*
   Make this [PacketPeerUDP] listen on the "port" binding to "bind_address" with a buffer size "recv_buf_size". If "bind_address" is set as "*" (default), the peer will listen on all available addresses (both IPv4 and IPv6). If "bind_address" is set as "0.0.0.0" (for IPv4) or "::" (for IPv6), the peer will listen on all available addresses matching that IP type. If "bind_address" is set to any valid address (e.g. "192.168.1.101", "::1", etc), the peer will only listen on the interface with that addresses (or fail if no interface with the given address exists).
*/
func (o *PacketPeerUDP) Listen(port int64, bindAddress string, recvBufSize int64) int64 {
	log.Println("Calling PacketPeerUDP.Listen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(port)
	goArguments[1] = reflect.ValueOf(bindAddress)
	goArguments[2] = reflect.ValueOf(recvBufSize)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "listen", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Close the UDP socket the [PacketPeerUDP] is currently listening on.
*/
func (o *PacketPeerUDP) Close() {
	log.Println("Calling PacketPeerUDP.Close()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "close", goArguments, "")

	log.Println("Got return value!")

}

/*
   Wait for a packet to arrive on the listening port, see [method listen].
*/
func (o *PacketPeerUDP) Wait() int64 {
	log.Println("Calling PacketPeerUDP.Wait()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "wait", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return whether this [PacketPeerUDP] is listening.
*/
func (o *PacketPeerUDP) IsListening() bool {
	log.Println("Calling PacketPeerUDP.IsListening()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_listening", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return the IP of the remote peer that sent the last packet(that was received with [method get_packet] or [method get_var]).
*/
func (o *PacketPeerUDP) GetPacketIp() string {
	log.Println("Calling PacketPeerUDP.GetPacketIp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_packet_ip", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the port of the remote peer that sent the last packet(that was received with [method get_packet] or [method get_var]).
*/
func (o *PacketPeerUDP) GetPacketPort() int64 {
	log.Println("Calling PacketPeerUDP.GetPacketPort()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_packet_port", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the destination address and port for sending packets and variables, a hostname will be resolved using if valid.
*/
func (o *PacketPeerUDP) SetDestAddress(host string, port int64) int64 {
	log.Println("Calling PacketPeerUDP.SetDestAddress()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(host)
	goArguments[1] = reflect.ValueOf(port)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "set_dest_address", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   PacketPeerUDPImplementer is an interface for PacketPeerUDP objects.
*/
type PacketPeerUDPImplementer interface {
	Class
}

/*
   SSL Stream peer. This object can be used to connect to SSL servers.
*/
type StreamPeerSSL struct {
	StreamPeer
}

func (o *StreamPeerSSL) baseClass() string {
	return "StreamPeerSSL"
}

/*

 */
func (o *StreamPeerSSL) AcceptStream(stream *StreamPeer) int64 {
	log.Println("Calling StreamPeerSSL.AcceptStream()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(stream)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "accept_stream", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Connect to a peer using an underlying [StreamPeer] "stream", when "validate_certs" is true, [StreamPeerSSL] will validate that the certificate presented by the peer matches the "for_hostname".
*/
func (o *StreamPeerSSL) ConnectToStream(stream *StreamPeer, validateCerts bool, forHostname string) int64 {
	log.Println("Calling StreamPeerSSL.ConnectToStream()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(stream)
	goArguments[1] = reflect.ValueOf(validateCerts)
	goArguments[2] = reflect.ValueOf(forHostname)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "connect_to_stream", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the status of the connection, one of STATUS_* enum.
*/
func (o *StreamPeerSSL) GetStatus() int64 {
	log.Println("Calling StreamPeerSSL.GetStatus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_status", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Disconnect from host.
*/
func (o *StreamPeerSSL) DisconnectFromStream() {
	log.Println("Calling StreamPeerSSL.DisconnectFromStream()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "disconnect_from_stream", goArguments, "")

	log.Println("Got return value!")

}

/*
   StreamPeerSSLImplementer is an interface for StreamPeerSSL objects.
*/
type StreamPeerSSLImplementer interface {
	Class
}

func newSingletonIP() *ip {
	obj := &ip{}
	ptr := C.godot_global_get_singleton(C.CString("IP"))
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*
   IP contains support functions for the IPv4 protocol. TCP/IP support is in different classes (see [StreamPeerTCP] and [TCP_Server]). IP provides hostname resolution support, both blocking and threaded.
*/
var IP = newSingletonIP()

/*
   IP contains support functions for the IPv4 protocol. TCP/IP support is in different classes (see [StreamPeerTCP] and [TCP_Server]). IP provides hostname resolution support, both blocking and threaded.
*/
type ip struct {
	Object
}

func (o *ip) baseClass() string {
	return "IP"
}

/*
   Returns a given hostname's IPv4 or IPv6 address when resolved (blocking-type method). The address type returned depends on the TYPE_* constant given as "ip_type".
*/
func (o *ip) ResolveHostname(host string, ipType int64) string {
	log.Println("Calling IP.ResolveHostname()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(host)
	goArguments[1] = reflect.ValueOf(ipType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "resolve_hostname", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Creates a queue item to resolve a hostname to an IPv4 or IPv6 address depending on the TYPE_* constant given as "ip_type". Returns the queue ID if successful, or RESOLVER_INVALID_ID on error.
*/
func (o *ip) ResolveHostnameQueueItem(host string, ipType int64) int64 {
	log.Println("Calling IP.ResolveHostnameQueueItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(host)
	goArguments[1] = reflect.ValueOf(ipType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "resolve_hostname_queue_item", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns a queued hostname's status as a RESOLVER_STATUS_* constant, given its queue "id".
*/
func (o *ip) GetResolveItemStatus(id int64) int64 {
	log.Println("Calling IP.GetResolveItemStatus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_resolve_item_status", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns a queued hostname's IP address, given its queue "id". Returns an empty string on error or if resolution hasn't happened yet (see [method get_resolve_item_status]).
*/
func (o *ip) GetResolveItemAddress(id int64) string {
	log.Println("Calling IP.GetResolveItemAddress()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_resolve_item_address", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Removes a given item "id" from the queue. This should be used to free a queue after it has completed to enable more queries to happen.
*/
func (o *ip) EraseResolveItem(id int64) {
	log.Println("Calling IP.EraseResolveItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "erase_resolve_item", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns all of the user's current IPv4 and IPv6 addresses as an array.
*/
func (o *ip) GetLocalAddresses() *Array {
	log.Println("Calling IP.GetLocalAddresses()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_local_addresses", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Removes all of a "hostname"'s cached references. If no "hostname" is given then all cached IP addresses are removed.
*/
func (o *ip) ClearCache(hostname string) {
	log.Println("Calling IP.ClearCache()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(hostname)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_cache", goArguments, "")

	log.Println("Got return value!")

}

/*
   PacketStreamPeer provides a wrapper for working using packets over a stream. This allows for using packet based code with StreamPeers. PacketPeerStream implements a custom protocol over the StreamPeer, so the user should not read or write to the wrapped StreamPeer directly.
*/
type PacketPeerStream struct {
	PacketPeer
}

func (o *PacketPeerStream) baseClass() string {
	return "PacketPeerStream"
}

/*
   Set the [StreamPeer] object to be wrapped.
*/
func (o *PacketPeerStream) SetStreamPeer(peer *Reference) {
	log.Println("Calling PacketPeerStream.SetStreamPeer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(peer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_stream_peer", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PacketPeerStream) SetInputBufferMaxSize(maxSizeBytes int64) {
	log.Println("Calling PacketPeerStream.SetInputBufferMaxSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(maxSizeBytes)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_input_buffer_max_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PacketPeerStream) SetOutputBufferMaxSize(maxSizeBytes int64) {
	log.Println("Calling PacketPeerStream.SetOutputBufferMaxSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(maxSizeBytes)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_output_buffer_max_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PacketPeerStream) GetInputBufferMaxSize() int64 {
	log.Println("Calling PacketPeerStream.GetInputBufferMaxSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_input_buffer_max_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PacketPeerStream) GetOutputBufferMaxSize() int64 {
	log.Println("Calling PacketPeerStream.GetOutputBufferMaxSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_output_buffer_max_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   PacketPeerStreamImplementer is an interface for PacketPeerStream objects.
*/
type PacketPeerStreamImplementer interface {
	Class
}

/*
   Main loop is the abstract main loop base class. All other main loop classes are derived from it. Upon application start, a [MainLoop] has to be provided to OS, else the application will exit. This happens automatically (and a [SceneTree] is created), unless a main [Script] is supplied, which may or not create and return a [MainLoop].
*/
type MainLoop struct {
	Object
}

func (o *MainLoop) baseClass() string {
	return "MainLoop"
}

/*

 */
func (o *MainLoop) X_InputEvent(ev *InputEvent) {
	log.Println("Calling MainLoop.X_InputEvent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ev)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_input_event", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MainLoop) X_InputText(text string) {
	log.Println("Calling MainLoop.X_InputText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_input_text", goArguments, "")

	log.Println("Got return value!")

}

/*
   Called once during initialization.
*/
func (o *MainLoop) X_Initialize() {
	log.Println("Calling MainLoop.X_Initialize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_initialize", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MainLoop) X_Iteration(delta float64) {
	log.Println("Calling MainLoop.X_Iteration()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(delta)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_iteration", goArguments, "")

	log.Println("Got return value!")

}

/*
   Called each idle frame with time since last call as an only argument.
*/
func (o *MainLoop) X_Idle(delta float64) {
	log.Println("Calling MainLoop.X_Idle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(delta)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_idle", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MainLoop) X_DropFiles(files *PoolStringArray, screen int64) {
	log.Println("Calling MainLoop.X_DropFiles()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(files)
	goArguments[1] = reflect.ValueOf(screen)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_drop_files", goArguments, "")

	log.Println("Got return value!")

}

/*
   Called before the program exits.
*/
func (o *MainLoop) X_Finalize() {
	log.Println("Calling MainLoop.X_Finalize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_finalize", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MainLoop) InputEvent(ev *InputEvent) {
	log.Println("Calling MainLoop.InputEvent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ev)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "input_event", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MainLoop) InputText(text string) {
	log.Println("Calling MainLoop.InputText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "input_text", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MainLoop) Init() {
	log.Println("Calling MainLoop.Init()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "init", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MainLoop) Iteration(delta float64) bool {
	log.Println("Calling MainLoop.Iteration()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(delta)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "iteration", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *MainLoop) Idle(delta float64) bool {
	log.Println("Calling MainLoop.Idle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(delta)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "idle", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *MainLoop) Finish() {
	log.Println("Calling MainLoop.Finish()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "finish", goArguments, "")

	log.Println("Got return value!")

}

/*
   MainLoopImplementer is an interface for MainLoop objects.
*/
type MainLoopImplementer interface {
	Class
}

/*
   Translations are resources that can be loaded/unloaded on demand. They map a string to another string.
*/
type Translation struct {
	Resource
}

func (o *Translation) baseClass() string {
	return "Translation"
}

/*
   Set the locale of the translation.
*/
func (o *Translation) SetLocale(locale string) {
	log.Println("Calling Translation.SetLocale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(locale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_locale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the locale of the translation.
*/
func (o *Translation) GetLocale() string {
	log.Println("Calling Translation.GetLocale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_locale", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Add a message for translation.
*/
func (o *Translation) AddMessage(srcMessage string, xlatedMessage string) {
	log.Println("Calling Translation.AddMessage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(srcMessage)
	goArguments[1] = reflect.ValueOf(xlatedMessage)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_message", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return a message for translation.
*/
func (o *Translation) GetMessage(srcMessage string) string {
	log.Println("Calling Translation.GetMessage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(srcMessage)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_message", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Erase a message.
*/
func (o *Translation) EraseMessage(srcMessage string) {
	log.Println("Calling Translation.EraseMessage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(srcMessage)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "erase_message", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return all the messages (keys).
*/
func (o *Translation) GetMessageList() *PoolStringArray {
	log.Println("Calling Translation.GetMessageList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_message_list", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*

 */
func (o *Translation) GetMessageCount() int64 {
	log.Println("Calling Translation.GetMessageCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_message_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *Translation) X_SetMessages(arg0 *PoolStringArray) {
	log.Println("Calling Translation.X_SetMessages()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_messages", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Translation) X_GetMessages() *PoolStringArray {
	log.Println("Calling Translation.X_GetMessages()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_messages", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   TranslationImplementer is an interface for Translation objects.
*/
type TranslationImplementer interface {
	Class
}

/*
   Optimized translation. Uses real-time compressed translations, which results in very small dictionaries.
*/
type PHashTranslation struct {
	Translation
}

func (o *PHashTranslation) baseClass() string {
	return "PHashTranslation"
}

/*

 */
func (o *PHashTranslation) Generate(from *Translation) {
	log.Println("Calling PHashTranslation.Generate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(from)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "generate", goArguments, "")

	log.Println("Got return value!")

}

/*
   PHashTranslationImplementer is an interface for PHashTranslation objects.
*/
type PHashTranslationImplementer interface {
	Class
}

/*
   Helper to manage UndoRedo in the editor or custom tools. It works by storing calls to functions in both 'do' an 'undo' lists. Common behavior is to create an action, then add do/undo calls to functions or property changes, then committing the action.
*/
type UndoRedo struct {
	Object
}

func (o *UndoRedo) baseClass() string {
	return "UndoRedo"
}

/*
   Create a new action. After this is called, do all your calls to [method add_do_method], [method add_undo_method], [method add_do_property] and [method add_undo_property].
*/
func (o *UndoRedo) CreateAction(name string, mergeMode int64) {
	log.Println("Calling UndoRedo.CreateAction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(mergeMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create_action", goArguments, "")

	log.Println("Got return value!")

}

/*
   Commit the action. All 'do' methods/properties are called/set when this function is called.
*/
func (o *UndoRedo) CommitAction() {
	log.Println("Calling UndoRedo.CommitAction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "commit_action", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *UndoRedo) AddDoMethod(object *Object, method string) *Variant {
	log.Println("Calling UndoRedo.AddDoMethod()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "add_do_method", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *UndoRedo) AddUndoMethod(object *Object, method string) *Variant {
	log.Println("Calling UndoRedo.AddUndoMethod()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "add_undo_method", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Set a property with a custom value.
*/
func (o *UndoRedo) AddDoProperty(object *Object, property string, value *Variant) {
	log.Println("Calling UndoRedo.AddDoProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(property)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_do_property", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undo setting of a property with a custom value.
*/
func (o *UndoRedo) AddUndoProperty(object *Object, property string, value *Variant) {
	log.Println("Calling UndoRedo.AddUndoProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(property)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_undo_property", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a 'do' reference that will be erased if the 'do' history is lost. This is useful mostly for new nodes created for the 'do' call. Do not use for resources.
*/
func (o *UndoRedo) AddDoReference(object *Object) {
	log.Println("Calling UndoRedo.AddDoReference()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(object)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_do_reference", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add an 'undo' reference that will be erased if the 'undo' history is lost. This is useful mostly for nodes removed with the 'do' call (not the 'undo' call!).
*/
func (o *UndoRedo) AddUndoReference(object *Object) {
	log.Println("Calling UndoRedo.AddUndoReference()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(object)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_undo_reference", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear the undo/redo history and associated references.
*/
func (o *UndoRedo) ClearHistory() {
	log.Println("Calling UndoRedo.ClearHistory()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_history", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the name of the current action.
*/
func (o *UndoRedo) GetCurrentActionName() string {
	log.Println("Calling UndoRedo.GetCurrentActionName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_action_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the version, each time a new action is committed, the version number of the UndoRedo is increased automatically. This is useful mostly to check if something changed from a saved version.
*/
func (o *UndoRedo) GetVersion() int64 {
	log.Println("Calling UndoRedo.GetVersion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_version", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *UndoRedo) SetMaxSteps(maxSteps int64) {
	log.Println("Calling UndoRedo.SetMaxSteps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(maxSteps)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_steps", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *UndoRedo) GetMaxSteps() int64 {
	log.Println("Calling UndoRedo.GetMaxSteps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_max_steps", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *UndoRedo) Redo() {
	log.Println("Calling UndoRedo.Redo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "redo", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *UndoRedo) Undo() {
	log.Println("Calling UndoRedo.Undo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "undo", goArguments, "")

	log.Println("Got return value!")

}

/*
   UndoRedoImplementer is an interface for UndoRedo objects.
*/
type UndoRedoImplementer interface {
	Class
}

/*
   Hyper-text transfer protocol client. Supports SSL and SSL server certificate verification. Can be reused to connect to different hosts and make many requests.
*/
type HTTPClient struct {
	Reference
}

func (o *HTTPClient) baseClass() string {
	return "HTTPClient"
}

/*
   Connect to a host. This needs to be done before any requests are sent. The host should not have http:// prepended but will strip the protocol identifier if provided. verify_host will check the SSL identity of the host if set to true.
*/
func (o *HTTPClient) ConnectToHost(host string, port int64, useSsl bool, verifyHost bool) int64 {
	log.Println("Calling HTTPClient.ConnectToHost()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(host)
	goArguments[1] = reflect.ValueOf(port)
	goArguments[2] = reflect.ValueOf(useSsl)
	goArguments[3] = reflect.ValueOf(verifyHost)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "connect_to_host", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set connection to use, for this client.
*/
func (o *HTTPClient) SetConnection(connection *StreamPeer) {
	log.Println("Calling HTTPClient.SetConnection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(connection)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_connection", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return current connection.
*/
func (o *HTTPClient) GetConnection() *StreamPeer {
	log.Println("Calling HTTPClient.GetConnection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection", goArguments, "*StreamPeer")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*StreamPeer)

	return returnValue

}

/*
   Sends a raw request to the connected host. The url is what is normally behind the hostname, i.e. in [code]http://somehost.com/index.php[/code], url would be "index.php". Headers are HTTP request headers. Sends body raw, as a byte array, does not encode it in any way.
*/
func (o *HTTPClient) RequestRaw(method int64, url string, headers *PoolStringArray, body *PoolByteArray) int64 {
	log.Println("Calling HTTPClient.RequestRaw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(method)
	goArguments[1] = reflect.ValueOf(url)
	goArguments[2] = reflect.ValueOf(headers)
	goArguments[3] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "request_raw", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Sends a request to the connected host. The url is what is normally behind the hostname, i.e. in [code]http://somehost.com/index.php[/code], url would be "index.php". Headers are HTTP request headers. To create a POST request with query strings to push to the server, do: [codeblock] var fields = {"username" : "user", "password" : "pass"} var queryString = httpClient.query_string_from_dict(fields) var headers = ["Content-Type: application/x-www-form-urlencoded", "Content-Length: " + str(queryString.length())] var result = httpClient.request(httpClient.METHOD_POST, "index.php", headers, queryString) [/codeblock]
*/
func (o *HTTPClient) Request(method int64, url string, headers *PoolStringArray, body string) int64 {
	log.Println("Calling HTTPClient.Request()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(method)
	goArguments[1] = reflect.ValueOf(url)
	goArguments[2] = reflect.ValueOf(headers)
	goArguments[3] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "request", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Stub function
*/
func (o *HTTPClient) SendBodyText(body string) int64 {
	log.Println("Calling HTTPClient.SendBodyText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "send_body_text", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Stub function
*/
func (o *HTTPClient) SendBodyData(body *PoolByteArray) int64 {
	log.Println("Calling HTTPClient.SendBodyData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "send_body_data", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Cloces the current connection, allows for reusal of [HTTPClient].
*/
func (o *HTTPClient) Close() {
	log.Println("Calling HTTPClient.Close()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "close", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether this [HTTPClient] has a response available.
*/
func (o *HTTPClient) HasResponse() bool {
	log.Println("Calling HTTPClient.HasResponse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_response", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return whether this [HTTPClient] has a response that is chunked.
*/
func (o *HTTPClient) IsResponseChunked() bool {
	log.Println("Calling HTTPClient.IsResponseChunked()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_response_chunked", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return the HTTP status code of the response.
*/
func (o *HTTPClient) GetResponseCode() int64 {
	log.Println("Calling HTTPClient.GetResponseCode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_response_code", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the response headers.
*/
func (o *HTTPClient) GetResponseHeaders() *PoolStringArray {
	log.Println("Calling HTTPClient.GetResponseHeaders()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_response_headers", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Returns all response headers as dictionary where the case-sensitivity of the keys and values is kept like the server delivers it. A value is a simple String, this string can have more than one value where "; " is used as separator. Structure: ("key":"value1; value2") Example: (content-length:12), (Content-Type:application/json; charset=UTF-8)
*/
func (o *HTTPClient) GetResponseHeadersAsDictionary() *Dictionary {
	log.Println("Calling HTTPClient.GetResponseHeadersAsDictionary()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_response_headers_as_dictionary", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
   Return the response's body length.
*/
func (o *HTTPClient) GetResponseBodyLength() int64 {
	log.Println("Calling HTTPClient.GetResponseBodyLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_response_body_length", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Reads one chunk from the response.
*/
func (o *HTTPClient) ReadResponseBodyChunk() *PoolByteArray {
	log.Println("Calling HTTPClient.ReadResponseBodyChunk()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "read_response_body_chunk", goArguments, "*PoolByteArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolByteArray)

	return returnValue

}

/*
   Sets the size of the buffer used and maximum bytes to read per iteration. see [method read_response_body_chunk]
*/
func (o *HTTPClient) SetReadChunkSize(bytes int64) {
	log.Println("Calling HTTPClient.SetReadChunkSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bytes)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_read_chunk_size", goArguments, "")

	log.Println("Got return value!")

}

/*
   If set to true, execution will block until all data is read from the response.
*/
func (o *HTTPClient) SetBlockingMode(enabled bool) {
	log.Println("Calling HTTPClient.SetBlockingMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_blocking_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether blocking mode is enabled.
*/
func (o *HTTPClient) IsBlockingModeEnabled() bool {
	log.Println("Calling HTTPClient.IsBlockingModeEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_blocking_mode_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns a STATUS_* enum constant. Need to call [method poll] in order to get status updates.
*/
func (o *HTTPClient) GetStatus() int64 {
	log.Println("Calling HTTPClient.GetStatus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_status", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   This needs to be called in order to have any request processed. Check results with [method get_status]
*/
func (o *HTTPClient) Poll() int64 {
	log.Println("Calling HTTPClient.Poll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "poll", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Generates a GET/POST application/x-www-form-urlencoded style query string from a provided dictionary, e.g.: [codeblock] var fields = {"username": "user", "password": "pass"} String queryString = httpClient.query_string_from_dict(fields) returns:= "username=user&password=pass" [/codeblock]
*/
func (o *HTTPClient) QueryStringFromDict(fields *Dictionary) string {
	log.Println("Calling HTTPClient.QueryStringFromDict()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fields)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "query_string_from_dict", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   HTTPClientImplementer is an interface for HTTPClient objects.
*/
type HTTPClientImplementer interface {
	Class
}

/*
   Interactive Resource Loader. This object is returned by ResourceLoader when performing an interactive load. It allows to load with high granularity, so this is mainly useful for displaying load bars/percentages.
*/
type ResourceInteractiveLoader struct {
	Reference
}

func (o *ResourceInteractiveLoader) baseClass() string {
	return "ResourceInteractiveLoader"
}

/*
   Return the loaded resource (only if loaded). Otherwise, returns null.
*/
func (o *ResourceInteractiveLoader) GetResource() *Resource {
	log.Println("Calling ResourceInteractiveLoader.GetResource()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_resource", goArguments, "*Resource")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Resource)

	return returnValue

}

/*
   Poll the load. If OK is returned, this means poll will have to be called again. If ERR_FILE_EOF is returned, them the load has finished and the resource can be obtained by calling [method get_resource].
*/
func (o *ResourceInteractiveLoader) Poll() int64 {
	log.Println("Calling ResourceInteractiveLoader.Poll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "poll", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ResourceInteractiveLoader) Wait() int64 {
	log.Println("Calling ResourceInteractiveLoader.Wait()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "wait", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the load stage. The total amount of stages can be queried with [method get_stage_count]
*/
func (o *ResourceInteractiveLoader) GetStage() int64 {
	log.Println("Calling ResourceInteractiveLoader.GetStage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stage", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the total amount of stages (calls to [method poll]) needed to completely load this resource.
*/
func (o *ResourceInteractiveLoader) GetStageCount() int64 {
	log.Println("Calling ResourceInteractiveLoader.GetStageCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stage_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   ResourceInteractiveLoaderImplementer is an interface for ResourceInteractiveLoader objects.
*/
type ResourceInteractiveLoaderImplementer interface {
	Class
}

/*

 */
type TriangleMesh struct {
	Reference
}

func (o *TriangleMesh) baseClass() string {
	return "TriangleMesh"
}

/*
   TriangleMeshImplementer is an interface for TriangleMesh objects.
*/
type TriangleMeshImplementer interface {
	Class
}

/*
   File type. This is used to permanently store data into the user device's file system and to read from it. This can be used to store game save data or player configuration files, for example. Here's a sample on how to write and read from a file: [codeblock] func save(content): var file = File.new() file.open("user://save_game.dat", file.WRITE) file.store_string(content) file.close() func load(): var file = File.new() file.open("user://save_game.dat", file.READ) var content = file.get_as_text() file.close() return content [/codeblock]
*/
type _File struct {
	Reference
}

func (o *_File) baseClass() string {
	return "_File"
}

/*
   Undocumented
*/
func (o *_File) OpenEncrypted(path string, modeFlags int64, key *PoolByteArray) int64 {
	log.Println("Calling _File.OpenEncrypted()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(path)
	goArguments[1] = reflect.ValueOf(modeFlags)
	goArguments[2] = reflect.ValueOf(key)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "open_encrypted", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *_File) OpenEncryptedWithPass(path string, modeFlags int64, pass string) int64 {
	log.Println("Calling _File.OpenEncryptedWithPass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(path)
	goArguments[1] = reflect.ValueOf(modeFlags)
	goArguments[2] = reflect.ValueOf(pass)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "open_encrypted_with_pass", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *_File) OpenCompressed(path string, modeFlags int64, compressionMode int64) int64 {
	log.Println("Calling _File.OpenCompressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(path)
	goArguments[1] = reflect.ValueOf(modeFlags)
	goArguments[2] = reflect.ValueOf(compressionMode)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "open_compressed", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *_File) Open(path string, flags int64) int64 {
	log.Println("Calling _File.Open()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(path)
	goArguments[1] = reflect.ValueOf(flags)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "open", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *_File) Close() {
	log.Println("Calling _File.Close()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "close", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *_File) IsOpen() bool {
	log.Println("Calling _File.IsOpen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_open", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *_File) Seek(position int64) {
	log.Println("Calling _File.Seek()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "seek", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *_File) SeekEnd(position int64) {
	log.Println("Calling _File.SeekEnd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "seek_end", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *_File) GetPosition() int64 {
	log.Println("Calling _File.GetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_position", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *_File) GetLen() int64 {
	log.Println("Calling _File.GetLen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_len", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *_File) EofReached() bool {
	log.Println("Calling _File.EofReached()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "eof_reached", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *_File) Get8() int64 {
	log.Println("Calling _File.Get8()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_8", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *_File) Get16() int64 {
	log.Println("Calling _File.Get16()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_16", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *_File) Get32() int64 {
	log.Println("Calling _File.Get32()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_32", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *_File) Get64() int64 {
	log.Println("Calling _File.Get64()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_64", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *_File) GetFloat() float64 {
	log.Println("Calling _File.GetFloat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_float", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Undocumented
*/
func (o *_File) GetDouble() float64 {
	log.Println("Calling _File.GetDouble()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_double", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Undocumented
*/
func (o *_File) GetReal() float64 {
	log.Println("Calling _File.GetReal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_real", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Undocumented
*/
func (o *_File) GetBuffer(len int64) *PoolByteArray {
	log.Println("Calling _File.GetBuffer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(len)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_buffer", goArguments, "*PoolByteArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolByteArray)

	return returnValue

}

/*
   Undocumented
*/
func (o *_File) GetLine() string {
	log.Println("Calling _File.GetLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_line", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *_File) GetAsText() string {
	log.Println("Calling _File.GetAsText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_as_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *_File) GetMd5(path string) string {
	log.Println("Calling _File.GetMd5()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_md5", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *_File) GetSha256(path string) string {
	log.Println("Calling _File.GetSha256()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sha256", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *_File) GetEndianSwap() bool {
	log.Println("Calling _File.GetEndianSwap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_endian_swap", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *_File) SetEndianSwap(enable bool) {
	log.Println("Calling _File.SetEndianSwap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_endian_swap", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *_File) GetError() int64 {
	log.Println("Calling _File.GetError()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_error", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *_File) GetVar() *Variant {
	log.Println("Calling _File.GetVar()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_var", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Undocumented
*/
func (o *_File) GetCsvLine(delim string) *PoolStringArray {
	log.Println("Calling _File.GetCsvLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(delim)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_csv_line", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Undocumented
*/
func (o *_File) Store8(value int64) {
	log.Println("Calling _File.Store8()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "store_8", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *_File) Store16(value int64) {
	log.Println("Calling _File.Store16()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "store_16", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *_File) Store32(value int64) {
	log.Println("Calling _File.Store32()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "store_32", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *_File) Store64(value int64) {
	log.Println("Calling _File.Store64()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "store_64", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *_File) StoreFloat(value float64) {
	log.Println("Calling _File.StoreFloat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "store_float", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *_File) StoreDouble(value float64) {
	log.Println("Calling _File.StoreDouble()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "store_double", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *_File) StoreReal(value float64) {
	log.Println("Calling _File.StoreReal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "store_real", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *_File) StoreBuffer(buffer *PoolByteArray) {
	log.Println("Calling _File.StoreBuffer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(buffer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "store_buffer", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *_File) StoreLine(line string) {
	log.Println("Calling _File.StoreLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(line)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "store_line", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *_File) StoreString(string string) {
	log.Println("Calling _File.StoreString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(string)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "store_string", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *_File) StoreVar(value *Variant) {
	log.Println("Calling _File.StoreVar()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "store_var", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *_File) StorePascalString(string string) {
	log.Println("Calling _File.StorePascalString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(string)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "store_pascal_string", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *_File) GetPascalString() string {
	log.Println("Calling _File.GetPascalString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pascal_string", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *_File) FileExists(path string) bool {
	log.Println("Calling _File.FileExists()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "file_exists", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *_File) GetModifiedTime(file string) int64 {
	log.Println("Calling _File.GetModifiedTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(file)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_modified_time", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   _FileImplementer is an interface for _File objects.
*/
type _FileImplementer interface {
	Class
}

/*
   Directory type. It is used to manage directories and their content (not restricted to the project folder). Here is an example on how to iterate through the files of a directory: [codeblock] func dir_contents(path): var dir = Directory.new() if dir.open(path) == OK: dir.list_dir_begin() var file_name = dir.get_next() while (file_name != ""): if dir.current_is_dir(): print("Found directory: " + file_name) else: print("Found file: " + file_name) file_name = dir.get_next() else: print("An error occurred when trying to access the path.") [/codeblock]
*/
type _Directory struct {
	Reference
}

func (o *_Directory) baseClass() string {
	return "_Directory"
}

/*
   Undocumented
*/
func (o *_Directory) Open(path string) int64 {
	log.Println("Calling _Directory.Open()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "open", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *_Directory) ListDirBegin(skipNavigational bool, skipHidden bool) int64 {
	log.Println("Calling _Directory.ListDirBegin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(skipNavigational)
	goArguments[1] = reflect.ValueOf(skipHidden)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "list_dir_begin", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *_Directory) GetNext() string {
	log.Println("Calling _Directory.GetNext()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_next", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *_Directory) CurrentIsDir() bool {
	log.Println("Calling _Directory.CurrentIsDir()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "current_is_dir", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *_Directory) ListDirEnd() {
	log.Println("Calling _Directory.ListDirEnd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "list_dir_end", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *_Directory) GetDriveCount() int64 {
	log.Println("Calling _Directory.GetDriveCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_drive_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *_Directory) GetDrive(idx int64) string {
	log.Println("Calling _Directory.GetDrive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_drive", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *_Directory) GetCurrentDrive() int64 {
	log.Println("Calling _Directory.GetCurrentDrive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_drive", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *_Directory) ChangeDir(todir string) int64 {
	log.Println("Calling _Directory.ChangeDir()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(todir)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "change_dir", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *_Directory) GetCurrentDir() string {
	log.Println("Calling _Directory.GetCurrentDir()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_dir", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *_Directory) MakeDir(path string) int64 {
	log.Println("Calling _Directory.MakeDir()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "make_dir", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *_Directory) MakeDirRecursive(path string) int64 {
	log.Println("Calling _Directory.MakeDirRecursive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "make_dir_recursive", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *_Directory) FileExists(path string) bool {
	log.Println("Calling _Directory.FileExists()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "file_exists", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *_Directory) DirExists(path string) bool {
	log.Println("Calling _Directory.DirExists()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "dir_exists", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *_Directory) GetSpaceLeft() int64 {
	log.Println("Calling _Directory.GetSpaceLeft()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_space_left", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *_Directory) Copy(from string, to string) int64 {
	log.Println("Calling _Directory.Copy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(to)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "copy", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *_Directory) Rename(from string, to string) int64 {
	log.Println("Calling _Directory.Rename()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(to)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "rename", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *_Directory) Remove(path string) int64 {
	log.Println("Calling _Directory.Remove()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "remove", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   _DirectoryImplementer is an interface for _Directory objects.
*/
type _DirectoryImplementer interface {
	Class
}

/*
   A unit of execution in a process. Can run methods on [Object]\ s simultaneously. The use of synchronization via [Mutex], [Semaphore] is advised if working with shared objects.
*/
type _Thread struct {
	Reference
}

func (o *_Thread) baseClass() string {
	return "_Thread"
}

/*
   Undocumented
*/
func (o *_Thread) Start(instance *Object, method string, userdata *Variant, priority int64) int64 {
	log.Println("Calling _Thread.Start()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(instance)
	goArguments[1] = reflect.ValueOf(method)
	goArguments[2] = reflect.ValueOf(userdata)
	goArguments[3] = reflect.ValueOf(priority)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "start", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *_Thread) GetId() string {
	log.Println("Calling _Thread.GetId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_id", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *_Thread) IsActive() bool {
	log.Println("Calling _Thread.IsActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_active", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *_Thread) WaitToFinish() *Variant {
	log.Println("Calling _Thread.WaitToFinish()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "wait_to_finish", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   _ThreadImplementer is an interface for _Thread objects.
*/
type _ThreadImplementer interface {
	Class
}

/*
   A synchronization Mutex. Element used in multi-threadding. Basically a binary [Semaphore]. Guarantees that only one thread has this lock, can be used to protect a critical section.
*/
type _Mutex struct {
	Reference
}

func (o *_Mutex) baseClass() string {
	return "_Mutex"
}

/*
   Undocumented
*/
func (o *_Mutex) Lock() {
	log.Println("Calling _Mutex.Lock()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "lock", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *_Mutex) TryLock() int64 {
	log.Println("Calling _Mutex.TryLock()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "try_lock", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *_Mutex) Unlock() {
	log.Println("Calling _Mutex.Unlock()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "unlock", goArguments, "")

	log.Println("Got return value!")

}

/*
   _MutexImplementer is an interface for _Mutex objects.
*/
type _MutexImplementer interface {
	Class
}

/*
   A synchronization Semaphore. Element used in multi-threadding. Initialized to zero on creation.
*/
type _Semaphore struct {
	Reference
}

func (o *_Semaphore) baseClass() string {
	return "_Semaphore"
}

/*
   Undocumented
*/
func (o *_Semaphore) Wait() int64 {
	log.Println("Calling _Semaphore.Wait()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "wait", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *_Semaphore) Post() int64 {
	log.Println("Calling _Semaphore.Post()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "post", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   _SemaphoreImplementer is an interface for _Semaphore objects.
*/
type _SemaphoreImplementer interface {
	Class
}

/*
   This class can serve as base to make custom XML parsers. Since XML is a very flexible standard, this interface is low level so it can be applied to any possible schema.
*/
type XMLParser struct {
	Reference
}

func (o *XMLParser) baseClass() string {
	return "XMLParser"
}

/*
   Read the next node of the file. This returns an error code.
*/
func (o *XMLParser) Read() int64 {
	log.Println("Calling XMLParser.Read()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "read", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the type of the current node. Compare with [code]NODE_*[/code] constants.
*/
func (o *XMLParser) GetNodeType() int64 {
	log.Println("Calling XMLParser.GetNodeType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the name of the current element node. This will raise an error if the current node type is not [code]NODE_ELEMENT[/code] nor [code]NODE_ELEMENT_END[/code]
*/
func (o *XMLParser) GetNodeName() string {
	log.Println("Calling XMLParser.GetNodeName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the contents of a text node. This will raise an error in any other type of node.
*/
func (o *XMLParser) GetNodeData() string {
	log.Println("Calling XMLParser.GetNodeData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_data", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the byte offset of the current node since the beginning of the file or buffer.
*/
func (o *XMLParser) GetNodeOffset() int64 {
	log.Println("Calling XMLParser.GetNodeOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_offset", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the amount of attributes in the current element.
*/
func (o *XMLParser) GetAttributeCount() int64 {
	log.Println("Calling XMLParser.GetAttributeCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_attribute_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the name of the attribute specified by the index in [code]idx[/code] argument.
*/
func (o *XMLParser) GetAttributeName(idx int64) string {
	log.Println("Calling XMLParser.GetAttributeName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_attribute_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the value of the attribute specified by the index in [code]idx[/code] argument.
*/
func (o *XMLParser) GetAttributeValue(idx int64) string {
	log.Println("Calling XMLParser.GetAttributeValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_attribute_value", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Check whether or not the current element has a certain attribute.
*/
func (o *XMLParser) HasAttribute(name string) bool {
	log.Println("Calling XMLParser.HasAttribute()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_attribute", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Get the value of a certain attribute of the current element by name. This will raise an error if the element has no such attribute.
*/
func (o *XMLParser) GetNamedAttributeValue(name string) string {
	log.Println("Calling XMLParser.GetNamedAttributeValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_named_attribute_value", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the value of a certain attribute of the current element by name. This will return an empty [String] if the attribute is not found.
*/
func (o *XMLParser) GetNamedAttributeValueSafe(name string) string {
	log.Println("Calling XMLParser.GetNamedAttributeValueSafe()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_named_attribute_value_safe", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Check whether the current element is empty (this only works for completely empty tags, e.g. <element \>).
*/
func (o *XMLParser) IsEmpty() bool {
	log.Println("Calling XMLParser.IsEmpty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_empty", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Get the current line in the parsed file (currently not implemented).
*/
func (o *XMLParser) GetCurrentLine() int64 {
	log.Println("Calling XMLParser.GetCurrentLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_line", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Skips the current section. If the node contains other elements, they will be ignored and the cursor will go to the closing of the current element.
*/
func (o *XMLParser) SkipSection() {
	log.Println("Calling XMLParser.SkipSection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "skip_section", goArguments, "")

	log.Println("Got return value!")

}

/*
   Move the buffer cursor to a certain offset (since the beginning) and read the next node there. This returns an error code.
*/
func (o *XMLParser) Seek(position int64) int64 {
	log.Println("Calling XMLParser.Seek()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "seek", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Open a XML file for parsing. This returns an error code.
*/
func (o *XMLParser) Open(file string) int64 {
	log.Println("Calling XMLParser.Open()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(file)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "open", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Open a XML raw buffer for parsing. This returns an error code.
*/
func (o *XMLParser) OpenBuffer(buffer *PoolByteArray) int64 {
	log.Println("Calling XMLParser.OpenBuffer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(buffer)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "open_buffer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   XMLParserImplementer is an interface for XMLParser objects.
*/
type XMLParserImplementer interface {
	Class
}

/*
   This helper class can be used to store [Variant] values on the filesystem using an INI-style formatting. The stored values as referenced by a section and a key. The stored data can be saved to or parsed from a file, though ConfigFile objects can also be used directly with accessing the filesystem. The following example shows how to parse a INI-style file from the system, read its contents and store new values in it: [codeblock] var config = ConfigFile.new() var err = config.load("user://settings.cfg") if err == OK: # if not, something went wrong with the file loading # Look for the display/width pair, and default to 1024 if missing var screen_width = get_value("display", "width", 1024) # Store a variable if and only it hasn't been defined yet if not config.has_section_key("audio", "mute"): config.set_value("audio", "mute", false) # Save the changes by overwriting the previous file config.save("user://settings.cfg") [/codeblock]
*/
type ConfigFile struct {
	Reference
}

func (o *ConfigFile) baseClass() string {
	return "ConfigFile"
}

/*
   Assign a value to the specified key of the the specified section. If the section and/or the key do not exist, they are created. Passing a [code]NULL[/code] value deletes the specified key if it exists (and deletes the section if it ends up empty once the key has been removed).
*/
func (o *ConfigFile) SetValue(section string, key string, value *Variant) {
	log.Println("Calling ConfigFile.SetValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(section)
	goArguments[1] = reflect.ValueOf(key)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_value", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current value for the specified section and key. If the section and/or the key do not exist, the method returns the value of the optional [i]default[/i] argument (and thus [code]NULL[/code] if not specified).
*/
func (o *ConfigFile) GetValue(section string, key string, aDefault *Variant) *Variant {
	log.Println("Calling ConfigFile.GetValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(section)
	goArguments[1] = reflect.ValueOf(key)
	goArguments[2] = reflect.ValueOf(aDefault)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_value", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Check if the specified section exists.
*/
func (o *ConfigFile) HasSection(section string) bool {
	log.Println("Calling ConfigFile.HasSection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(section)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_section", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Check if the specified section-key pair exists.
*/
func (o *ConfigFile) HasSectionKey(section string, key string) bool {
	log.Println("Calling ConfigFile.HasSectionKey()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(section)
	goArguments[1] = reflect.ValueOf(key)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_section_key", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return an array of all defined section identifiers.
*/
func (o *ConfigFile) GetSections() *PoolStringArray {
	log.Println("Calling ConfigFile.GetSections()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sections", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Return an array of all defined key identifiers in the specified section.
*/
func (o *ConfigFile) GetSectionKeys(section string) *PoolStringArray {
	log.Println("Calling ConfigFile.GetSectionKeys()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(section)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_section_keys", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*

 */
func (o *ConfigFile) EraseSection(section string) {
	log.Println("Calling ConfigFile.EraseSection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(section)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "erase_section", goArguments, "")

	log.Println("Got return value!")

}

/*
   Load the config file specified as a parameter. The file's contents are parsed and loaded in the ConfigFile object from which the method was called. The return value is one of the OK, FAILED or ERR_* constants listed in [@Global Scope] (if the load was successful, it returns OK).
*/
func (o *ConfigFile) Load(path string) int64 {
	log.Println("Calling ConfigFile.Load()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "load", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Save the contents of the ConfigFile object to the file specified as a parameter. The output file uses an INI-style structure. The return value is one of the OK, FAILED or ERR_* constants listed in [@Global Scope] (if the save was successful, it returns OK).
*/
func (o *ConfigFile) Save(path string) int64 {
	log.Println("Calling ConfigFile.Save()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "save", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   ConfigFileImplementer is an interface for ConfigFile objects.
*/
type ConfigFileImplementer interface {
	Class
}

/*

 */
type PCKPacker struct {
	Reference
}

func (o *PCKPacker) baseClass() string {
	return "PCKPacker"
}

/*

 */
func (o *PCKPacker) PckStart(pckName string, alignment int64) int64 {
	log.Println("Calling PCKPacker.PckStart()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(pckName)
	goArguments[1] = reflect.ValueOf(alignment)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "pck_start", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PCKPacker) AddFile(pckPath string, sourcePath string) int64 {
	log.Println("Calling PCKPacker.AddFile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(pckPath)
	goArguments[1] = reflect.ValueOf(sourcePath)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "add_file", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PCKPacker) Flush(verbose bool) int64 {
	log.Println("Calling PCKPacker.Flush()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(verbose)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "flush", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   PCKPackerImplementer is an interface for PCKPacker objects.
*/
type PCKPackerImplementer interface {
	Class
}

/*

 */
type PackedDataContainer struct {
	Resource
}

func (o *PackedDataContainer) baseClass() string {
	return "PackedDataContainer"
}

/*
   Undocumented
*/
func (o *PackedDataContainer) X_SetData(arg0 *PoolByteArray) {
	log.Println("Calling PackedDataContainer.X_SetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_data", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *PackedDataContainer) X_GetData() *PoolByteArray {
	log.Println("Calling PackedDataContainer.X_GetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_data", goArguments, "*PoolByteArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolByteArray)

	return returnValue

}

/*
   Undocumented
*/
func (o *PackedDataContainer) X_IterInit(arg0 *Array) *Variant {
	log.Println("Calling PackedDataContainer.X_IterInit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_iter_init", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Undocumented
*/
func (o *PackedDataContainer) X_IterGet(arg0 *Variant) *Variant {
	log.Println("Calling PackedDataContainer.X_IterGet()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_iter_get", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Undocumented
*/
func (o *PackedDataContainer) X_IterNext(arg0 *Array) *Variant {
	log.Println("Calling PackedDataContainer.X_IterNext()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_iter_next", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *PackedDataContainer) Pack(value *Variant) int64 {
	log.Println("Calling PackedDataContainer.Pack()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "pack", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PackedDataContainer) Size() int64 {
	log.Println("Calling PackedDataContainer.Size()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   PackedDataContainerImplementer is an interface for PackedDataContainer objects.
*/
type PackedDataContainerImplementer interface {
	Class
}

/*

 */
type PackedDataContainerRef struct {
	Reference
}

func (o *PackedDataContainerRef) baseClass() string {
	return "PackedDataContainerRef"
}

/*

 */
func (o *PackedDataContainerRef) Size() int64 {
	log.Println("Calling PackedDataContainerRef.Size()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *PackedDataContainerRef) X_IterInit(arg0 *Array) *Variant {
	log.Println("Calling PackedDataContainerRef.X_IterInit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_iter_init", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Undocumented
*/
func (o *PackedDataContainerRef) X_IterGet(arg0 *Variant) *Variant {
	log.Println("Calling PackedDataContainerRef.X_IterGet()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_iter_get", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Undocumented
*/
func (o *PackedDataContainerRef) X_IterNext(arg0 *Array) *Variant {
	log.Println("Calling PackedDataContainerRef.X_IterNext()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_iter_next", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Undocumented
*/
func (o *PackedDataContainerRef) X_IsDictionary() bool {
	log.Println("Calling PackedDataContainerRef.X_IsDictionary()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_is_dictionary", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   PackedDataContainerRefImplementer is an interface for PackedDataContainerRef objects.
*/
type PackedDataContainerRefImplementer interface {
	Class
}

/*
   A* (A star) is a computer algorithm that is widely used in pathfinding and graph traversal, the process of plotting an efficiently directed path between multiple points. It enjoys widespread use due to its performance and accuracy. Godot's A* implementation make use of vectors as points. You must add points manually with [method AStar.add_point] and create segments manually with [method AStar.connect_points]. So you can test if there is a path between two points with the [method AStar.are_points_connected] function, get the list of existing ids in the found path with [method AStar.get_id_path], or the points list with [method AStar.get_point_path].
*/
type AStar struct {
	Reference
}

func (o *AStar) baseClass() string {
	return "AStar"
}

/*
   Called when estimating the cost between a point and the path's ending point.
*/
func (o *AStar) X_EstimateCost(fromId int64, toId int64) {
	log.Println("Calling AStar.X_EstimateCost()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(fromId)
	goArguments[1] = reflect.ValueOf(toId)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_estimate_cost", goArguments, "")

	log.Println("Got return value!")

}

/*
   Called when computing the cost between two connected points.
*/
func (o *AStar) X_ComputeCost(fromId int64, toId int64) {
	log.Println("Calling AStar.X_ComputeCost()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(fromId)
	goArguments[1] = reflect.ValueOf(toId)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_compute_cost", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns an id with no point associated to it.
*/
func (o *AStar) GetAvailablePointId() int64 {
	log.Println("Calling AStar.GetAvailablePointId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_available_point_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Adds a new point at the given position with the given identifier. The algorithm prefers points with lower [code]weight_scale[/code] to form a path. The [code]id[/code] must be 0 or larger, and the [code]weight_scale[/code] must be 1 or larger. [codeblock] var as = AStar.new() as.add_point(1, Vector3(1,0,0), 4) # Adds the point (1,0,0) with weight_scale=4 and id=1 [/codeblock]
*/
func (o *AStar) AddPoint(id int64, position *Vector3, weightScale float64) {
	log.Println("Calling AStar.AddPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(position)
	goArguments[2] = reflect.ValueOf(weightScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_point", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the position of the point associated with the given id.
*/
func (o *AStar) GetPointPosition(id int64) *Vector3 {
	log.Println("Calling AStar.GetPointPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_position", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Returns the weight scale of the point associated with the given id.
*/
func (o *AStar) GetPointWeightScale(id int64) float64 {
	log.Println("Calling AStar.GetPointWeightScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_weight_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Removes the point associated with the given id from the points pool.
*/
func (o *AStar) RemovePoint(id int64) {
	log.Println("Calling AStar.RemovePoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_point", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether a point associated with the given id exists.
*/
func (o *AStar) HasPoint(id int64) bool {
	log.Println("Calling AStar.HasPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_point", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *AStar) GetPoints() *Array {
	log.Println("Calling AStar.GetPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_points", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Creates a segment between the given points. [codeblock] var as = AStar.new() as.add_point(1, Vector3(1,1,0)) as.add_point(2, Vector3(0,5,0)) as.connect_points(1, 2, false) # If bidirectional=false it's only possible to go from point 1 to point 2 # and not from point 2 to point 1. [/codeblock]
*/
func (o *AStar) ConnectPoints(id int64, toId int64, bidirectional bool) {
	log.Println("Calling AStar.ConnectPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(toId)
	goArguments[2] = reflect.ValueOf(bidirectional)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "connect_points", goArguments, "")

	log.Println("Got return value!")

}

/*
   Deletes the segment between the given points.
*/
func (o *AStar) DisconnectPoints(id int64, toId int64) {
	log.Println("Calling AStar.DisconnectPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(toId)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "disconnect_points", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether there is a connection/segment between the given points.
*/
func (o *AStar) ArePointsConnected(id int64, toId int64) bool {
	log.Println("Calling AStar.ArePointsConnected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(toId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "are_points_connected", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Clears all the points and segments.
*/
func (o *AStar) Clear() {
	log.Println("Calling AStar.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the id of the closest point to [code]to_position[/code]. Returns -1 if there are no points in the points pool.
*/
func (o *AStar) GetClosestPoint(toPosition *Vector3) int64 {
	log.Println("Calling AStar.GetClosestPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toPosition)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_point", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the closest position to [code]to_position[/code] that resides inside a segment between two connected points. [codeblock] var as = AStar.new() as.add_point(1, Vector3(0,0,0)) as.add_point(2, Vector3(0,5,0)) as.connect_points(1, 2) var res = as.get_closest_position_in_segment(Vector3(3,3,0)) # returns (0, 3, 0) [/codeblock] The result is in the segment that goes from [code]y=0[/code] to [code]y=5[/code]. It's the closest position in the segment to the given point.
*/
func (o *AStar) GetClosestPositionInSegment(toPosition *Vector3) *Vector3 {
	log.Println("Calling AStar.GetClosestPositionInSegment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toPosition)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_position_in_segment", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Returns an array with the points that are in the path found by AStar between the given points. The array is ordered from the starting point to the ending point of the path.
*/
func (o *AStar) GetPointPath(fromId int64, toId int64) *PoolVector3Array {
	log.Println("Calling AStar.GetPointPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(fromId)
	goArguments[1] = reflect.ValueOf(toId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_path", goArguments, "*PoolVector3Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector3Array)

	return returnValue

}

/*
   Returns an array with the ids of the points that form the path found by AStar between the given points. The array is ordered from the starting point to the ending point of the path. [codeblock] var as = AStar.new() as.add_point(1, Vector3(0,0,0)) as.add_point(2, Vector3(0,1,0), 1) # default weight is 1 as.add_point(3, Vector3(1,1,0)) as.add_point(4, Vector3(2,0,0)) as.connect_points(1, 2, false) as.connect_points(2, 3, false) as.connect_points(4, 3, false) as.connect_points(1, 4, false) as.connect_points(5, 4, false) var res = as.get_id_path(1, 3) # returns [1, 2, 3] [/codeblock] If you change the 2nd point's weight to 3, then the result will be [code][1, 4, 3][/code] instead, because now even though the distance is longer, it's "easier" to get through point 4 than through point 2.
*/
func (o *AStar) GetIdPath(fromId int64, toId int64) *PoolIntArray {
	log.Println("Calling AStar.GetIdPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(fromId)
	goArguments[1] = reflect.ValueOf(toId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_id_path", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*
   AStarImplementer is an interface for AStar objects.
*/
type AStarImplementer interface {
	Class
}

/*

 */
type EncodedObjectAsID struct {
	Reference
}

func (o *EncodedObjectAsID) baseClass() string {
	return "EncodedObjectAsID"
}

/*

 */
func (o *EncodedObjectAsID) SetObjectId(id int64) {
	log.Println("Calling EncodedObjectAsID.SetObjectId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_object_id", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EncodedObjectAsID) GetObjectId() int64 {
	log.Println("Calling EncodedObjectAsID.GetObjectId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_object_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   EncodedObjectAsIDImplementer is an interface for EncodedObjectAsID objects.
*/
type EncodedObjectAsIDImplementer interface {
	Class
}

/*

 */
type JSONParseResult struct {
	Reference
}

func (o *JSONParseResult) baseClass() string {
	return "JSONParseResult"
}

/*

 */
func (o *JSONParseResult) GetError() int64 {
	log.Println("Calling JSONParseResult.GetError()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_error", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *JSONParseResult) GetErrorString() string {
	log.Println("Calling JSONParseResult.GetErrorString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_error_string", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *JSONParseResult) GetErrorLine() int64 {
	log.Println("Calling JSONParseResult.GetErrorLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_error_line", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *JSONParseResult) GetResult() *Variant {
	log.Println("Calling JSONParseResult.GetResult()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_result", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *JSONParseResult) SetError(error int64) {
	log.Println("Calling JSONParseResult.SetError()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(error)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_error", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *JSONParseResult) SetErrorString(errorString string) {
	log.Println("Calling JSONParseResult.SetErrorString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(errorString)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_error_string", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *JSONParseResult) SetErrorLine(errorLine int64) {
	log.Println("Calling JSONParseResult.SetErrorLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(errorLine)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_error_line", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *JSONParseResult) SetResult(result *Variant) {
	log.Println("Calling JSONParseResult.SetResult()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(result)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_result", goArguments, "")

	log.Println("Got return value!")

}

/*
   JSONParseResultImplementer is an interface for JSONParseResult objects.
*/
type JSONParseResultImplementer interface {
	Class
}

/*

 */
type IP_Unix struct {
	ip
}

func (o *IP_Unix) baseClass() string {
	return "IP_Unix"
}

/*
   IP_UnixImplementer is an interface for IP_Unix objects.
*/
type IP_UnixImplementer interface {
	Class
}

func newSingletonGeometry() *geometry {
	obj := &geometry{}
	ptr := C.godot_global_get_singleton(C.CString("_Geometry"))
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*

 */
var Geometry = newSingletonGeometry()

/*

 */
type geometry struct {
	Object
}

func (o *geometry) baseClass() string {
	return "_Geometry"
}

/*
   Undocumented
*/
func (o *geometry) BuildBoxPlanes(extents *Vector3) *Array {
	log.Println("Calling _Geometry.BuildBoxPlanes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(extents)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "build_box_planes", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Undocumented
*/
func (o *geometry) BuildCylinderPlanes(radius float64, height float64, sides int64, axis int64) *Array {
	log.Println("Calling _Geometry.BuildCylinderPlanes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(radius)
	goArguments[1] = reflect.ValueOf(height)
	goArguments[2] = reflect.ValueOf(sides)
	goArguments[3] = reflect.ValueOf(axis)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "build_cylinder_planes", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Undocumented
*/
func (o *geometry) BuildCapsulePlanes(radius float64, height float64, sides int64, lats int64, axis int64) *Array {
	log.Println("Calling _Geometry.BuildCapsulePlanes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(radius)
	goArguments[1] = reflect.ValueOf(height)
	goArguments[2] = reflect.ValueOf(sides)
	goArguments[3] = reflect.ValueOf(lats)
	goArguments[4] = reflect.ValueOf(axis)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "build_capsule_planes", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Undocumented
*/
func (o *geometry) SegmentIntersectsCircle(segmentFrom *Vector2, segmentTo *Vector2, circlePosition *Vector2, circleRadius float64) float64 {
	log.Println("Calling _Geometry.SegmentIntersectsCircle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(segmentFrom)
	goArguments[1] = reflect.ValueOf(segmentTo)
	goArguments[2] = reflect.ValueOf(circlePosition)
	goArguments[3] = reflect.ValueOf(circleRadius)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "segment_intersects_circle", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Undocumented
*/
func (o *geometry) SegmentIntersectsSegment2D(fromA *Vector2, toA *Vector2, fromB *Vector2, toB *Vector2) *Variant {
	log.Println("Calling _Geometry.SegmentIntersectsSegment2D()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(fromA)
	goArguments[1] = reflect.ValueOf(toA)
	goArguments[2] = reflect.ValueOf(fromB)
	goArguments[3] = reflect.ValueOf(toB)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "segment_intersects_segment_2d", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Undocumented
*/
func (o *geometry) GetClosestPointsBetweenSegments2D(p1 *Vector2, q1 *Vector2, p2 *Vector2, q2 *Vector2) *PoolVector2Array {
	log.Println("Calling _Geometry.GetClosestPointsBetweenSegments2D()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(p1)
	goArguments[1] = reflect.ValueOf(q1)
	goArguments[2] = reflect.ValueOf(p2)
	goArguments[3] = reflect.ValueOf(q2)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_points_between_segments_2d", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*
   Undocumented
*/
func (o *geometry) GetClosestPointsBetweenSegments(p1 *Vector3, p2 *Vector3, q1 *Vector3, q2 *Vector3) *PoolVector3Array {
	log.Println("Calling _Geometry.GetClosestPointsBetweenSegments()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(p1)
	goArguments[1] = reflect.ValueOf(p2)
	goArguments[2] = reflect.ValueOf(q1)
	goArguments[3] = reflect.ValueOf(q2)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_points_between_segments", goArguments, "*PoolVector3Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector3Array)

	return returnValue

}

/*
   Undocumented
*/
func (o *geometry) GetClosestPointToSegment2D(point *Vector2, s1 *Vector2, s2 *Vector2) *Vector2 {
	log.Println("Calling _Geometry.GetClosestPointToSegment2D()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(point)
	goArguments[1] = reflect.ValueOf(s1)
	goArguments[2] = reflect.ValueOf(s2)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_point_to_segment_2d", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Undocumented
*/
func (o *geometry) GetClosestPointToSegment(point *Vector3, s1 *Vector3, s2 *Vector3) *Vector3 {
	log.Println("Calling _Geometry.GetClosestPointToSegment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(point)
	goArguments[1] = reflect.ValueOf(s1)
	goArguments[2] = reflect.ValueOf(s2)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_point_to_segment", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Undocumented
*/
func (o *geometry) GetClosestPointToSegmentUncapped2D(point *Vector2, s1 *Vector2, s2 *Vector2) *Vector2 {
	log.Println("Calling _Geometry.GetClosestPointToSegmentUncapped2D()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(point)
	goArguments[1] = reflect.ValueOf(s1)
	goArguments[2] = reflect.ValueOf(s2)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_point_to_segment_uncapped_2d", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Undocumented
*/
func (o *geometry) GetClosestPointToSegmentUncapped(point *Vector3, s1 *Vector3, s2 *Vector3) *Vector3 {
	log.Println("Calling _Geometry.GetClosestPointToSegmentUncapped()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(point)
	goArguments[1] = reflect.ValueOf(s1)
	goArguments[2] = reflect.ValueOf(s2)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_point_to_segment_uncapped", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Undocumented
*/
func (o *geometry) GetUv84NormalBit(normal *Vector3) int64 {
	log.Println("Calling _Geometry.GetUv84NormalBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(normal)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_uv84_normal_bit", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *geometry) RayIntersectsTriangle(from *Vector3, dir *Vector3, a *Vector3, b *Vector3, c *Vector3) *Variant {
	log.Println("Calling _Geometry.RayIntersectsTriangle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(dir)
	goArguments[2] = reflect.ValueOf(a)
	goArguments[3] = reflect.ValueOf(b)
	goArguments[4] = reflect.ValueOf(c)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "ray_intersects_triangle", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Undocumented
*/
func (o *geometry) SegmentIntersectsTriangle(from *Vector3, to *Vector3, a *Vector3, b *Vector3, c *Vector3) *Variant {
	log.Println("Calling _Geometry.SegmentIntersectsTriangle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(to)
	goArguments[2] = reflect.ValueOf(a)
	goArguments[3] = reflect.ValueOf(b)
	goArguments[4] = reflect.ValueOf(c)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "segment_intersects_triangle", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Undocumented
*/
func (o *geometry) SegmentIntersectsSphere(from *Vector3, to *Vector3, spherePosition *Vector3, sphereRadius float64) *PoolVector3Array {
	log.Println("Calling _Geometry.SegmentIntersectsSphere()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(to)
	goArguments[2] = reflect.ValueOf(spherePosition)
	goArguments[3] = reflect.ValueOf(sphereRadius)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "segment_intersects_sphere", goArguments, "*PoolVector3Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector3Array)

	return returnValue

}

/*
   Undocumented
*/
func (o *geometry) SegmentIntersectsCylinder(from *Vector3, to *Vector3, height float64, radius float64) *PoolVector3Array {
	log.Println("Calling _Geometry.SegmentIntersectsCylinder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(to)
	goArguments[2] = reflect.ValueOf(height)
	goArguments[3] = reflect.ValueOf(radius)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "segment_intersects_cylinder", goArguments, "*PoolVector3Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector3Array)

	return returnValue

}

/*
   Undocumented
*/
func (o *geometry) SegmentIntersectsConvex(from *Vector3, to *Vector3, planes *Array) *PoolVector3Array {
	log.Println("Calling _Geometry.SegmentIntersectsConvex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(to)
	goArguments[2] = reflect.ValueOf(planes)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "segment_intersects_convex", goArguments, "*PoolVector3Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector3Array)

	return returnValue

}

/*
   Undocumented
*/
func (o *geometry) PointIsInsideTriangle(point *Vector2, a *Vector2, b *Vector2, c *Vector2) bool {
	log.Println("Calling _Geometry.PointIsInsideTriangle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(point)
	goArguments[1] = reflect.ValueOf(a)
	goArguments[2] = reflect.ValueOf(b)
	goArguments[3] = reflect.ValueOf(c)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "point_is_inside_triangle", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *geometry) TriangulatePolygon(polygon *PoolVector2Array) *PoolIntArray {
	log.Println("Calling _Geometry.TriangulatePolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(polygon)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "triangulate_polygon", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*
   Undocumented
*/
func (o *geometry) MakeAtlas(sizes *PoolVector2Array) *Dictionary {
	log.Println("Calling _Geometry.MakeAtlas()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sizes)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "make_atlas", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

func newSingletonResourceLoader() *resourceLoader {
	obj := &resourceLoader{}
	ptr := C.godot_global_get_singleton(C.CString("_ResourceLoader"))
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*
   Resource Loader. This is a static object accessible as [ResourceLoader]. GDScript has a simplified load() function, though.
*/
var ResourceLoader = newSingletonResourceLoader()

/*
   Resource Loader. This is a static object accessible as [ResourceLoader]. GDScript has a simplified load() function, though.
*/
type resourceLoader struct {
	Object
}

func (o *resourceLoader) baseClass() string {
	return "_ResourceLoader"
}

/*
   Undocumented
*/
func (o *resourceLoader) LoadInteractive(path string, typeHint string) *ResourceInteractiveLoader {
	log.Println("Calling _ResourceLoader.LoadInteractive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(path)
	goArguments[1] = reflect.ValueOf(typeHint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "load_interactive", goArguments, "*ResourceInteractiveLoader")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*ResourceInteractiveLoader)

	return returnValue

}

/*
   Undocumented
*/
func (o *resourceLoader) Load(path string, typeHint string, pNoCache bool) *Resource {
	log.Println("Calling _ResourceLoader.Load()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(path)
	goArguments[1] = reflect.ValueOf(typeHint)
	goArguments[2] = reflect.ValueOf(pNoCache)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "load", goArguments, "*Resource")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Resource)

	return returnValue

}

/*
   Undocumented
*/
func (o *resourceLoader) GetRecognizedExtensionsForType(aType string) *PoolStringArray {
	log.Println("Calling _ResourceLoader.GetRecognizedExtensionsForType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_recognized_extensions_for_type", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Undocumented
*/
func (o *resourceLoader) SetAbortOnMissingResources(abort bool) {
	log.Println("Calling _ResourceLoader.SetAbortOnMissingResources()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(abort)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_abort_on_missing_resources", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *resourceLoader) GetDependencies(path string) *PoolStringArray {
	log.Println("Calling _ResourceLoader.GetDependencies()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dependencies", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Undocumented
*/
func (o *resourceLoader) Has(path string) bool {
	log.Println("Calling _ResourceLoader.Has()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

func newSingletonResourceSaver() *resourceSaver {
	obj := &resourceSaver{}
	ptr := C.godot_global_get_singleton(C.CString("_ResourceSaver"))
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*
   Resource Saving Interface. This interface is used for saving resources to disk.
*/
var ResourceSaver = newSingletonResourceSaver()

/*
   Resource Saving Interface. This interface is used for saving resources to disk.
*/
type resourceSaver struct {
	Object
}

func (o *resourceSaver) baseClass() string {
	return "_ResourceSaver"
}

/*
   Undocumented
*/
func (o *resourceSaver) Save(path string, resource *Resource, flags int64) int64 {
	log.Println("Calling _ResourceSaver.Save()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(path)
	goArguments[1] = reflect.ValueOf(resource)
	goArguments[2] = reflect.ValueOf(flags)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "save", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *resourceSaver) GetRecognizedExtensions(aType *Resource) *PoolStringArray {
	log.Println("Calling _ResourceSaver.GetRecognizedExtensions()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_recognized_extensions", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

func newSingletonOS() *os {
	obj := &os{}
	ptr := C.godot_global_get_singleton(C.CString("_OS"))
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*
   Operating System functions. OS Wraps the most common functionality to communicate with the host Operating System, such as: mouse grabbing, mouse cursors, clipboard, video mode, date and time, timers, environment variables, execution of binaries, command line, etc.
*/
var OS = newSingletonOS()

/*
   Operating System functions. OS Wraps the most common functionality to communicate with the host Operating System, such as: mouse grabbing, mouse cursors, clipboard, video mode, date and time, timers, environment variables, execution of binaries, command line, etc.
*/
type os struct {
	Object
}

func (o *os) baseClass() string {
	return "_OS"
}

/*
   Undocumented
*/
func (o *os) SetClipboard(clipboard string) {
	log.Println("Calling _OS.SetClipboard()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(clipboard)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_clipboard", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) GetClipboard() string {
	log.Println("Calling _OS.GetClipboard()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_clipboard", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetScreenCount() int64 {
	log.Println("Calling _OS.GetScreenCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_screen_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetCurrentScreen() int64 {
	log.Println("Calling _OS.GetCurrentScreen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_screen", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) SetCurrentScreen(screen int64) {
	log.Println("Calling _OS.SetCurrentScreen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(screen)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_current_screen", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) GetScreenPosition(screen int64) *Vector2 {
	log.Println("Calling _OS.GetScreenPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(screen)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_screen_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetScreenSize(screen int64) *Vector2 {
	log.Println("Calling _OS.GetScreenSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(screen)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_screen_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetScreenDpi(screen int64) int64 {
	log.Println("Calling _OS.GetScreenDpi()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(screen)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_screen_dpi", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetWindowPosition() *Vector2 {
	log.Println("Calling _OS.GetWindowPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_window_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) SetWindowPosition(position *Vector2) {
	log.Println("Calling _OS.SetWindowPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_window_position", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) GetWindowSize() *Vector2 {
	log.Println("Calling _OS.GetWindowSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_window_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) SetWindowSize(size *Vector2) {
	log.Println("Calling _OS.SetWindowSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_window_size", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) SetWindowFullscreen(enabled bool) {
	log.Println("Calling _OS.SetWindowFullscreen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_window_fullscreen", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) IsWindowFullscreen() bool {
	log.Println("Calling _OS.IsWindowFullscreen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_window_fullscreen", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) SetWindowResizable(enabled bool) {
	log.Println("Calling _OS.SetWindowResizable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_window_resizable", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) IsWindowResizable() bool {
	log.Println("Calling _OS.IsWindowResizable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_window_resizable", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) SetWindowMinimized(enabled bool) {
	log.Println("Calling _OS.SetWindowMinimized()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_window_minimized", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) IsWindowMinimized() bool {
	log.Println("Calling _OS.IsWindowMinimized()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_window_minimized", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) SetWindowMaximized(enabled bool) {
	log.Println("Calling _OS.SetWindowMaximized()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_window_maximized", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) IsWindowMaximized() bool {
	log.Println("Calling _OS.IsWindowMaximized()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_window_maximized", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) RequestAttention() {
	log.Println("Calling _OS.RequestAttention()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "request_attention", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) SetBorderlessWindow(borderless bool) {
	log.Println("Calling _OS.SetBorderlessWindow()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(borderless)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_borderless_window", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) GetBorderlessWindow() bool {
	log.Println("Calling _OS.GetBorderlessWindow()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_borderless_window", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) SetImePosition(position *Vector2) {
	log.Println("Calling _OS.SetImePosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ime_position", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) SetScreenOrientation(orientation int64) {
	log.Println("Calling _OS.SetScreenOrientation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(orientation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_screen_orientation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) GetScreenOrientation() int64 {
	log.Println("Calling _OS.GetScreenOrientation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_screen_orientation", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) SetKeepScreenOn(enabled bool) {
	log.Println("Calling _OS.SetKeepScreenOn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_keep_screen_on", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) IsKeepScreenOn() bool {
	log.Println("Calling _OS.IsKeepScreenOn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_keep_screen_on", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) HasTouchscreenUiHint() bool {
	log.Println("Calling _OS.HasTouchscreenUiHint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_touchscreen_ui_hint", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) SetWindowTitle(title string) {
	log.Println("Calling _OS.SetWindowTitle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(title)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_window_title", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) SetLowProcessorUsageMode(enable bool) {
	log.Println("Calling _OS.SetLowProcessorUsageMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_low_processor_usage_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) IsInLowProcessorUsageMode() bool {
	log.Println("Calling _OS.IsInLowProcessorUsageMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_in_low_processor_usage_mode", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetProcessorCount() int64 {
	log.Println("Calling _OS.GetProcessorCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_processor_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetExecutablePath() string {
	log.Println("Calling _OS.GetExecutablePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_executable_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) Execute(path string, arguments *PoolStringArray, blocking bool, output *Array) int64 {
	log.Println("Calling _OS.Execute()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(path)
	goArguments[1] = reflect.ValueOf(arguments)
	goArguments[2] = reflect.ValueOf(blocking)
	goArguments[3] = reflect.ValueOf(output)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "execute", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) Kill(pid int64) int64 {
	log.Println("Calling _OS.Kill()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pid)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "kill", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) ShellOpen(uri string) int64 {
	log.Println("Calling _OS.ShellOpen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(uri)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shell_open", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetProcessId() int64 {
	log.Println("Calling _OS.GetProcessId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_process_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetEnvironment(environment string) string {
	log.Println("Calling _OS.GetEnvironment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(environment)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_environment", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) HasEnvironment(environment string) bool {
	log.Println("Calling _OS.HasEnvironment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(environment)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_environment", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetName() string {
	log.Println("Calling _OS.GetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetCmdlineArgs() *PoolStringArray {
	log.Println("Calling _OS.GetCmdlineArgs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cmdline_args", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetDatetime(utc bool) *Dictionary {
	log.Println("Calling _OS.GetDatetime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(utc)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_datetime", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetDate(utc bool) *Dictionary {
	log.Println("Calling _OS.GetDate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(utc)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_date", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetTime(utc bool) *Dictionary {
	log.Println("Calling _OS.GetTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(utc)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_time", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetTimeZoneInfo() *Dictionary {
	log.Println("Calling _OS.GetTimeZoneInfo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_time_zone_info", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetUnixTime() int64 {
	log.Println("Calling _OS.GetUnixTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_unix_time", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetDatetimeFromUnixTime(unixTimeVal int64) *Dictionary {
	log.Println("Calling _OS.GetDatetimeFromUnixTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(unixTimeVal)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_datetime_from_unix_time", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetUnixTimeFromDatetime(datetime *Dictionary) int64 {
	log.Println("Calling _OS.GetUnixTimeFromDatetime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(datetime)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_unix_time_from_datetime", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetSystemTimeSecs() int64 {
	log.Println("Calling _OS.GetSystemTimeSecs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_system_time_secs", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) SetIcon(icon *Image) {
	log.Println("Calling _OS.SetIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(icon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_icon", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) GetExitCode() int64 {
	log.Println("Calling _OS.GetExitCode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_exit_code", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) SetExitCode(code int64) {
	log.Println("Calling _OS.SetExitCode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(code)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_exit_code", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) DelayUsec(usec int64) {
	log.Println("Calling _OS.DelayUsec()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(usec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "delay_usec", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) DelayMsec(msec int64) {
	log.Println("Calling _OS.DelayMsec()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(msec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "delay_msec", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) GetTicksMsec() int64 {
	log.Println("Calling _OS.GetTicksMsec()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ticks_msec", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetSplashTickMsec() int64 {
	log.Println("Calling _OS.GetSplashTickMsec()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_splash_tick_msec", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetLocale() string {
	log.Println("Calling _OS.GetLocale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_locale", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetLatinKeyboardVariant() string {
	log.Println("Calling _OS.GetLatinKeyboardVariant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_latin_keyboard_variant", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetModelName() string {
	log.Println("Calling _OS.GetModelName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_model_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) CanDraw() bool {
	log.Println("Calling _OS.CanDraw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "can_draw", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) IsStdoutVerbose() bool {
	log.Println("Calling _OS.IsStdoutVerbose()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_stdout_verbose", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) CanUseThreads() bool {
	log.Println("Calling _OS.CanUseThreads()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "can_use_threads", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) IsDebugBuild() bool {
	log.Println("Calling _OS.IsDebugBuild()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_debug_build", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) DumpMemoryToFile(file string) {
	log.Println("Calling _OS.DumpMemoryToFile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(file)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "dump_memory_to_file", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) DumpResourcesToFile(file string) {
	log.Println("Calling _OS.DumpResourcesToFile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(file)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "dump_resources_to_file", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) HasVirtualKeyboard() bool {
	log.Println("Calling _OS.HasVirtualKeyboard()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_virtual_keyboard", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) ShowVirtualKeyboard(existingText string) {
	log.Println("Calling _OS.ShowVirtualKeyboard()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(existingText)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "show_virtual_keyboard", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) HideVirtualKeyboard() {
	log.Println("Calling _OS.HideVirtualKeyboard()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "hide_virtual_keyboard", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) PrintResourcesInUse(short bool) {
	log.Println("Calling _OS.PrintResourcesInUse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(short)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "print_resources_in_use", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) PrintAllResources(tofile string) {
	log.Println("Calling _OS.PrintAllResources()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tofile)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "print_all_resources", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) GetStaticMemoryUsage() int64 {
	log.Println("Calling _OS.GetStaticMemoryUsage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_static_memory_usage", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetStaticMemoryPeakUsage() int64 {
	log.Println("Calling _OS.GetStaticMemoryPeakUsage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_static_memory_peak_usage", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetDynamicMemoryUsage() int64 {
	log.Println("Calling _OS.GetDynamicMemoryUsage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dynamic_memory_usage", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetDataDir() string {
	log.Println("Calling _OS.GetDataDir()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_data_dir", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetSystemDir(dir int64) string {
	log.Println("Calling _OS.GetSystemDir()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(dir)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_system_dir", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetUniqueId() string {
	log.Println("Calling _OS.GetUniqueId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_unique_id", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) IsOkLeftAndCancelRight() bool {
	log.Println("Calling _OS.IsOkLeftAndCancelRight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_ok_left_and_cancel_right", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) PrintAllTexturesBySize() {
	log.Println("Calling _OS.PrintAllTexturesBySize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "print_all_textures_by_size", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) PrintResourcesByType(types *PoolStringArray) {
	log.Println("Calling _OS.PrintResourcesByType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(types)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "print_resources_by_type", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) NativeVideoPlay(path string, volume float64, audioTrack string, subtitleTrack string) int64 {
	log.Println("Calling _OS.NativeVideoPlay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(path)
	goArguments[1] = reflect.ValueOf(volume)
	goArguments[2] = reflect.ValueOf(audioTrack)
	goArguments[3] = reflect.ValueOf(subtitleTrack)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "native_video_play", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) NativeVideoIsPlaying() bool {
	log.Println("Calling _OS.NativeVideoIsPlaying()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "native_video_is_playing", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) NativeVideoStop() {
	log.Println("Calling _OS.NativeVideoStop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "native_video_stop", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) NativeVideoPause() {
	log.Println("Calling _OS.NativeVideoPause()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "native_video_pause", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) NativeVideoUnpause() {
	log.Println("Calling _OS.NativeVideoUnpause()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "native_video_unpause", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) GetScancodeString(code int64) string {
	log.Println("Calling _OS.GetScancodeString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(code)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scancode_string", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) IsScancodeUnicode(code int64) bool {
	log.Println("Calling _OS.IsScancodeUnicode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(code)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_scancode_unicode", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) FindScancodeFromString(string string) int64 {
	log.Println("Calling _OS.FindScancodeFromString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(string)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "find_scancode_from_string", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) SetUseFileAccessSaveAndSwap(enabled bool) {
	log.Println("Calling _OS.SetUseFileAccessSaveAndSwap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_file_access_save_and_swap", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) Alert(text string, title string) {
	log.Println("Calling _OS.Alert()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(text)
	goArguments[1] = reflect.ValueOf(title)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "alert", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) SetThreadName(name string) int64 {
	log.Println("Calling _OS.SetThreadName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "set_thread_name", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) SetUseVsync(enable bool) {
	log.Println("Calling _OS.SetUseVsync()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_vsync", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *os) IsVsyncEnabled() bool {
	log.Println("Calling _OS.IsVsyncEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_vsync_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetPowerState() int64 {
	log.Println("Calling _OS.GetPowerState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_power_state", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetPowerSecondsLeft() int64 {
	log.Println("Calling _OS.GetPowerSecondsLeft()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_power_seconds_left", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *os) GetPowerPercentLeft() int64 {
	log.Println("Calling _OS.GetPowerPercentLeft()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_power_percent_left", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

func newSingletonEngine() *engine {
	obj := &engine{}
	ptr := C.godot_global_get_singleton(C.CString("_Engine"))
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*

 */
var Engine = newSingletonEngine()

/*

 */
type engine struct {
	Object
}

func (o *engine) baseClass() string {
	return "_Engine"
}

/*
   Undocumented
*/
func (o *engine) SetIterationsPerSecond(iterationsPerSecond int64) {
	log.Println("Calling _Engine.SetIterationsPerSecond()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(iterationsPerSecond)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_iterations_per_second", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *engine) GetIterationsPerSecond() int64 {
	log.Println("Calling _Engine.GetIterationsPerSecond()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_iterations_per_second", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *engine) SetTargetFps(targetFps int64) {
	log.Println("Calling _Engine.SetTargetFps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(targetFps)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_target_fps", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *engine) GetTargetFps() float64 {
	log.Println("Calling _Engine.GetTargetFps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_target_fps", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Undocumented
*/
func (o *engine) SetTimeScale(timeScale float64) {
	log.Println("Calling _Engine.SetTimeScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(timeScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_time_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *engine) GetTimeScale() float64 {
	log.Println("Calling _Engine.GetTimeScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_time_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Undocumented
*/
func (o *engine) GetFramesDrawn() int64 {
	log.Println("Calling _Engine.GetFramesDrawn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_frames_drawn", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *engine) GetFramesPerSecond() float64 {
	log.Println("Calling _Engine.GetFramesPerSecond()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_frames_per_second", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Undocumented
*/
func (o *engine) GetMainLoop() *MainLoop {
	log.Println("Calling _Engine.GetMainLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_main_loop", goArguments, "*MainLoop")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*MainLoop)

	return returnValue

}

/*
   Undocumented
*/
func (o *engine) GetVersionInfo() *Dictionary {
	log.Println("Calling _Engine.GetVersionInfo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_version_info", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
   Undocumented
*/
func (o *engine) IsInFixedFrame() bool {
	log.Println("Calling _Engine.IsInFixedFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_in_fixed_frame", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *engine) SetEditorHint(enabled bool) {
	log.Println("Calling _Engine.SetEditorHint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_editor_hint", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *engine) IsEditorHint() bool {
	log.Println("Calling _Engine.IsEditorHint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_editor_hint", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

func newSingletonClassDB() *classDb {
	obj := &classDb{}
	ptr := C.godot_global_get_singleton(C.CString("_ClassDB"))
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*
   Provides access to metadata stored for every available class.
*/
var ClassDB = newSingletonClassDB()

/*
   Provides access to metadata stored for every available class.
*/
type classDb struct {
	Object
}

func (o *classDb) baseClass() string {
	return "_ClassDB"
}

/*
   Undocumented
*/
func (o *classDb) GetClassList() *PoolStringArray {
	log.Println("Calling _ClassDB.GetClassList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_class_list", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Undocumented
*/
func (o *classDb) GetInheritersFromClass(class string) *PoolStringArray {
	log.Println("Calling _ClassDB.GetInheritersFromClass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(class)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_inheriters_from_class", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Undocumented
*/
func (o *classDb) GetParentClass(class string) string {
	log.Println("Calling _ClassDB.GetParentClass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(class)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_parent_class", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *classDb) ClassExists(class string) bool {
	log.Println("Calling _ClassDB.ClassExists()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(class)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "class_exists", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *classDb) IsParentClass(class string, inherits string) bool {
	log.Println("Calling _ClassDB.IsParentClass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(class)
	goArguments[1] = reflect.ValueOf(inherits)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_parent_class", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *classDb) CanInstance(class string) bool {
	log.Println("Calling _ClassDB.CanInstance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(class)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "can_instance", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *classDb) Instance(class string) *Variant {
	log.Println("Calling _ClassDB.Instance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(class)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "instance", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Undocumented
*/
func (o *classDb) ClassHasSignal(class string, signal string) bool {
	log.Println("Calling _ClassDB.ClassHasSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(class)
	goArguments[1] = reflect.ValueOf(signal)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "class_has_signal", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *classDb) ClassGetSignal(class string, signal string) *Dictionary {
	log.Println("Calling _ClassDB.ClassGetSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(class)
	goArguments[1] = reflect.ValueOf(signal)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "class_get_signal", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
   Undocumented
*/
func (o *classDb) ClassGetSignalList(class string, noInheritance bool) *Array {
	log.Println("Calling _ClassDB.ClassGetSignalList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(class)
	goArguments[1] = reflect.ValueOf(noInheritance)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "class_get_signal_list", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Undocumented
*/
func (o *classDb) ClassGetPropertyList(class string, noInheritance bool) *Array {
	log.Println("Calling _ClassDB.ClassGetPropertyList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(class)
	goArguments[1] = reflect.ValueOf(noInheritance)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "class_get_property_list", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Undocumented
*/
func (o *classDb) ClassGetProperty(object *Object, property string) *Variant {
	log.Println("Calling _ClassDB.ClassGetProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(property)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "class_get_property", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Undocumented
*/
func (o *classDb) ClassSetProperty(object *Object, property string, value *Variant) int64 {
	log.Println("Calling _ClassDB.ClassSetProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(property)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "class_set_property", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *classDb) ClassHasMethod(class string, method string, noInheritance bool) bool {
	log.Println("Calling _ClassDB.ClassHasMethod()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(class)
	goArguments[1] = reflect.ValueOf(method)
	goArguments[2] = reflect.ValueOf(noInheritance)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "class_has_method", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *classDb) ClassGetMethodList(class string, noInheritance bool) *Array {
	log.Println("Calling _ClassDB.ClassGetMethodList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(class)
	goArguments[1] = reflect.ValueOf(noInheritance)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "class_get_method_list", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Undocumented
*/
func (o *classDb) ClassGetIntegerConstantList(class string, noInheritance bool) *PoolStringArray {
	log.Println("Calling _ClassDB.ClassGetIntegerConstantList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(class)
	goArguments[1] = reflect.ValueOf(noInheritance)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "class_get_integer_constant_list", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Undocumented
*/
func (o *classDb) ClassHasIntegerConstant(class string, name string) bool {
	log.Println("Calling _ClassDB.ClassHasIntegerConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(class)
	goArguments[1] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "class_has_integer_constant", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *classDb) ClassGetIntegerConstant(class string, name string) int64 {
	log.Println("Calling _ClassDB.ClassGetIntegerConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(class)
	goArguments[1] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "class_get_integer_constant", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *classDb) ClassGetCategory(class string) string {
	log.Println("Calling _ClassDB.ClassGetCategory()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(class)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "class_get_category", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *classDb) IsClassEnabled(class string) bool {
	log.Println("Calling _ClassDB.IsClassEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(class)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_class_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

func newSingletonMarshalls() *marshalls {
	obj := &marshalls{}
	ptr := C.godot_global_get_singleton(C.CString("_Marshalls"))
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*
   Provides data transformation and encoding utility functions.
*/
var Marshalls = newSingletonMarshalls()

/*
   Provides data transformation and encoding utility functions.
*/
type marshalls struct {
	Reference
}

func (o *marshalls) baseClass() string {
	return "_Marshalls"
}

/*
   Undocumented
*/
func (o *marshalls) VariantToBase64(variant *Variant) string {
	log.Println("Calling _Marshalls.VariantToBase64()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(variant)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "variant_to_base64", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *marshalls) Base64ToVariant(base64Str string) *Variant {
	log.Println("Calling _Marshalls.Base64ToVariant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(base64Str)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "base64_to_variant", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Undocumented
*/
func (o *marshalls) RawToBase64(array *PoolByteArray) string {
	log.Println("Calling _Marshalls.RawToBase64()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(array)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "raw_to_base64", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *marshalls) Base64ToRaw(base64Str string) *PoolByteArray {
	log.Println("Calling _Marshalls.Base64ToRaw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(base64Str)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "base64_to_raw", goArguments, "*PoolByteArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolByteArray)

	return returnValue

}

/*
   Undocumented
*/
func (o *marshalls) Utf8ToBase64(utf8Str string) string {
	log.Println("Calling _Marshalls.Utf8ToBase64()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(utf8Str)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "utf8_to_base64", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *marshalls) Base64ToUtf8(base64Str string) string {
	log.Println("Calling _Marshalls.Base64ToUtf8()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(base64Str)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "base64_to_utf8", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

func newSingletonJSON() *json {
	obj := &json{}
	ptr := C.godot_global_get_singleton(C.CString("_JSON"))
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*

 */
var JSON = newSingletonJSON()

/*

 */
type json struct {
	Object
}

func (o *json) baseClass() string {
	return "_JSON"
}

/*
   Undocumented
*/
func (o *json) Print(value *Variant) string {
	log.Println("Calling _JSON.Print()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "print", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *json) Parse(json string) *JSONParseResult {
	log.Println("Calling _JSON.Parse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(json)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "parse", goArguments, "*JSONParseResult")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*JSONParseResult)

	return returnValue

}

func newSingletonProjectSettings() *projectSettings {
	obj := &projectSettings{}
	ptr := C.godot_global_get_singleton(C.CString("ProjectSettings"))
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*
   Contains global variables accessible from everywhere. Use the normal [Object] API, such as "ProjectSettings.get(variable)", "ProjectSettings.set(variable,value)" or "ProjectSettings.has(variable)" to access them. Variables stored in project.godot are also loaded into ProjectSettings, making this object very useful for reading custom game configuration options.
*/
var ProjectSettings = newSingletonProjectSettings()

/*
   Contains global variables accessible from everywhere. Use the normal [Object] API, such as "ProjectSettings.get(variable)", "ProjectSettings.set(variable,value)" or "ProjectSettings.has(variable)" to access them. Variables stored in project.godot are also loaded into ProjectSettings, making this object very useful for reading custom game configuration options.
*/
type projectSettings struct {
	Object
}

func (o *projectSettings) baseClass() string {
	return "ProjectSettings"
}

/*
   Return true if a configuration value is present.
*/
func (o *projectSettings) Has(name string) bool {
	log.Println("Calling ProjectSettings.Has()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the order of a configuration value (influences when saved to the config file).
*/
func (o *projectSettings) SetOrder(name string, position int64) {
	log.Println("Calling ProjectSettings.SetOrder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_order", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the order of a configuration value (influences when saved to the config file).
*/
func (o *projectSettings) GetOrder(name string) int64 {
	log.Println("Calling ProjectSettings.GetOrder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_order", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *projectSettings) SetInitialValue(name string, value *Variant) {
	log.Println("Calling ProjectSettings.SetInitialValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_initial_value", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a custom property info to a property. The dictionary must contain: name:[String](the name of the property) and type:[int](see TYPE_* in [@Global Scope]), and optionally hint:[int](see PROPERTY_HINT_* in [@Global Scope]), hint_string:[String]. Example: [codeblock] ProjectSettings.set("category/property_name", 0) var property_info = { "name": "category/property_name", "type": TYPE_INT, "hint": PROPERTY_HINT_ENUM, "hint_string": "one,two,three" } ProjectSettings.add_property_info(property_info) [/codeblock]
*/
func (o *projectSettings) AddPropertyInfo(hint *Dictionary) {
	log.Println("Calling ProjectSettings.AddPropertyInfo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(hint)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_property_info", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear the whole configuration (not recommended, may break things).
*/
func (o *projectSettings) Clear(name string) {
	log.Println("Calling ProjectSettings.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Convert a path to a localized path (res:// path).
*/
func (o *projectSettings) LocalizePath(path string) string {
	log.Println("Calling ProjectSettings.LocalizePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "localize_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Convert a localized path (res://) to a full native OS path.
*/
func (o *projectSettings) GlobalizePath(path string) string {
	log.Println("Calling ProjectSettings.GlobalizePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "globalize_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *projectSettings) Save() int64 {
	log.Println("Calling ProjectSettings.Save()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "save", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *projectSettings) HasSingleton(name string) bool {
	log.Println("Calling ProjectSettings.HasSingleton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_singleton", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *projectSettings) GetSingleton(name string) *Object {
	log.Println("Calling ProjectSettings.GetSingleton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_singleton", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*

 */
func (o *projectSettings) LoadResourcePack(pack string) bool {
	log.Println("Calling ProjectSettings.LoadResourcePack()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pack)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "load_resource_pack", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *projectSettings) PropertyCanRevert(name string) bool {
	log.Println("Calling ProjectSettings.PropertyCanRevert()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "property_can_revert", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *projectSettings) PropertyGetRevert(name string) *Variant {
	log.Println("Calling ProjectSettings.PropertyGetRevert()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "property_get_revert", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *projectSettings) SaveCustom(file string) int64 {
	log.Println("Calling ProjectSettings.SaveCustom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(file)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "save_custom", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

func newSingletonInputMap() *inputMap {
	obj := &inputMap{}
	ptr := C.godot_global_get_singleton(C.CString("InputMap"))
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*

 */
var InputMap = newSingletonInputMap()

/*

 */
type inputMap struct {
	Object
}

func (o *inputMap) baseClass() string {
	return "InputMap"
}

/*
   Whether this InputMap has a registered action with the given name.
*/
func (o *inputMap) HasAction(action string) bool {
	log.Println("Calling InputMap.HasAction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_action", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return an array of all actions in the [InputMap].
*/
func (o *inputMap) GetActions() *Array {
	log.Println("Calling InputMap.GetActions()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_actions", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Add an (empty) action to the [InputMap]. An [InputEvent] can then be added to this action with [method action_add_event].
*/
func (o *inputMap) AddAction(action string) {
	log.Println("Calling InputMap.AddAction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_action", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove an action from the [InputMap].
*/
func (o *inputMap) EraseAction(action string) {
	log.Println("Calling InputMap.EraseAction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "erase_action", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add an [InputEvent] to an action. This [InputEvent] will trigger the action.
*/
func (o *inputMap) ActionAddEvent(action string, event *InputEvent) {
	log.Println("Calling InputMap.ActionAddEvent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(action)
	goArguments[1] = reflect.ValueOf(event)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "action_add_event", goArguments, "")

	log.Println("Got return value!")

}

/*
   Whether an action has an [InputEvent] associated with it.
*/
func (o *inputMap) ActionHasEvent(action string, event *InputEvent) bool {
	log.Println("Calling InputMap.ActionHasEvent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(action)
	goArguments[1] = reflect.ValueOf(event)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "action_has_event", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Remove an [InputEvent] from an action.
*/
func (o *inputMap) ActionEraseEvent(action string, event *InputEvent) {
	log.Println("Calling InputMap.ActionEraseEvent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(action)
	goArguments[1] = reflect.ValueOf(event)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "action_erase_event", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return an array of InputEvents associated with a given action.
*/
func (o *inputMap) GetActionList(action string) *Array {
	log.Println("Calling InputMap.GetActionList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_action_list", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Return whether the given event is part of an existing action. This method ignores keyboard modifiers if the given [InputEvent] is not pressed (for proper release detection). See [method action_has_event] if you don't want this behavior.
*/
func (o *inputMap) EventIsAction(event *InputEvent, action string) bool {
	log.Println("Calling InputMap.EventIsAction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(event)
	goArguments[1] = reflect.ValueOf(action)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "event_is_action", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Clear the [InputMap] and load it anew from [ProjectSettings].
*/
func (o *inputMap) LoadFromGlobals() {
	log.Println("Calling InputMap.LoadFromGlobals()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "load_from_globals", goArguments, "")

	log.Println("Got return value!")

}

func newSingletonTranslationServer() *translationServer {
	obj := &translationServer{}
	ptr := C.godot_global_get_singleton(C.CString("TranslationServer"))
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*

 */
var TranslationServer = newSingletonTranslationServer()

/*

 */
type translationServer struct {
	Object
}

func (o *translationServer) baseClass() string {
	return "TranslationServer"
}

/*

 */
func (o *translationServer) SetLocale(locale string) {
	log.Println("Calling TranslationServer.SetLocale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(locale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_locale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *translationServer) GetLocale() string {
	log.Println("Calling TranslationServer.GetLocale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_locale", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *translationServer) Translate(message string) string {
	log.Println("Calling TranslationServer.Translate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(message)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "translate", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *translationServer) AddTranslation(translation *Translation) {
	log.Println("Calling TranslationServer.AddTranslation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(translation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_translation", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *translationServer) RemoveTranslation(translation *Translation) {
	log.Println("Calling TranslationServer.RemoveTranslation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(translation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_translation", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *translationServer) Clear() {
	log.Println("Calling TranslationServer.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

func newSingletonPerformance() *performance {
	obj := &performance{}
	ptr := C.godot_global_get_singleton(C.CString("Performance"))
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*

 */
var Performance = newSingletonPerformance()

/*

 */
type performance struct {
	Object
}

func (o *performance) baseClass() string {
	return "Performance"
}

/*

 */
func (o *performance) GetMonitor(monitor int64) float64 {
	log.Println("Calling Performance.GetMonitor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(monitor)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_monitor", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

func newSingletonVisualServer() *visualServer {
	obj := &visualServer{}
	ptr := C.godot_global_get_singleton(C.CString("VisualServer"))
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*
   Server for anything visible. The visual server is the API backend for everything visible. The whole scene system mounts on it to display. The visual server is completely opaque, the internals are entirely implementation specific and cannot be accessed.
*/
var VisualServer = newSingletonVisualServer()

/*
   Server for anything visible. The visual server is the API backend for everything visible. The whole scene system mounts on it to display. The visual server is completely opaque, the internals are entirely implementation specific and cannot be accessed.
*/
type visualServer struct {
	Object
}

func (o *visualServer) baseClass() string {
	return "VisualServer"
}

/*

 */
func (o *visualServer) ForceDraw() {
	log.Println("Calling VisualServer.ForceDraw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "force_draw", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *visualServer) TextureCreate() *RID {
	log.Println("Calling VisualServer.TextureCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "texture_create", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *visualServer) TextureCreateFromImage(image *Image, flags int64) *RID {
	log.Println("Calling VisualServer.TextureCreateFromImage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(image)
	goArguments[1] = reflect.ValueOf(flags)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "texture_create_from_image", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *visualServer) TextureSetFlags(texture *RID, flags int64) {
	log.Println("Calling VisualServer.TextureSetFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(texture)
	goArguments[1] = reflect.ValueOf(flags)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "texture_set_flags", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *visualServer) TextureGetFlags(texture *RID) int64 {
	log.Println("Calling VisualServer.TextureGetFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "texture_get_flags", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *visualServer) TextureGetWidth(texture *RID) int64 {
	log.Println("Calling VisualServer.TextureGetWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "texture_get_width", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *visualServer) TextureGetHeight(texture *RID) int64 {
	log.Println("Calling VisualServer.TextureGetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "texture_get_height", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *visualServer) TextureSetShrinkAllX2OnSetData(shrink bool) {
	log.Println("Calling VisualServer.TextureSetShrinkAllX2OnSetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shrink)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "texture_set_shrink_all_x2_on_set_data", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
type PhysicsServerSW struct {
	physicsServer
}

func (o *PhysicsServerSW) baseClass() string {
	return "PhysicsServerSW"
}

/*
   PhysicsServerSWImplementer is an interface for PhysicsServerSW objects.
*/
type PhysicsServerSWImplementer interface {
	Class
}

func newSingletonPhysicsServer() *physicsServer {
	obj := &physicsServer{}
	ptr := C.godot_global_get_singleton(C.CString("PhysicsServer"))
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*

 */
var PhysicsServer = newSingletonPhysicsServer()

/*

 */
type physicsServer struct {
	Object
}

func (o *physicsServer) baseClass() string {
	return "PhysicsServer"
}

/*

 */
func (o *physicsServer) ShapeCreate(aType int64) *RID {
	log.Println("Calling PhysicsServer.ShapeCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_create", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *physicsServer) ShapeSetData(shape *RID, data *Variant) {
	log.Println("Calling PhysicsServer.ShapeSetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(shape)
	goArguments[1] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shape_set_data", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) ShapeGetType(shape *RID) int64 {
	log.Println("Calling PhysicsServer.ShapeGetType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_get_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *physicsServer) ShapeGetData(shape *RID) *Variant {
	log.Println("Calling PhysicsServer.ShapeGetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_get_data", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *physicsServer) SpaceCreate() *RID {
	log.Println("Calling PhysicsServer.SpaceCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "space_create", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *physicsServer) SpaceSetActive(space *RID, active bool) {
	log.Println("Calling PhysicsServer.SpaceSetActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(space)
	goArguments[1] = reflect.ValueOf(active)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "space_set_active", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) SpaceIsActive(space *RID) bool {
	log.Println("Calling PhysicsServer.SpaceIsActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(space)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "space_is_active", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *physicsServer) SpaceSetParam(space *RID, param int64, value float64) {
	log.Println("Calling PhysicsServer.SpaceSetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(space)
	goArguments[1] = reflect.ValueOf(param)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "space_set_param", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) SpaceGetParam(space *RID, param int64) float64 {
	log.Println("Calling PhysicsServer.SpaceGetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(space)
	goArguments[1] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "space_get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *physicsServer) SpaceGetDirectState(space *RID) *PhysicsDirectSpaceState {
	log.Println("Calling PhysicsServer.SpaceGetDirectState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(space)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "space_get_direct_state", goArguments, "*PhysicsDirectSpaceState")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PhysicsDirectSpaceState)

	return returnValue

}

/*

 */
func (o *physicsServer) AreaCreate() *RID {
	log.Println("Calling PhysicsServer.AreaCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_create", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *physicsServer) AreaSetSpace(area *RID, space *RID) {
	log.Println("Calling PhysicsServer.AreaSetSpace()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(space)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_space", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) AreaGetSpace(area *RID) *RID {
	log.Println("Calling PhysicsServer.AreaGetSpace()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_space", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *physicsServer) AreaSetSpaceOverrideMode(area *RID, mode int64) {
	log.Println("Calling PhysicsServer.AreaSetSpaceOverrideMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_space_override_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) AreaGetSpaceOverrideMode(area *RID) int64 {
	log.Println("Calling PhysicsServer.AreaGetSpaceOverrideMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_space_override_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *physicsServer) AreaAddShape(area *RID, shape *RID, transform *Transform) {
	log.Println("Calling PhysicsServer.AreaAddShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(shape)
	goArguments[2] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_add_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) AreaSetShape(area *RID, shapeIdx int64, shape *RID) {
	log.Println("Calling PhysicsServer.AreaSetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(shapeIdx)
	goArguments[2] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) AreaSetShapeTransform(area *RID, shapeIdx int64, transform *Transform) {
	log.Println("Calling PhysicsServer.AreaSetShapeTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(shapeIdx)
	goArguments[2] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_shape_transform", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) AreaGetShapeCount(area *RID) int64 {
	log.Println("Calling PhysicsServer.AreaGetShapeCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_shape_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *physicsServer) AreaGetShape(area *RID, shapeIdx int64) *RID {
	log.Println("Calling PhysicsServer.AreaGetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_shape", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *physicsServer) AreaGetShapeTransform(area *RID, shapeIdx int64) *Transform {
	log.Println("Calling PhysicsServer.AreaGetShapeTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_shape_transform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*

 */
func (o *physicsServer) AreaRemoveShape(area *RID, shapeIdx int64) {
	log.Println("Calling PhysicsServer.AreaRemoveShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_remove_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) AreaClearShapes(area *RID) {
	log.Println("Calling PhysicsServer.AreaClearShapes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_clear_shapes", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) AreaSetCollisionLayer(area *RID, layer int64) {
	log.Println("Calling PhysicsServer.AreaSetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_collision_layer", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) AreaSetCollisionMask(area *RID, mask int64) {
	log.Println("Calling PhysicsServer.AreaSetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_collision_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) AreaSetParam(area *RID, param int64, value *Variant) {
	log.Println("Calling PhysicsServer.AreaSetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(param)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_param", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) AreaSetTransform(area *RID, transform *Transform) {
	log.Println("Calling PhysicsServer.AreaSetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) AreaGetParam(area *RID, param int64) *Variant {
	log.Println("Calling PhysicsServer.AreaGetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_param", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *physicsServer) AreaGetTransform(area *RID) *Transform {
	log.Println("Calling PhysicsServer.AreaGetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_transform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*

 */
func (o *physicsServer) AreaAttachObjectInstanceId(area *RID, id int64) {
	log.Println("Calling PhysicsServer.AreaAttachObjectInstanceId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_attach_object_instance_id", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) AreaGetObjectInstanceId(area *RID) int64 {
	log.Println("Calling PhysicsServer.AreaGetObjectInstanceId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_object_instance_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *physicsServer) AreaSetMonitorCallback(area *RID, receiver *Object, method string) {
	log.Println("Calling PhysicsServer.AreaSetMonitorCallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(receiver)
	goArguments[2] = reflect.ValueOf(method)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_monitor_callback", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) AreaSetRayPickable(area *RID, enable bool) {
	log.Println("Calling PhysicsServer.AreaSetRayPickable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_ray_pickable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) AreaIsRayPickable(area *RID) bool {
	log.Println("Calling PhysicsServer.AreaIsRayPickable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_is_ray_pickable", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *physicsServer) BodyCreate(mode int64, initSleeping bool) *RID {
	log.Println("Calling PhysicsServer.BodyCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(mode)
	goArguments[1] = reflect.ValueOf(initSleeping)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_create", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *physicsServer) BodySetSpace(body *RID, space *RID) {
	log.Println("Calling PhysicsServer.BodySetSpace()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(space)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_space", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) BodyGetSpace(body *RID) *RID {
	log.Println("Calling PhysicsServer.BodyGetSpace()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_space", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *physicsServer) BodySetMode(body *RID, mode int64) {
	log.Println("Calling PhysicsServer.BodySetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) BodyGetMode(body *RID) int64 {
	log.Println("Calling PhysicsServer.BodyGetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *physicsServer) BodySetCollisionLayer(body *RID, layer int64) {
	log.Println("Calling PhysicsServer.BodySetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_collision_layer", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) BodyGetCollisionLayer(body *RID) int64 {
	log.Println("Calling PhysicsServer.BodyGetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_collision_layer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *physicsServer) BodySetCollisionMask(body *RID, mask int64) {
	log.Println("Calling PhysicsServer.BodySetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_collision_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) BodyGetCollisionMask(body *RID) int64 {
	log.Println("Calling PhysicsServer.BodyGetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_collision_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *physicsServer) BodyAddShape(body *RID, shape *RID, transform *Transform) {
	log.Println("Calling PhysicsServer.BodyAddShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shape)
	goArguments[2] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_add_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) BodySetShape(body *RID, shapeIdx int64, shape *RID) {
	log.Println("Calling PhysicsServer.BodySetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)
	goArguments[2] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) BodySetShapeTransform(body *RID, shapeIdx int64, transform *Transform) {
	log.Println("Calling PhysicsServer.BodySetShapeTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)
	goArguments[2] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_shape_transform", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) BodyGetShapeCount(body *RID) int64 {
	log.Println("Calling PhysicsServer.BodyGetShapeCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_shape_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *physicsServer) BodyGetShape(body *RID, shapeIdx int64) *RID {
	log.Println("Calling PhysicsServer.BodyGetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_shape", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *physicsServer) BodyGetShapeTransform(body *RID, shapeIdx int64) *Transform {
	log.Println("Calling PhysicsServer.BodyGetShapeTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_shape_transform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*

 */
func (o *physicsServer) BodyRemoveShape(body *RID, shapeIdx int64) {
	log.Println("Calling PhysicsServer.BodyRemoveShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_remove_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) BodyClearShapes(body *RID) {
	log.Println("Calling PhysicsServer.BodyClearShapes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_clear_shapes", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) BodyAttachObjectInstanceId(body *RID, id int64) {
	log.Println("Calling PhysicsServer.BodyAttachObjectInstanceId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_attach_object_instance_id", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) BodyGetObjectInstanceId(body *RID) int64 {
	log.Println("Calling PhysicsServer.BodyGetObjectInstanceId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_object_instance_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *physicsServer) BodySetEnableContinuousCollisionDetection(body *RID, enable bool) {
	log.Println("Calling PhysicsServer.BodySetEnableContinuousCollisionDetection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_enable_continuous_collision_detection", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) BodyIsContinuousCollisionDetectionEnabled(body *RID) bool {
	log.Println("Calling PhysicsServer.BodyIsContinuousCollisionDetectionEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_is_continuous_collision_detection_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *physicsServer) BodySetParam(body *RID, param int64, value float64) {
	log.Println("Calling PhysicsServer.BodySetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(param)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_param", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) BodyGetParam(body *RID, param int64) float64 {
	log.Println("Calling PhysicsServer.BodyGetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *physicsServer) BodySetState(body *RID, state int64, value *Variant) {
	log.Println("Calling PhysicsServer.BodySetState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(state)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_state", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) BodyGetState(body *RID, state int64) *Variant {
	log.Println("Calling PhysicsServer.BodyGetState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(state)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_state", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *physicsServer) BodyApplyImpulse(body *RID, position *Vector3, impulse *Vector3) {
	log.Println("Calling PhysicsServer.BodyApplyImpulse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(position)
	goArguments[2] = reflect.ValueOf(impulse)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_apply_impulse", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) BodyApplyTorqueImpulse(body *RID, impulse *Vector3) {
	log.Println("Calling PhysicsServer.BodyApplyTorqueImpulse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(impulse)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_apply_torque_impulse", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) BodySetAxisVelocity(body *RID, axisVelocity *Vector3) {
	log.Println("Calling PhysicsServer.BodySetAxisVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(axisVelocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_axis_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) BodySetAxisLock(body *RID, axis int64) {
	log.Println("Calling PhysicsServer.BodySetAxisLock()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(axis)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_axis_lock", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) BodyGetAxisLock(body *RID) int64 {
	log.Println("Calling PhysicsServer.BodyGetAxisLock()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_axis_lock", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *physicsServer) BodyAddCollisionException(body *RID, exceptedBody *RID) {
	log.Println("Calling PhysicsServer.BodyAddCollisionException()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(exceptedBody)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_add_collision_exception", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) BodyRemoveCollisionException(body *RID, exceptedBody *RID) {
	log.Println("Calling PhysicsServer.BodyRemoveCollisionException()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(exceptedBody)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_remove_collision_exception", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) BodySetMaxContactsReported(body *RID, amount int64) {
	log.Println("Calling PhysicsServer.BodySetMaxContactsReported()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_max_contacts_reported", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) BodyGetMaxContactsReported(body *RID) int64 {
	log.Println("Calling PhysicsServer.BodyGetMaxContactsReported()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_max_contacts_reported", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *physicsServer) BodySetOmitForceIntegration(body *RID, enable bool) {
	log.Println("Calling PhysicsServer.BodySetOmitForceIntegration()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_omit_force_integration", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) BodyIsOmittingForceIntegration(body *RID) bool {
	log.Println("Calling PhysicsServer.BodyIsOmittingForceIntegration()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_is_omitting_force_integration", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *physicsServer) BodySetForceIntegrationCallback(body *RID, receiver *Object, method string, userdata *Variant) {
	log.Println("Calling PhysicsServer.BodySetForceIntegrationCallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(receiver)
	goArguments[2] = reflect.ValueOf(method)
	goArguments[3] = reflect.ValueOf(userdata)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_force_integration_callback", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) BodySetRayPickable(body *RID, enable bool) {
	log.Println("Calling PhysicsServer.BodySetRayPickable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_ray_pickable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) BodyIsRayPickable(body *RID) bool {
	log.Println("Calling PhysicsServer.BodyIsRayPickable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_is_ray_pickable", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *physicsServer) JointCreatePin(bodyA *RID, localA *Vector3, bodyB *RID, localB *Vector3) *RID {
	log.Println("Calling PhysicsServer.JointCreatePin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(bodyA)
	goArguments[1] = reflect.ValueOf(localA)
	goArguments[2] = reflect.ValueOf(bodyB)
	goArguments[3] = reflect.ValueOf(localB)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "joint_create_pin", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *physicsServer) PinJointSetParam(joint *RID, param int64, value float64) {
	log.Println("Calling PhysicsServer.PinJointSetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(param)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "pin_joint_set_param", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) PinJointGetParam(joint *RID, param int64) float64 {
	log.Println("Calling PhysicsServer.PinJointGetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "pin_joint_get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *physicsServer) PinJointSetLocalA(joint *RID, localA *Vector3) {
	log.Println("Calling PhysicsServer.PinJointSetLocalA()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(localA)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "pin_joint_set_local_a", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) PinJointGetLocalA(joint *RID) *Vector3 {
	log.Println("Calling PhysicsServer.PinJointGetLocalA()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(joint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "pin_joint_get_local_a", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *physicsServer) PinJointSetLocalB(joint *RID, localB *Vector3) {
	log.Println("Calling PhysicsServer.PinJointSetLocalB()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(localB)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "pin_joint_set_local_b", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) PinJointGetLocalB(joint *RID) *Vector3 {
	log.Println("Calling PhysicsServer.PinJointGetLocalB()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(joint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "pin_joint_get_local_b", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *physicsServer) JointCreateHinge(bodyA *RID, hingeA *Transform, bodyB *RID, hingeB *Transform) *RID {
	log.Println("Calling PhysicsServer.JointCreateHinge()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(bodyA)
	goArguments[1] = reflect.ValueOf(hingeA)
	goArguments[2] = reflect.ValueOf(bodyB)
	goArguments[3] = reflect.ValueOf(hingeB)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "joint_create_hinge", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *physicsServer) HingeJointSetParam(joint *RID, param int64, value float64) {
	log.Println("Calling PhysicsServer.HingeJointSetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(param)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "hinge_joint_set_param", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) HingeJointGetParam(joint *RID, param int64) float64 {
	log.Println("Calling PhysicsServer.HingeJointGetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "hinge_joint_get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *physicsServer) HingeJointSetFlag(joint *RID, flag int64, enabled bool) {
	log.Println("Calling PhysicsServer.HingeJointSetFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(flag)
	goArguments[2] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "hinge_joint_set_flag", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) HingeJointGetFlag(joint *RID, flag int64) bool {
	log.Println("Calling PhysicsServer.HingeJointGetFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(flag)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "hinge_joint_get_flag", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *physicsServer) JointCreateSlider(bodyA *RID, localRefA *Transform, bodyB *RID, localRefB *Transform) *RID {
	log.Println("Calling PhysicsServer.JointCreateSlider()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(bodyA)
	goArguments[1] = reflect.ValueOf(localRefA)
	goArguments[2] = reflect.ValueOf(bodyB)
	goArguments[3] = reflect.ValueOf(localRefB)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "joint_create_slider", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *physicsServer) SliderJointSetParam(joint *RID, param int64, value float64) {
	log.Println("Calling PhysicsServer.SliderJointSetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(param)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "slider_joint_set_param", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) SliderJointGetParam(joint *RID, param int64) float64 {
	log.Println("Calling PhysicsServer.SliderJointGetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "slider_joint_get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *physicsServer) JointCreateConeTwist(bodyA *RID, localRefA *Transform, bodyB *RID, localRefB *Transform) *RID {
	log.Println("Calling PhysicsServer.JointCreateConeTwist()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(bodyA)
	goArguments[1] = reflect.ValueOf(localRefA)
	goArguments[2] = reflect.ValueOf(bodyB)
	goArguments[3] = reflect.ValueOf(localRefB)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "joint_create_cone_twist", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *physicsServer) ConeTwistJointSetParam(joint *RID, param int64, value float64) {
	log.Println("Calling PhysicsServer.ConeTwistJointSetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(param)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "cone_twist_joint_set_param", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) ConeTwistJointGetParam(joint *RID, param int64) float64 {
	log.Println("Calling PhysicsServer.ConeTwistJointGetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "cone_twist_joint_get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *physicsServer) JointGetType(joint *RID) int64 {
	log.Println("Calling PhysicsServer.JointGetType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(joint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "joint_get_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *physicsServer) JointSetSolverPriority(joint *RID, priority int64) {
	log.Println("Calling PhysicsServer.JointSetSolverPriority()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(priority)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "joint_set_solver_priority", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) JointGetSolverPriority(joint *RID) int64 {
	log.Println("Calling PhysicsServer.JointGetSolverPriority()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(joint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "joint_get_solver_priority", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *physicsServer) JointCreateGeneric6Dof(bodyA *RID, localRefA *Transform, bodyB *RID, localRefB *Transform) *RID {
	log.Println("Calling PhysicsServer.JointCreateGeneric6Dof()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(bodyA)
	goArguments[1] = reflect.ValueOf(localRefA)
	goArguments[2] = reflect.ValueOf(bodyB)
	goArguments[3] = reflect.ValueOf(localRefB)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "joint_create_generic_6dof", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *physicsServer) Generic6DofJointSetParam(joint *RID, axis int64, param int64, value float64) {
	log.Println("Calling PhysicsServer.Generic6DofJointSetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(axis)
	goArguments[2] = reflect.ValueOf(param)
	goArguments[3] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "generic_6dof_joint_set_param", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) Generic6DofJointGetParam(joint *RID, axis int64, param int64) float64 {
	log.Println("Calling PhysicsServer.Generic6DofJointGetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(axis)
	goArguments[2] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "generic_6dof_joint_get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *physicsServer) Generic6DofJointSetFlag(joint *RID, axis int64, flag int64, enable bool) {
	log.Println("Calling PhysicsServer.Generic6DofJointSetFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(axis)
	goArguments[2] = reflect.ValueOf(flag)
	goArguments[3] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "generic_6dof_joint_set_flag", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) Generic6DofJointGetFlag(joint *RID, axis int64, flag int64) bool {
	log.Println("Calling PhysicsServer.Generic6DofJointGetFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(axis)
	goArguments[2] = reflect.ValueOf(flag)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "generic_6dof_joint_get_flag", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *physicsServer) FreeRid(rid *RID) {
	log.Println("Calling PhysicsServer.FreeRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rid)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "free_rid", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) SetActive(active bool) {
	log.Println("Calling PhysicsServer.SetActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(active)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_active", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physicsServer) GetProcessInfo(processInfo int64) int64 {
	log.Println("Calling PhysicsServer.GetProcessInfo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(processInfo)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_process_info", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
type PhysicsDirectBodyStateSW struct {
	PhysicsDirectBodyState
}

func (o *PhysicsDirectBodyStateSW) baseClass() string {
	return "PhysicsDirectBodyStateSW"
}

/*
   PhysicsDirectBodyStateSWImplementer is an interface for PhysicsDirectBodyStateSW objects.
*/
type PhysicsDirectBodyStateSWImplementer interface {
	Class
}

/*

 */
type PhysicsDirectBodyState struct {
	Object
}

func (o *PhysicsDirectBodyState) baseClass() string {
	return "PhysicsDirectBodyState"
}

/*

 */
func (o *PhysicsDirectBodyState) GetTotalGravity() *Vector3 {
	log.Println("Calling PhysicsDirectBodyState.GetTotalGravity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_total_gravity", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetTotalLinearDamp() float64 {
	log.Println("Calling PhysicsDirectBodyState.GetTotalLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_total_linear_damp", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetTotalAngularDamp() float64 {
	log.Println("Calling PhysicsDirectBodyState.GetTotalAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_total_angular_damp", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetCenterOfMass() *Vector3 {
	log.Println("Calling PhysicsDirectBodyState.GetCenterOfMass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_center_of_mass", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetPrincipalInertiaAxes() *Basis {
	log.Println("Calling PhysicsDirectBodyState.GetPrincipalInertiaAxes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_principal_inertia_axes", goArguments, "*Basis")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Basis)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetInverseMass() float64 {
	log.Println("Calling PhysicsDirectBodyState.GetInverseMass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_inverse_mass", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetInverseInertia() *Vector3 {
	log.Println("Calling PhysicsDirectBodyState.GetInverseInertia()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_inverse_inertia", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) SetLinearVelocity(velocity *Vector3) {
	log.Println("Calling PhysicsDirectBodyState.SetLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(velocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_linear_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsDirectBodyState) GetLinearVelocity() *Vector3 {
	log.Println("Calling PhysicsDirectBodyState.GetLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_linear_velocity", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) SetAngularVelocity(velocity *Vector3) {
	log.Println("Calling PhysicsDirectBodyState.SetAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(velocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_angular_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsDirectBodyState) GetAngularVelocity() *Vector3 {
	log.Println("Calling PhysicsDirectBodyState.GetAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_angular_velocity", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) SetTransform(transform *Transform) {
	log.Println("Calling PhysicsDirectBodyState.SetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsDirectBodyState) GetTransform() *Transform {
	log.Println("Calling PhysicsDirectBodyState.GetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_transform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) AddForce(force *Vector3, position *Vector3) {
	log.Println("Calling PhysicsDirectBodyState.AddForce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(force)
	goArguments[1] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_force", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsDirectBodyState) ApplyImpulse(position *Vector3, j *Vector3) {
	log.Println("Calling PhysicsDirectBodyState.ApplyImpulse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(position)
	goArguments[1] = reflect.ValueOf(j)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "apply_impulse", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsDirectBodyState) ApplyTorqeImpulse(j *Vector3) {
	log.Println("Calling PhysicsDirectBodyState.ApplyTorqeImpulse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(j)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "apply_torqe_impulse", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsDirectBodyState) SetSleepState(enabled bool) {
	log.Println("Calling PhysicsDirectBodyState.SetSleepState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sleep_state", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsDirectBodyState) IsSleeping() bool {
	log.Println("Calling PhysicsDirectBodyState.IsSleeping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_sleeping", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactCount() int64 {
	log.Println("Calling PhysicsDirectBodyState.GetContactCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactLocalPosition(contactIdx int64) *Vector3 {
	log.Println("Calling PhysicsDirectBodyState.GetContactLocalPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_local_position", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactLocalNormal(contactIdx int64) *Vector3 {
	log.Println("Calling PhysicsDirectBodyState.GetContactLocalNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_local_normal", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactLocalShape(contactIdx int64) int64 {
	log.Println("Calling PhysicsDirectBodyState.GetContactLocalShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_local_shape", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactCollider(contactIdx int64) *RID {
	log.Println("Calling PhysicsDirectBodyState.GetContactCollider()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_collider", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactColliderPosition(contactIdx int64) *Vector3 {
	log.Println("Calling PhysicsDirectBodyState.GetContactColliderPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_collider_position", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactColliderId(contactIdx int64) int64 {
	log.Println("Calling PhysicsDirectBodyState.GetContactColliderId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_collider_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactColliderObject(contactIdx int64) *Object {
	log.Println("Calling PhysicsDirectBodyState.GetContactColliderObject()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_collider_object", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactColliderShape(contactIdx int64) int64 {
	log.Println("Calling PhysicsDirectBodyState.GetContactColliderShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_collider_shape", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactColliderVelocityAtPosition(contactIdx int64) *Vector3 {
	log.Println("Calling PhysicsDirectBodyState.GetContactColliderVelocityAtPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_collider_velocity_at_position", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetStep() float64 {
	log.Println("Calling PhysicsDirectBodyState.GetStep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_step", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) IntegrateForces() {
	log.Println("Calling PhysicsDirectBodyState.IntegrateForces()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "integrate_forces", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsDirectBodyState) GetSpaceState() *PhysicsDirectSpaceState {
	log.Println("Calling PhysicsDirectBodyState.GetSpaceState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_space_state", goArguments, "*PhysicsDirectSpaceState")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PhysicsDirectSpaceState)

	return returnValue

}

/*
   PhysicsDirectBodyStateImplementer is an interface for PhysicsDirectBodyState objects.
*/
type PhysicsDirectBodyStateImplementer interface {
	Class
}

/*
   Software implementation of [Physics2DServer]. This class exposes no new methods or properties and should not be used, as [Physics2DServer] automatically selects the best implementation available.
*/
type Physics2DServerSW struct {
	physics2DServer
}

func (o *Physics2DServerSW) baseClass() string {
	return "Physics2DServerSW"
}

/*
   Physics2DServerSWImplementer is an interface for Physics2DServerSW objects.
*/
type Physics2DServerSWImplementer interface {
	Class
}

func newSingletonPhysics2DServer() *physics2DServer {
	obj := &physics2DServer{}
	ptr := C.godot_global_get_singleton(C.CString("Physics2DServer"))
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*
   Physics 2D Server is the server responsible for all 2D physics. It can create many kinds of physics objects, but does not insert them on the node tree.
*/
var Physics2DServer = newSingletonPhysics2DServer()

/*
   Physics 2D Server is the server responsible for all 2D physics. It can create many kinds of physics objects, but does not insert them on the node tree.
*/
type physics2DServer struct {
	Object
}

func (o *physics2DServer) baseClass() string {
	return "Physics2DServer"
}

/*
   Create a shape of type SHAPE_*. Does not assign it to a body or an area. To do so, you must use [method area_set_shape] or [method body_set_shape].
*/
func (o *physics2DServer) ShapeCreate(aType int64) *RID {
	log.Println("Calling Physics2DServer.ShapeCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_create", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Set the shape data that defines its shape and size. The data to be passed depends on the kind of shape created [method shape_get_type].
*/
func (o *physics2DServer) ShapeSetData(shape *RID, data *Variant) {
	log.Println("Calling Physics2DServer.ShapeSetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(shape)
	goArguments[1] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shape_set_data", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the type of shape (see SHAPE_* constants).
*/
func (o *physics2DServer) ShapeGetType(shape *RID) int64 {
	log.Println("Calling Physics2DServer.ShapeGetType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_get_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the shape data.
*/
func (o *physics2DServer) ShapeGetData(shape *RID) *Variant {
	log.Println("Calling Physics2DServer.ShapeGetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_get_data", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Create a space. A space is a collection of parameters for the physics engine that can be assigned to an area or a body. It can be assigned to an area with [method area_set_space], or to a body with [method body_set_space].
*/
func (o *physics2DServer) SpaceCreate() *RID {
	log.Println("Calling Physics2DServer.SpaceCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "space_create", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Mark a space as active. It will not have an effect, unless it is assigned to an area or body.
*/
func (o *physics2DServer) SpaceSetActive(space *RID, active bool) {
	log.Println("Calling Physics2DServer.SpaceSetActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(space)
	goArguments[1] = reflect.ValueOf(active)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "space_set_active", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether the space is active.
*/
func (o *physics2DServer) SpaceIsActive(space *RID) bool {
	log.Println("Calling Physics2DServer.SpaceIsActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(space)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "space_is_active", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the value for a space parameter. A list of available parameters is on the SPACE_PARAM_* constants.
*/
func (o *physics2DServer) SpaceSetParam(space *RID, param int64, value float64) {
	log.Println("Calling Physics2DServer.SpaceSetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(space)
	goArguments[1] = reflect.ValueOf(param)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "space_set_param", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the value of a space parameter.
*/
func (o *physics2DServer) SpaceGetParam(space *RID, param int64) float64 {
	log.Println("Calling Physics2DServer.SpaceGetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(space)
	goArguments[1] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "space_get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the state of a space, a [Physics2DDirectSpaceState]. This object can be used to make collision/intersection queries.
*/
func (o *physics2DServer) SpaceGetDirectState(space *RID) *Physics2DDirectSpaceState {
	log.Println("Calling Physics2DServer.SpaceGetDirectState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(space)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "space_get_direct_state", goArguments, "*Physics2DDirectSpaceState")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Physics2DDirectSpaceState)

	return returnValue

}

/*
   Create an [Area2D].
*/
func (o *physics2DServer) AreaCreate() *RID {
	log.Println("Calling Physics2DServer.AreaCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_create", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Assign a space to the area.
*/
func (o *physics2DServer) AreaSetSpace(area *RID, space *RID) {
	log.Println("Calling Physics2DServer.AreaSetSpace()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(space)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_space", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the space assigned to the area.
*/
func (o *physics2DServer) AreaGetSpace(area *RID) *RID {
	log.Println("Calling Physics2DServer.AreaGetSpace()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_space", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Set the space override mode for the area. The modes are described in the constants AREA_SPACE_OVERRIDE_*.
*/
func (o *physics2DServer) AreaSetSpaceOverrideMode(area *RID, mode int64) {
	log.Println("Calling Physics2DServer.AreaSetSpaceOverrideMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_space_override_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the space override mode for the area.
*/
func (o *physics2DServer) AreaGetSpaceOverrideMode(area *RID) int64 {
	log.Println("Calling Physics2DServer.AreaGetSpaceOverrideMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_space_override_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Add a shape to the area, along with a transform matrix. Shapes are usually referenced by their index, so you should track which shape has a given index.
*/
func (o *physics2DServer) AreaAddShape(area *RID, shape *RID, transform *Transform2D) {
	log.Println("Calling Physics2DServer.AreaAddShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(shape)
	goArguments[2] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_add_shape", goArguments, "")

	log.Println("Got return value!")

}

/*
   Substitute a given area shape by another. The old shape is selected by its index, the new one by its [RID].
*/
func (o *physics2DServer) AreaSetShape(area *RID, shapeIdx int64, shape *RID) {
	log.Println("Calling Physics2DServer.AreaSetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(shapeIdx)
	goArguments[2] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_shape", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the transform matrix for an area shape.
*/
func (o *physics2DServer) AreaSetShapeTransform(area *RID, shapeIdx int64, transform *Transform2D) {
	log.Println("Calling Physics2DServer.AreaSetShapeTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(shapeIdx)
	goArguments[2] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_shape_transform", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physics2DServer) AreaSetShapeDisabled(area *RID, shapeIdx int64, disable bool) {
	log.Println("Calling Physics2DServer.AreaSetShapeDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(shapeIdx)
	goArguments[2] = reflect.ValueOf(disable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_shape_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the number of shapes assigned to an area.
*/
func (o *physics2DServer) AreaGetShapeCount(area *RID) int64 {
	log.Println("Calling Physics2DServer.AreaGetShapeCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_shape_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the [RID] of the nth shape of an area.
*/
func (o *physics2DServer) AreaGetShape(area *RID, shapeIdx int64) *RID {
	log.Println("Calling Physics2DServer.AreaGetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_shape", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Return the transform matrix of a shape within an area.
*/
func (o *physics2DServer) AreaGetShapeTransform(area *RID, shapeIdx int64) *Transform2D {
	log.Println("Calling Physics2DServer.AreaGetShapeTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_shape_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Remove a shape from an area. It does not delete the shape, so it can be reassigned later.
*/
func (o *physics2DServer) AreaRemoveShape(area *RID, shapeIdx int64) {
	log.Println("Calling Physics2DServer.AreaRemoveShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_remove_shape", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove all shapes from an area. It does not delete the shapes, so they can be reassigned later.
*/
func (o *physics2DServer) AreaClearShapes(area *RID) {
	log.Println("Calling Physics2DServer.AreaClearShapes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_clear_shapes", goArguments, "")

	log.Println("Got return value!")

}

/*
   Assign the area to one or many physics layers.
*/
func (o *physics2DServer) AreaSetCollisionLayer(area *RID, layer int64) {
	log.Println("Calling Physics2DServer.AreaSetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_collision_layer", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set which physics layers the area will monitor.
*/
func (o *physics2DServer) AreaSetCollisionMask(area *RID, mask int64) {
	log.Println("Calling Physics2DServer.AreaSetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_collision_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the value for an area parameter. A list of available parameters is on the AREA_PARAM_* constants.
*/
func (o *physics2DServer) AreaSetParam(area *RID, param int64, value *Variant) {
	log.Println("Calling Physics2DServer.AreaSetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(param)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_param", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the transform matrix for an area.
*/
func (o *physics2DServer) AreaSetTransform(area *RID, transform *Transform2D) {
	log.Println("Calling Physics2DServer.AreaSetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return an area parameter value.
*/
func (o *physics2DServer) AreaGetParam(area *RID, param int64) *Variant {
	log.Println("Calling Physics2DServer.AreaGetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_param", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Return the transform matrix for an area.
*/
func (o *physics2DServer) AreaGetTransform(area *RID) *Transform2D {
	log.Println("Calling Physics2DServer.AreaGetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Assign the area to a descendant of [Object], so it can exist in the node tree.
*/
func (o *physics2DServer) AreaAttachObjectInstanceId(area *RID, id int64) {
	log.Println("Calling Physics2DServer.AreaAttachObjectInstanceId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_attach_object_instance_id", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the instance ID of the object the area is assigned to.
*/
func (o *physics2DServer) AreaGetObjectInstanceId(area *RID) int64 {
	log.Println("Calling Physics2DServer.AreaGetObjectInstanceId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_object_instance_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the function to call when any body/area enters or exits the area. This callback will be called for any object interacting with the area, and takes five parameters: 1: AREA_BODY_ADDED or AREA_BODY_REMOVED, depending on whether the object entered or exited the area. 2: [RID] of the object that entered/exited the area. 3: Instance ID of the object that entered/exited the area. 4: The shape index of the object that entered/exited the area. 5: The shape index of the area where the object entered/exited.
*/
func (o *physics2DServer) AreaSetMonitorCallback(area *RID, receiver *Object, method string) {
	log.Println("Calling Physics2DServer.AreaSetMonitorCallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(receiver)
	goArguments[2] = reflect.ValueOf(method)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_monitor_callback", goArguments, "")

	log.Println("Got return value!")

}

/*
   Create a physics body. The first parameter can be any value from constants BODY_MODE*, for the type of body created. Additionally, the body can be created in sleeping state to save processing time.
*/
func (o *physics2DServer) BodyCreate(mode int64, initSleeping bool) *RID {
	log.Println("Calling Physics2DServer.BodyCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(mode)
	goArguments[1] = reflect.ValueOf(initSleeping)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_create", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Assign a space to the body (see [method create_space]).
*/
func (o *physics2DServer) BodySetSpace(body *RID, space *RID) {
	log.Println("Calling Physics2DServer.BodySetSpace()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(space)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_space", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the [RID] of the space assigned to a body.
*/
func (o *physics2DServer) BodyGetSpace(body *RID) *RID {
	log.Println("Calling Physics2DServer.BodyGetSpace()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_space", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Set the body mode, from one of the constants BODY_MODE*.
*/
func (o *physics2DServer) BodySetMode(body *RID, mode int64) {
	log.Println("Calling Physics2DServer.BodySetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the body mode.
*/
func (o *physics2DServer) BodyGetMode(body *RID) int64 {
	log.Println("Calling Physics2DServer.BodyGetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Add a shape to the body, along with a transform matrix. Shapes are usually referenced by their index, so you should track which shape has a given index.
*/
func (o *physics2DServer) BodyAddShape(body *RID, shape *RID, transform *Transform2D) {
	log.Println("Calling Physics2DServer.BodyAddShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shape)
	goArguments[2] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_add_shape", goArguments, "")

	log.Println("Got return value!")

}

/*
   Substitute a given body shape by another. The old shape is selected by its index, the new one by its [RID].
*/
func (o *physics2DServer) BodySetShape(body *RID, shapeIdx int64, shape *RID) {
	log.Println("Calling Physics2DServer.BodySetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)
	goArguments[2] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_shape", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the transform matrix for a body shape.
*/
func (o *physics2DServer) BodySetShapeTransform(body *RID, shapeIdx int64, transform *Transform2D) {
	log.Println("Calling Physics2DServer.BodySetShapeTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)
	goArguments[2] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_shape_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set metadata of a shape within a body. This metadata is different from [method Object.set_meta], and can be retrieved on shape queries.
*/
func (o *physics2DServer) BodySetShapeMetadata(body *RID, shapeIdx int64, metadata *Variant) {
	log.Println("Calling Physics2DServer.BodySetShapeMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)
	goArguments[2] = reflect.ValueOf(metadata)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_shape_metadata", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the number of shapes assigned to a body.
*/
func (o *physics2DServer) BodyGetShapeCount(body *RID) int64 {
	log.Println("Calling Physics2DServer.BodyGetShapeCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_shape_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the [RID] of the nth shape of a body.
*/
func (o *physics2DServer) BodyGetShape(body *RID, shapeIdx int64) *RID {
	log.Println("Calling Physics2DServer.BodyGetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_shape", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Return the transform matrix of a body shape.
*/
func (o *physics2DServer) BodyGetShapeTransform(body *RID, shapeIdx int64) *Transform2D {
	log.Println("Calling Physics2DServer.BodyGetShapeTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_shape_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Return the metadata of a shape of a body.
*/
func (o *physics2DServer) BodyGetShapeMetadata(body *RID, shapeIdx int64) *Variant {
	log.Println("Calling Physics2DServer.BodyGetShapeMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_shape_metadata", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Remove a shape from a body. The shape is not deleted, so it can be reused afterwards.
*/
func (o *physics2DServer) BodyRemoveShape(body *RID, shapeIdx int64) {
	log.Println("Calling Physics2DServer.BodyRemoveShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_remove_shape", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove all shapes from a body.
*/
func (o *physics2DServer) BodyClearShapes(body *RID) {
	log.Println("Calling Physics2DServer.BodyClearShapes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_clear_shapes", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physics2DServer) BodySetShapeDisabled(body *RID, shapeIdx int64, disable bool) {
	log.Println("Calling Physics2DServer.BodySetShapeDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)
	goArguments[2] = reflect.ValueOf(disable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_shape_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *physics2DServer) BodySetShapeAsOneWayCollision(body *RID, shapeIdx int64, enable bool) {
	log.Println("Calling Physics2DServer.BodySetShapeAsOneWayCollision()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)
	goArguments[2] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_shape_as_one_way_collision", goArguments, "")

	log.Println("Got return value!")

}

/*
   Assign the area to a descendant of [Object], so it can exist in the node tree.
*/
func (o *physics2DServer) BodyAttachObjectInstanceId(body *RID, id int64) {
	log.Println("Calling Physics2DServer.BodyAttachObjectInstanceId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_attach_object_instance_id", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the instance ID of the object the area is assigned to.
*/
func (o *physics2DServer) BodyGetObjectInstanceId(body *RID) int64 {
	log.Println("Calling Physics2DServer.BodyGetObjectInstanceId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_object_instance_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the continuous collision detection mode from any of the CCD_MODE_* constants. Continuous collision detection tries to predict where a moving body will collide, instead of moving it and correcting its movement if it collided.
*/
func (o *physics2DServer) BodySetContinuousCollisionDetectionMode(body *RID, mode int64) {
	log.Println("Calling Physics2DServer.BodySetContinuousCollisionDetectionMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_continuous_collision_detection_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the continuous collision detection mode.
*/
func (o *physics2DServer) BodyGetContinuousCollisionDetectionMode(body *RID) int64 {
	log.Println("Calling Physics2DServer.BodyGetContinuousCollisionDetectionMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_continuous_collision_detection_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the physics layer or layers a body belongs to.
*/
func (o *physics2DServer) BodySetCollisionLayer(body *RID, layer int64) {
	log.Println("Calling Physics2DServer.BodySetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_collision_layer", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the physics layer or layers a body belongs to.
*/
func (o *physics2DServer) BodyGetCollisionLayer(body *RID) int64 {
	log.Println("Calling Physics2DServer.BodyGetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_collision_layer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the physics layer or layers a body can collide with.
*/
func (o *physics2DServer) BodySetCollisionMask(body *RID, mask int64) {
	log.Println("Calling Physics2DServer.BodySetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_collision_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the physics layer or layers a body can collide with.
*/
func (o *physics2DServer) BodyGetCollisionMask(body *RID) int64 {
	log.Println("Calling Physics2DServer.BodyGetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_collision_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set a body parameter (see BODY_PARAM* constants).
*/
func (o *physics2DServer) BodySetParam(body *RID, param int64, value float64) {
	log.Println("Calling Physics2DServer.BodySetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(param)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_param", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the value of a body parameter.
*/
func (o *physics2DServer) BodyGetParam(body *RID, param int64) float64 {
	log.Println("Calling Physics2DServer.BodyGetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set a body state (see BODY_STATE* constants).
*/
func (o *physics2DServer) BodySetState(body *RID, state int64, value *Variant) {
	log.Println("Calling Physics2DServer.BodySetState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(state)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_state", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return a body state.
*/
func (o *physics2DServer) BodyGetState(body *RID, state int64) *Variant {
	log.Println("Calling Physics2DServer.BodyGetState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(state)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_state", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Add a positioned impulse to the applied force and torque. Both the force and the offset from the body origin are in global coordinates.
*/
func (o *physics2DServer) BodyApplyImpulse(body *RID, position *Vector2, impulse *Vector2) {
	log.Println("Calling Physics2DServer.BodyApplyImpulse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(position)
	goArguments[2] = reflect.ValueOf(impulse)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_apply_impulse", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a positioned force to the applied force and torque. As with [method body_apply_impulse], both the force and the offset from the body origin are in global coordinates. A force differs from an impulse in that, while the two are forces, the impulse clears itself after being applied.
*/
func (o *physics2DServer) BodyAddForce(body *RID, offset *Vector2, force *Vector2) {
	log.Println("Calling Physics2DServer.BodyAddForce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(offset)
	goArguments[2] = reflect.ValueOf(force)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_add_force", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set an axis velocity. The velocity in the given vector axis will be set as the given vector length. This is useful for jumping behavior.
*/
func (o *physics2DServer) BodySetAxisVelocity(body *RID, axisVelocity *Vector2) {
	log.Println("Calling Physics2DServer.BodySetAxisVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(axisVelocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_axis_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a body to the list of bodies exempt from collisions.
*/
func (o *physics2DServer) BodyAddCollisionException(body *RID, exceptedBody *RID) {
	log.Println("Calling Physics2DServer.BodyAddCollisionException()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(exceptedBody)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_add_collision_exception", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove a body from the list of bodies exempt from collisions.
*/
func (o *physics2DServer) BodyRemoveCollisionException(body *RID, exceptedBody *RID) {
	log.Println("Calling Physics2DServer.BodyRemoveCollisionException()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(exceptedBody)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_remove_collision_exception", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the maximum contacts to report. Bodies can keep a log of the contacts with other bodies, this is enabled by setting the maximum amount of contacts reported to a number greater than 0.
*/
func (o *physics2DServer) BodySetMaxContactsReported(body *RID, amount int64) {
	log.Println("Calling Physics2DServer.BodySetMaxContactsReported()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_max_contacts_reported", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the maximum contacts that can be reported. See [method body_set_max_contacts_reported].
*/
func (o *physics2DServer) BodyGetMaxContactsReported(body *RID) int64 {
	log.Println("Calling Physics2DServer.BodyGetMaxContactsReported()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_max_contacts_reported", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set whether a body uses a callback function to calculate its own physics (see [method body_set_force_integration_callback]).
*/
func (o *physics2DServer) BodySetOmitForceIntegration(body *RID, enable bool) {
	log.Println("Calling Physics2DServer.BodySetOmitForceIntegration()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_omit_force_integration", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether a body uses a callback function to calculate its own physics (see [method body_set_force_integration_callback]).
*/
func (o *physics2DServer) BodyIsOmittingForceIntegration(body *RID) bool {
	log.Println("Calling Physics2DServer.BodyIsOmittingForceIntegration()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_is_omitting_force_integration", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the function used to calculate physics for an object, if that object allows it (see [method body_set_omit_force integration]).
*/
func (o *physics2DServer) BodySetForceIntegrationCallback(body *RID, receiver *Object, method string, userdata *Variant) {
	log.Println("Calling Physics2DServer.BodySetForceIntegrationCallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(receiver)
	goArguments[2] = reflect.ValueOf(method)
	goArguments[3] = reflect.ValueOf(userdata)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_force_integration_callback", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether a body can move from a given point in a given direction. Apart from the boolean return value, a [Physics2DTestMotionResult] can be passed to return additional information in.
*/
func (o *physics2DServer) BodyTestMotion(body *RID, from *Transform2D, motion *Vector2, margin float64, result *Physics2DTestMotionResult) bool {
	log.Println("Calling Physics2DServer.BodyTestMotion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(from)
	goArguments[2] = reflect.ValueOf(motion)
	goArguments[3] = reflect.ValueOf(margin)
	goArguments[4] = reflect.ValueOf(result)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_test_motion", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set a joint parameter. Parameters are explained in the JOINT_PARAM* constants.
*/
func (o *physics2DServer) JointSetParam(joint *RID, param int64, value float64) {
	log.Println("Calling Physics2DServer.JointSetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(param)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "joint_set_param", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the value of a joint parameter.
*/
func (o *physics2DServer) JointGetParam(joint *RID, param int64) float64 {
	log.Println("Calling Physics2DServer.JointGetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "joint_get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Create a pin joint between two bodies. If not specified, the second body is assumed to be the joint itself.
*/
func (o *physics2DServer) PinJointCreate(anchor *Vector2, bodyA *RID, bodyB *RID) *RID {
	log.Println("Calling Physics2DServer.PinJointCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(anchor)
	goArguments[1] = reflect.ValueOf(bodyA)
	goArguments[2] = reflect.ValueOf(bodyB)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "pin_joint_create", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Create a groove joint between two bodies. If not specified, the bodyies are assumed to be the joint itself.
*/
func (o *physics2DServer) GrooveJointCreate(groove1A *Vector2, groove2A *Vector2, anchorB *Vector2, bodyA *RID, bodyB *RID) *RID {
	log.Println("Calling Physics2DServer.GrooveJointCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(groove1A)
	goArguments[1] = reflect.ValueOf(groove2A)
	goArguments[2] = reflect.ValueOf(anchorB)
	goArguments[3] = reflect.ValueOf(bodyA)
	goArguments[4] = reflect.ValueOf(bodyB)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "groove_joint_create", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Create a damped spring joint between two bodies. If not specified, the second body is assumed to be the joint itself.
*/
func (o *physics2DServer) DampedSpringJointCreate(anchorA *Vector2, anchorB *Vector2, bodyA *RID, bodyB *RID) *RID {
	log.Println("Calling Physics2DServer.DampedSpringJointCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(anchorA)
	goArguments[1] = reflect.ValueOf(anchorB)
	goArguments[2] = reflect.ValueOf(bodyA)
	goArguments[3] = reflect.ValueOf(bodyB)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "damped_spring_joint_create", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Set a damped spring joint parameter. Parameters are explained in the DAMPED_STRING* constants.
*/
func (o *physics2DServer) DampedStringJointSetParam(joint *RID, param int64, value float64) {
	log.Println("Calling Physics2DServer.DampedStringJointSetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(param)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "damped_string_joint_set_param", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the value of a damped spring joint parameter.
*/
func (o *physics2DServer) DampedStringJointGetParam(joint *RID, param int64) float64 {
	log.Println("Calling Physics2DServer.DampedStringJointGetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "damped_string_joint_get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the type of a joint (see JOINT_* constants).
*/
func (o *physics2DServer) JointGetType(joint *RID) int64 {
	log.Println("Calling Physics2DServer.JointGetType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(joint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "joint_get_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Destroy any of the objects created by Physics2DServer. If the [RID] passed is not one of the objects that can be created by Physics2DServer, an error will be sent to the console.
*/
func (o *physics2DServer) FreeRid(rid *RID) {
	log.Println("Calling Physics2DServer.FreeRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rid)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "free_rid", goArguments, "")

	log.Println("Got return value!")

}

/*
   Activate or deactivate the 2D physics engine.
*/
func (o *physics2DServer) SetActive(active bool) {
	log.Println("Calling Physics2DServer.SetActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(active)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_active", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return information about the current state of the 2D physics engine. The states are listed under the INFO_* constants.
*/
func (o *physics2DServer) GetProcessInfo(processInfo int64) int64 {
	log.Println("Calling Physics2DServer.GetProcessInfo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(processInfo)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_process_info", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Software implementation of [Physics2DDirectBodyState]. This object exposes no new methods or properties and should not be used, as [Physics2DDirectBodyState] selects the best implementation available.
*/
type Physics2DDirectBodyStateSW struct {
	Physics2DDirectBodyState
}

func (o *Physics2DDirectBodyStateSW) baseClass() string {
	return "Physics2DDirectBodyStateSW"
}

/*
   Physics2DDirectBodyStateSWImplementer is an interface for Physics2DDirectBodyStateSW objects.
*/
type Physics2DDirectBodyStateSWImplementer interface {
	Class
}

/*
   Direct access object to a physics body in the [Physics2DServer]. This object is passed via the direct state callback of rigid/character bodies, and is intended for changing the direct state of that body.
*/
type Physics2DDirectBodyState struct {
	Object
}

func (o *Physics2DDirectBodyState) baseClass() string {
	return "Physics2DDirectBodyState"
}

/*
   Return the total gravity vector being currently applied to this body.
*/
func (o *Physics2DDirectBodyState) GetTotalGravity() *Vector2 {
	log.Println("Calling Physics2DDirectBodyState.GetTotalGravity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_total_gravity", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the rate at which the body stops moving, if there are not any other forces moving it.
*/
func (o *Physics2DDirectBodyState) GetTotalLinearDamp() float64 {
	log.Println("Calling Physics2DDirectBodyState.GetTotalLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_total_linear_damp", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the rate at which the body stops rotating, if there are not any other forces moving it.
*/
func (o *Physics2DDirectBodyState) GetTotalAngularDamp() float64 {
	log.Println("Calling Physics2DDirectBodyState.GetTotalAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_total_angular_damp", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the inverse of the mass of the body.
*/
func (o *Physics2DDirectBodyState) GetInverseMass() float64 {
	log.Println("Calling Physics2DDirectBodyState.GetInverseMass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_inverse_mass", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the inverse of the inertia of the body.
*/
func (o *Physics2DDirectBodyState) GetInverseInertia() float64 {
	log.Println("Calling Physics2DDirectBodyState.GetInverseInertia()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_inverse_inertia", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Change the linear velocity of the body.
*/
func (o *Physics2DDirectBodyState) SetLinearVelocity(velocity *Vector2) {
	log.Println("Calling Physics2DDirectBodyState.SetLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(velocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_linear_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current linear velocity of the body.
*/
func (o *Physics2DDirectBodyState) GetLinearVelocity() *Vector2 {
	log.Println("Calling Physics2DDirectBodyState.GetLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_linear_velocity", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Change the angular velocity of the body.
*/
func (o *Physics2DDirectBodyState) SetAngularVelocity(velocity float64) {
	log.Println("Calling Physics2DDirectBodyState.SetAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(velocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_angular_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the angular velocity of the body.
*/
func (o *Physics2DDirectBodyState) GetAngularVelocity() float64 {
	log.Println("Calling Physics2DDirectBodyState.GetAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_angular_velocity", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Change the transform matrix of the body.
*/
func (o *Physics2DDirectBodyState) SetTransform(transform *Transform2D) {
	log.Println("Calling Physics2DDirectBodyState.SetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the transform matrix of the body.
*/
func (o *Physics2DDirectBodyState) GetTransform() *Transform2D {
	log.Println("Calling Physics2DDirectBodyState.GetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Set the sleeping state of the body, only affects character/rigid bodies.
*/
func (o *Physics2DDirectBodyState) SetSleepState(enabled bool) {
	log.Println("Calling Physics2DDirectBodyState.SetSleepState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sleep_state", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if this body is currently sleeping (not active).
*/
func (o *Physics2DDirectBodyState) IsSleeping() bool {
	log.Println("Calling Physics2DDirectBodyState.IsSleeping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_sleeping", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return the amount of contacts this body has with other bodies. Note that by default this returns 0 unless bodies are configured to log contacts.
*/
func (o *Physics2DDirectBodyState) GetContactCount() int64 {
	log.Println("Calling Physics2DDirectBodyState.GetContactCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the local position (of this body) of the contact point.
*/
func (o *Physics2DDirectBodyState) GetContactLocalPosition(contactIdx int64) *Vector2 {
	log.Println("Calling Physics2DDirectBodyState.GetContactLocalPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_local_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the local normal (of this body) of the contact point.
*/
func (o *Physics2DDirectBodyState) GetContactLocalNormal(contactIdx int64) *Vector2 {
	log.Println("Calling Physics2DDirectBodyState.GetContactLocalNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_local_normal", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the local shape index of the collision.
*/
func (o *Physics2DDirectBodyState) GetContactLocalShape(contactIdx int64) int64 {
	log.Println("Calling Physics2DDirectBodyState.GetContactLocalShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_local_shape", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the [RID] of the collider.
*/
func (o *Physics2DDirectBodyState) GetContactCollider(contactIdx int64) *RID {
	log.Println("Calling Physics2DDirectBodyState.GetContactCollider()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_collider", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Return the contact position in the collider.
*/
func (o *Physics2DDirectBodyState) GetContactColliderPosition(contactIdx int64) *Vector2 {
	log.Println("Calling Physics2DDirectBodyState.GetContactColliderPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_collider_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the object id of the collider.
*/
func (o *Physics2DDirectBodyState) GetContactColliderId(contactIdx int64) int64 {
	log.Println("Calling Physics2DDirectBodyState.GetContactColliderId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_collider_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the collider object, this depends on how it was created (will return a scene node if such was used to create it).
*/
func (o *Physics2DDirectBodyState) GetContactColliderObject(contactIdx int64) *Object {
	log.Println("Calling Physics2DDirectBodyState.GetContactColliderObject()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_collider_object", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*
   Return the collider shape index.
*/
func (o *Physics2DDirectBodyState) GetContactColliderShape(contactIdx int64) int64 {
	log.Println("Calling Physics2DDirectBodyState.GetContactColliderShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_collider_shape", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the metadata of the collided shape. This metadata is different from [method Object.get_meta], and is set with [method Physics2DServer.shape_set_data].
*/
func (o *Physics2DDirectBodyState) GetContactColliderShapeMetadata(contactIdx int64) *Variant {
	log.Println("Calling Physics2DDirectBodyState.GetContactColliderShapeMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_collider_shape_metadata", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Return the linear velocity vector at contact point of the collider.
*/
func (o *Physics2DDirectBodyState) GetContactColliderVelocityAtPosition(contactIdx int64) *Vector2 {
	log.Println("Calling Physics2DDirectBodyState.GetContactColliderVelocityAtPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_collider_velocity_at_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the timestep (delta) used for the simulation.
*/
func (o *Physics2DDirectBodyState) GetStep() float64 {
	log.Println("Calling Physics2DDirectBodyState.GetStep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_step", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Call the built-in force integration code.
*/
func (o *Physics2DDirectBodyState) IntegrateForces() {
	log.Println("Calling Physics2DDirectBodyState.IntegrateForces()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "integrate_forces", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current state of space, useful for queries.
*/
func (o *Physics2DDirectBodyState) GetSpaceState() *Physics2DDirectSpaceState {
	log.Println("Calling Physics2DDirectBodyState.GetSpaceState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_space_state", goArguments, "*Physics2DDirectSpaceState")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Physics2DDirectSpaceState)

	return returnValue

}

/*
   Physics2DDirectBodyStateImplementer is an interface for Physics2DDirectBodyState objects.
*/
type Physics2DDirectBodyStateImplementer interface {
	Class
}

func newSingletonAudioServer() *audioServer {
	obj := &audioServer{}
	ptr := C.godot_global_get_singleton(C.CString("AudioServer"))
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*
   AudioServer is a low level server interface for audio access. It is in charge of creating sample data (playable audio) as well as its playback via a voice interface.
*/
var AudioServer = newSingletonAudioServer()

/*
   AudioServer is a low level server interface for audio access. It is in charge of creating sample data (playable audio) as well as its playback via a voice interface.
*/
type audioServer struct {
	Object
}

func (o *audioServer) baseClass() string {
	return "AudioServer"
}

/*

 */
func (o *audioServer) SetBusCount(amount int64) {
	log.Println("Calling AudioServer.SetBusCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bus_count", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *audioServer) GetBusCount() int64 {
	log.Println("Calling AudioServer.GetBusCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bus_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *audioServer) RemoveBus(index int64) {
	log.Println("Calling AudioServer.RemoveBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_bus", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *audioServer) AddBus(atPosition int64) {
	log.Println("Calling AudioServer.AddBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(atPosition)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_bus", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *audioServer) MoveBus(index int64, toIndex int64) {
	log.Println("Calling AudioServer.MoveBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(index)
	goArguments[1] = reflect.ValueOf(toIndex)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "move_bus", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *audioServer) SetBusName(busIdx int64, name string) {
	log.Println("Calling AudioServer.SetBusName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bus_name", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *audioServer) GetBusName(busIdx int64) string {
	log.Println("Calling AudioServer.GetBusName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(busIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bus_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *audioServer) GetBusIndex(busName string) int64 {
	log.Println("Calling AudioServer.GetBusIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(busName)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bus_index", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *audioServer) SetBusVolumeDb(busIdx int64, volumeDb float64) {
	log.Println("Calling AudioServer.SetBusVolumeDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(volumeDb)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bus_volume_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *audioServer) GetBusVolumeDb(busIdx int64) float64 {
	log.Println("Calling AudioServer.GetBusVolumeDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(busIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bus_volume_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *audioServer) SetBusSend(busIdx int64, send string) {
	log.Println("Calling AudioServer.SetBusSend()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(send)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bus_send", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *audioServer) GetBusSend(busIdx int64) string {
	log.Println("Calling AudioServer.GetBusSend()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(busIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bus_send", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *audioServer) SetBusSolo(busIdx int64, enable bool) {
	log.Println("Calling AudioServer.SetBusSolo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bus_solo", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *audioServer) IsBusSolo(busIdx int64) bool {
	log.Println("Calling AudioServer.IsBusSolo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(busIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_bus_solo", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *audioServer) SetBusMute(busIdx int64, enable bool) {
	log.Println("Calling AudioServer.SetBusMute()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bus_mute", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *audioServer) IsBusMute(busIdx int64) bool {
	log.Println("Calling AudioServer.IsBusMute()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(busIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_bus_mute", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *audioServer) SetBusBypassEffects(busIdx int64, enable bool) {
	log.Println("Calling AudioServer.SetBusBypassEffects()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bus_bypass_effects", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *audioServer) IsBusBypassingEffects(busIdx int64) bool {
	log.Println("Calling AudioServer.IsBusBypassingEffects()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(busIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_bus_bypassing_effects", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *audioServer) AddBusEffect(busIdx int64, effect *AudioEffect, atPosition int64) {
	log.Println("Calling AudioServer.AddBusEffect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(effect)
	goArguments[2] = reflect.ValueOf(atPosition)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_bus_effect", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *audioServer) RemoveBusEffect(busIdx int64, effectIdx int64) {
	log.Println("Calling AudioServer.RemoveBusEffect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(effectIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_bus_effect", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *audioServer) GetBusEffectCount(busIdx int64) int64 {
	log.Println("Calling AudioServer.GetBusEffectCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(busIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bus_effect_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *audioServer) GetBusEffect(busIdx int64, effectIdx int64) *AudioEffect {
	log.Println("Calling AudioServer.GetBusEffect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(effectIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bus_effect", goArguments, "*AudioEffect")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*AudioEffect)

	return returnValue

}

/*

 */
func (o *audioServer) SwapBusEffects(busIdx int64, effectIdx int64, byEffectIdx int64) {
	log.Println("Calling AudioServer.SwapBusEffects()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(effectIdx)
	goArguments[2] = reflect.ValueOf(byEffectIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "swap_bus_effects", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *audioServer) SetBusEffectEnabled(busIdx int64, effectIdx int64, enabled bool) {
	log.Println("Calling AudioServer.SetBusEffectEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(effectIdx)
	goArguments[2] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bus_effect_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *audioServer) IsBusEffectEnabled(busIdx int64, effectIdx int64) bool {
	log.Println("Calling AudioServer.IsBusEffectEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(effectIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_bus_effect_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *audioServer) GetBusPeakVolumeLeftDb(busIdx int64, channel int64) float64 {
	log.Println("Calling AudioServer.GetBusPeakVolumeLeftDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(channel)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bus_peak_volume_left_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *audioServer) GetBusPeakVolumeRightDb(busIdx int64, channel int64) float64 {
	log.Println("Calling AudioServer.GetBusPeakVolumeRightDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(channel)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bus_peak_volume_right_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *audioServer) Lock() {
	log.Println("Calling AudioServer.Lock()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "lock", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *audioServer) Unlock() {
	log.Println("Calling AudioServer.Unlock()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "unlock", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *audioServer) GetSpeakerMode() int64 {
	log.Println("Calling AudioServer.GetSpeakerMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_speaker_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *audioServer) GetMixRate() float64 {
	log.Println("Calling AudioServer.GetMixRate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mix_rate", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *audioServer) SetBusLayout(busLayout *AudioBusLayout) {
	log.Println("Calling AudioServer.SetBusLayout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(busLayout)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bus_layout", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *audioServer) GenerateBusLayout() *AudioBusLayout {
	log.Println("Calling AudioServer.GenerateBusLayout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "generate_bus_layout", goArguments, "*AudioBusLayout")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*AudioBusLayout)

	return returnValue

}

/*
   Default implementation of the [Input] class, used internally by the editor and games for default input management.
*/
type InputDefault struct {
	input
}

func (o *InputDefault) baseClass() string {
	return "InputDefault"
}

/*
   InputDefaultImplementer is an interface for InputDefault objects.
*/
type InputDefaultImplementer interface {
	Class
}

func newSingletonInput() *input {
	obj := &input{}
	ptr := C.godot_global_get_singleton(C.CString("Input"))
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*
   A Singleton that deals with inputs. This includes key presses, mouse buttons and movement, joypads, and input actions.
*/
var Input = newSingletonInput()

/*
   A Singleton that deals with inputs. This includes key presses, mouse buttons and movement, joypads, and input actions.
*/
type input struct {
	Object
}

func (o *input) baseClass() string {
	return "Input"
}

/*
   Returns true or false depending on whether the key is pressed or not. You can pass KEY_*, which are pre-defined constants listed in [@Global Scope].
*/
func (o *input) IsKeyPressed(scancode int64) bool {
	log.Println("Calling Input.IsKeyPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scancode)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_key_pressed", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns true or false depending on whether mouse button is pressed or not. You can pass BUTTON_*, which are pre-defined constants listed in [@Global Scope].
*/
func (o *input) IsMouseButtonPressed(button int64) bool {
	log.Println("Calling Input.IsMouseButtonPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(button)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_mouse_button_pressed", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns if the joypad button at the given index is currently pressed. (see JOY_* constants in [@Global Scope])
*/
func (o *input) IsJoyButtonPressed(device int64, button int64) bool {
	log.Println("Calling Input.IsJoyButtonPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(device)
	goArguments[1] = reflect.ValueOf(button)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_joy_button_pressed", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns true or false depending on whether the action event is pressed. Actions and their events can be set in the Project Settings / Input Map tab. Or be set with [InputMap].
*/
func (o *input) IsActionPressed(action string) bool {
	log.Println("Calling Input.IsActionPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_action_pressed", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *input) IsActionJustPressed(action string) bool {
	log.Println("Calling Input.IsActionJustPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_action_just_pressed", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *input) IsActionJustReleased(action string) bool {
	log.Println("Calling Input.IsActionJustReleased()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_action_just_released", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Add a new mapping entry (in SDL2 format) to the mapping database. Optionally update already connected devices.
*/
func (o *input) AddJoyMapping(mapping string, updateExisting bool) {
	log.Println("Calling Input.AddJoyMapping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(mapping)
	goArguments[1] = reflect.ValueOf(updateExisting)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_joy_mapping", goArguments, "")

	log.Println("Got return value!")

}

/*
   Removes all mappings from the internal db that match the given uid.
*/
func (o *input) RemoveJoyMapping(guid string) {
	log.Println("Calling Input.RemoveJoyMapping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(guid)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_joy_mapping", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns if the specified device is known by the system. This means that it sets all button and axis indices exactly as defined in the JOY_* constants (see [@Global Scope]). Unknown joypads are not expected to match these constants, but you can still retrieve events from them.
*/
func (o *input) IsJoyKnown(device int64) bool {
	log.Println("Calling Input.IsJoyKnown()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(device)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_joy_known", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns the current value of the joypad axis at given index (see JOY_* constants in [@Global Scope])
*/
func (o *input) GetJoyAxis(device int64, axis int64) float64 {
	log.Println("Calling Input.GetJoyAxis()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(device)
	goArguments[1] = reflect.ValueOf(axis)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_joy_axis", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns the name of the joypad at the specified device index
*/
func (o *input) GetJoyName(device int64) string {
	log.Println("Calling Input.GetJoyName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(device)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_joy_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Returns a SDL2 compatible device guid on platforms that use gamepad remapping. Returns "Default Gamepad" otherwise.
*/
func (o *input) GetJoyGuid(device int64) string {
	log.Println("Calling Input.GetJoyGuid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(device)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_joy_guid", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Returns an [Array] containing the device IDs of all currently connected joypads.
*/
func (o *input) GetConnectedJoypads() *Array {
	log.Println("Calling Input.GetConnectedJoypads()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connected_joypads", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Returns the strength of the joypad vibration: x is the strength of the weak motor, and y is the strength of the strong motor.
*/
func (o *input) GetJoyVibrationStrength(device int64) *Vector2 {
	log.Println("Calling Input.GetJoyVibrationStrength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(device)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_joy_vibration_strength", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Returns the duration of the current vibration effect in seconds.
*/
func (o *input) GetJoyVibrationDuration(device int64) float64 {
	log.Println("Calling Input.GetJoyVibrationDuration()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(device)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_joy_vibration_duration", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *input) GetJoyButtonString(buttonIndex int64) string {
	log.Println("Calling Input.GetJoyButtonString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(buttonIndex)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_joy_button_string", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *input) GetJoyButtonIndexFromString(button string) int64 {
	log.Println("Calling Input.GetJoyButtonIndexFromString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(button)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_joy_button_index_from_string", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *input) GetJoyAxisString(axisIndex int64) string {
	log.Println("Calling Input.GetJoyAxisString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(axisIndex)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_joy_axis_string", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *input) GetJoyAxisIndexFromString(axis string) int64 {
	log.Println("Calling Input.GetJoyAxisIndexFromString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(axis)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_joy_axis_index_from_string", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Starts to vibrate the joypad. Joypads usually come with two rumble motors, a strong and a weak one. weak_magnitude is the strength of the weak motor (between 0 and 1) and strong_magnitude is the strength of the strong motor (between 0 and 1). duration is the duration of the effect in seconds (a duration of 0 will try to play the vibration indefinitely). Note that not every hardware is compatible with long effect durations, it is recommended to restart an effect if in need to play it for more than a few seconds.
*/
func (o *input) StartJoyVibration(device int64, weakMagnitude float64, strongMagnitude float64, duration float64) {
	log.Println("Calling Input.StartJoyVibration()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(device)
	goArguments[1] = reflect.ValueOf(weakMagnitude)
	goArguments[2] = reflect.ValueOf(strongMagnitude)
	goArguments[3] = reflect.ValueOf(duration)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "start_joy_vibration", goArguments, "")

	log.Println("Got return value!")

}

/*
   Stops the vibration of the joypad.
*/
func (o *input) StopJoyVibration(device int64) {
	log.Println("Calling Input.StopJoyVibration()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(device)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "stop_joy_vibration", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *input) GetGravity() *Vector3 {
	log.Println("Calling Input.GetGravity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gravity", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   If the device has an accelerometer, this will return the movement.
*/
func (o *input) GetAccelerometer() *Vector3 {
	log.Println("Calling Input.GetAccelerometer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_accelerometer", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   If the device has a magnetometer, this will return the magnetic field strength in micro-Tesla for all axes.
*/
func (o *input) GetMagnetometer() *Vector3 {
	log.Println("Calling Input.GetMagnetometer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_magnetometer", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   If the device has a gyroscope, this will return the rate of rotation in rad/s around a device's x, y, and z axis.
*/
func (o *input) GetGyroscope() *Vector3 {
	log.Println("Calling Input.GetGyroscope()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gyroscope", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Returns the mouse speed for the last time the cursor was moved, and this until the next frame where the mouse moves. This means that even if the mouse is not moving, this function will still return the value of the last motion.
*/
func (o *input) GetLastMouseSpeed() *Vector2 {
	log.Println("Calling Input.GetLastMouseSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_last_mouse_speed", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Returns mouse buttons as a bitmask. If multiple mouse buttons are pressed at the same time the bits are added together.
*/
func (o *input) GetMouseButtonMask() int64 {
	log.Println("Calling Input.GetMouseButtonMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mouse_button_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the mouse mode. See the constants for more information.
*/
func (o *input) SetMouseMode(mode int64) {
	log.Println("Calling Input.SetMouseMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mouse_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the mouse mode. See the constants for more information.
*/
func (o *input) GetMouseMode() int64 {
	log.Println("Calling Input.GetMouseMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mouse_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Sets the mouse position to the specified vector.
*/
func (o *input) WarpMousePosition(to *Vector2) {
	log.Println("Calling Input.WarpMousePosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(to)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "warp_mouse_position", goArguments, "")

	log.Println("Got return value!")

}

/*
   This will simulate pressing the specificed action.
*/
func (o *input) ActionPress(action string) {
	log.Println("Calling Input.ActionPress()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "action_press", goArguments, "")

	log.Println("Got return value!")

}

/*
   If the specified action is already pressed, this will release it.
*/
func (o *input) ActionRelease(action string) {
	log.Println("Calling Input.ActionRelease()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "action_release", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *input) SetCustomMouseCursor(image *Resource, hotspot *Vector2) {
	log.Println("Calling Input.SetCustomMouseCursor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(image)
	goArguments[1] = reflect.ValueOf(hotspot)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_mouse_cursor", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *input) ParseInputEvent(event *InputEvent) {
	log.Println("Calling Input.ParseInputEvent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(event)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "parse_input_event", goArguments, "")

	log.Println("Got return value!")

}

func newSingletonARVRServer() *arvrServer {
	obj := &arvrServer{}
	ptr := C.godot_global_get_singleton(C.CString("ARVRServer"))
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*
   The AR/VR Server is the heart of our AR/VR solution and handles all the processing.
*/
var ARVRServer = newSingletonARVRServer()

/*
   The AR/VR Server is the heart of our AR/VR solution and handles all the processing.
*/
type arvrServer struct {
	Object
}

func (o *arvrServer) baseClass() string {
	return "ARVRServer"
}

/*
   Returns our world scale (see ARVROrigin for more information).
*/
func (o *arvrServer) GetWorldScale() float64 {
	log.Println("Calling ARVRServer.GetWorldScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_world_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Changing the world scale, see the ARVROrigin documentation for more information.
*/
func (o *arvrServer) SetWorldScale(arg0 float64) {
	log.Println("Calling ARVRServer.SetWorldScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_world_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Gets our reference frame transform, mostly used internally and exposed for GDNative build interfaces.
*/
func (o *arvrServer) GetReferenceFrame() *Transform {
	log.Println("Calling ARVRServer.GetReferenceFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_reference_frame", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*
   This is a really important function to understand correctly. AR and VR platforms all handle positioning slightly differently. For platforms that do not offer spatial tracking our origin point (0,0,0) is the location of our HMD but you have little control over the direction the player is facing in the real world. For platforms that do offer spatial tracking our origin point depends very much on the system. For OpenVR our origin point is usually the center of the tracking space, on the ground. For other platforms its often the location of the tracking camera. This method allows you to create a reference frame, it will take the current location of the HMD and use that to adjust all our tracking data in essence realigning the real world to your players current position in your game world. For this method to produce usable results tracking information should be available and this often takes a few frames after starting your game. You should call this method after a few seconds have passed, when the user requests a realignment of the display holding a designated button on a controller for a short period of time, and when implementing a teleport mechanism.
*/
func (o *arvrServer) RequestReferenceFrame(ignoreTilt bool, keepHeight bool) {
	log.Println("Calling ARVRServer.RequestReferenceFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ignoreTilt)
	goArguments[1] = reflect.ValueOf(keepHeight)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "request_reference_frame", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the number of interfaces currently registered with the AR/VR server. If you're game supports multiple AR/VR platforms you can look throught the available interface and either present the user with a selection or simply try an initialize each interface and use the first one that returns true.
*/
func (o *arvrServer) GetInterfaceCount() int64 {
	log.Println("Calling ARVRServer.GetInterfaceCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_interface_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the interface registered at a given index in our list of interfaces.
*/
func (o *arvrServer) GetInterface(idx int64) *ARVRInterface {
	log.Println("Calling ARVRServer.GetInterface()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_interface", goArguments, "*ARVRInterface")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*ARVRInterface)

	return returnValue

}

/*
   Find an interface by its name. Say that you're making a game that uses specific capabilities of an AR/VR platform you can find the interface for that platform by name and initialize it.
*/
func (o *arvrServer) FindInterface(name string) *ARVRInterface {
	log.Println("Calling ARVRServer.FindInterface()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "find_interface", goArguments, "*ARVRInterface")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*ARVRInterface)

	return returnValue

}

/*
   Get the number of trackers currently registered.
*/
func (o *arvrServer) GetTrackerCount() int64 {
	log.Println("Calling ARVRServer.GetTrackerCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tracker_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the positional tracker at the given ID.
*/
func (o *arvrServer) GetTracker(idx int64) *ARVRPositionalTracker {
	log.Println("Calling ARVRServer.GetTracker()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tracker", goArguments, "*ARVRPositionalTracker")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*ARVRPositionalTracker)

	return returnValue

}

/*
   Changes the primary interface to the specified interface. Again mostly exposed for GDNative interfaces.
*/
func (o *arvrServer) SetPrimaryInterface(arg0 *ARVRInterface) {
	log.Println("Calling ARVRServer.SetPrimaryInterface()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_primary_interface", goArguments, "")

	log.Println("Got return value!")

}

/*
   Mostly exposed for GDNative based interfaces, this is called to register an available interface with the AR/VR server.
*/
func (o *arvrServer) AddInterface(arg0 *ARVRInterface) {
	log.Println("Calling ARVRServer.AddInterface()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_interface", goArguments, "")

	log.Println("Got return value!")

}

/*
   Removes a registered interface, again exposed mostly for GDNative based interfaces.
*/
func (o *arvrServer) RemoveInterface(arg0 *ARVRInterface) {
	log.Println("Calling ARVRServer.RemoveInterface()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_interface", goArguments, "")

	log.Println("Got return value!")

}

/*
   This class needs to be implemented to make an AR or VR platform available to Godot and these should be implemented as C++ modules or GDNative modules (note that for GDNative the subclass ARVRScriptInterface should be used). Part of the interface is exposed to GDScript so you can detect, enable and configure an AR or VR platform. Interfaces should be written in such a way that simply enabling them will give us a working setup. You can query the available interfaces through ARVRServer.
*/
type ARVRInterface struct {
	Reference
}

func (o *ARVRInterface) baseClass() string {
	return "ARVRInterface"
}

/*
   Returns the name of this interface (OpenVR, OpenHMD, ARKit, etc).
*/
func (o *ARVRInterface) GetName() string {
	log.Println("Calling ARVRInterface.GetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Returns true if this interface is currently the primary interface (the interface responsible for showing the output).
*/
func (o *ARVRInterface) IsPrimary() bool {
	log.Println("Calling ARVRInterface.IsPrimary()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_primary", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set this interface to the primary interface (unset the old one).
*/
func (o *ARVRInterface) SetIsPrimary(enable bool) {
	log.Println("Calling ARVRInterface.SetIsPrimary()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_is_primary", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns true if this interface has been installed. Say your game is designed to work with OpenVR so you are using the OpenVR interface but the user hasn't installed SteamVR, this would return false.
*/
func (o *ARVRInterface) IsInstalled() bool {
	log.Println("Calling ARVRInterface.IsInstalled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_installed", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns true if an HMD is available for this interface.
*/
func (o *ARVRInterface) HmdIsPresent() bool {
	log.Println("Calling ARVRInterface.HmdIsPresent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "hmd_is_present", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns true if this interface supports HMDs and by extension uses stereo scopic rendering.
*/
func (o *ARVRInterface) SupportsHmd() bool {
	log.Println("Calling ARVRInterface.SupportsHmd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "supports_hmd", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns true if this interface is active.
*/
func (o *ARVRInterface) IsInitialized() bool {
	log.Println("Calling ARVRInterface.IsInitialized()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_initialized", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Call this to initialize this interface. The first interface that is initialized is identified as the primary interface and it will be used for rendering output. After initializing the interface you want to use you then need to enable the AR/VR mode of a viewport and rendering should commence. Note that you must enable the AR/VR mode on the main viewport for any device that uses the main output of Godot such as for mobile VR. If you do this for a platform that handles its own output (such as OpenVR) Godot will show just one eye without distortion on screen. Alternatively you can add a separate viewport node to your scene and enable AR/VR on that viewport and it will be used to output to the HMD leaving you free to do anything you like in the main window such as using a separate camera as a spectator camera or render out something completely different. While currently not used you can activate additional interfaces, you may wish to do this if you want to track controllers from other platforms. However at this point in time only one interface can render to an HMD.
*/
func (o *ARVRInterface) Initialize() bool {
	log.Println("Calling ARVRInterface.Initialize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "initialize", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Turns the interface off.
*/
func (o *ARVRInterface) Uninitialize() {
	log.Println("Calling ARVRInterface.Uninitialize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "uninitialize", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the resolution at which we should render our intermediate results before things like lens distortion are applied by the VR platform.
*/
func (o *ARVRInterface) GetRecommendedRenderTargetsize() *Vector2 {
	log.Println("Calling ARVRInterface.GetRecommendedRenderTargetsize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_recommended_render_targetsize", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   ARVRInterfaceImplementer is an interface for ARVRInterface objects.
*/
type ARVRInterfaceImplementer interface {
	Class
}

/*
   An instance of this object represents a device that is tracked such as a controller or anchor point. HMDs aren't represented here as they are fully handled internally. As controllers are turned on and the AR/VR interface detects them instances of this object are automatically added to this list of active tracking objects accessible through the ARVRServer The ARVRController and ARVRAnchor both consume objects of this type and should be the objects you use in game. The positional trackers are just the under the hood objects that make this all work and are mostly exposed so GDNative based interfaces can interact with them.
*/
type ARVRPositionalTracker struct {
	Object
}

func (o *ARVRPositionalTracker) baseClass() string {
	return "ARVRPositionalTracker"
}

/*
   Type of tracker.
*/
func (o *ARVRPositionalTracker) GetType() int64 {
	log.Println("Calling ARVRPositionalTracker.GetType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   If available this returns the name of the controller or anchor point.
*/
func (o *ARVRPositionalTracker) GetName() string {
	log.Println("Calling ARVRPositionalTracker.GetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   If this is a controller that is being tracked the controller will also be represented by a joystick entry with this id.
*/
func (o *ARVRPositionalTracker) GetJoyId() int64 {
	log.Println("Calling ARVRPositionalTracker.GetJoyId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_joy_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns true if the orientation of this device is being tracked.
*/
func (o *ARVRPositionalTracker) GetTracksOrientation() bool {
	log.Println("Calling ARVRPositionalTracker.GetTracksOrientation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tracks_orientation", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns the orientation matrix of the controller.
*/
func (o *ARVRPositionalTracker) GetOrientation() *Basis {
	log.Println("Calling ARVRPositionalTracker.GetOrientation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_orientation", goArguments, "*Basis")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Basis)

	return returnValue

}

/*
   Returns true if the position of this device is being tracked.
*/
func (o *ARVRPositionalTracker) GetTracksPosition() bool {
	log.Println("Calling ARVRPositionalTracker.GetTracksPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tracks_position", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns the position of the controller adjusted by world scale.
*/
func (o *ARVRPositionalTracker) GetPosition() *Vector3 {
	log.Println("Calling ARVRPositionalTracker.GetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_position", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *ARVRPositionalTracker) GetHand() int64 {
	log.Println("Calling ARVRPositionalTracker.GetHand()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_hand", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the transform combining the orientation and position of this device.
*/
func (o *ARVRPositionalTracker) GetTransform(adjustByReferenceFrame bool) *Transform {
	log.Println("Calling ARVRPositionalTracker.GetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(adjustByReferenceFrame)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_transform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*
   Undocumented
*/
func (o *ARVRPositionalTracker) X_SetType(aType int64) {
	log.Println("Calling ARVRPositionalTracker.X_SetType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_type", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ARVRPositionalTracker) X_SetName(name string) {
	log.Println("Calling ARVRPositionalTracker.X_SetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_name", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ARVRPositionalTracker) X_SetJoyId(joyId int64) {
	log.Println("Calling ARVRPositionalTracker.X_SetJoyId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(joyId)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_joy_id", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ARVRPositionalTracker) X_SetOrientation(orientation *Basis) {
	log.Println("Calling ARVRPositionalTracker.X_SetOrientation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(orientation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_orientation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ARVRPositionalTracker) X_SetRwPosition(rwPosition *Vector3) {
	log.Println("Calling ARVRPositionalTracker.X_SetRwPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rwPosition)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_rw_position", goArguments, "")

	log.Println("Got return value!")

}

/*
   ARVRPositionalTrackerImplementer is an interface for ARVRPositionalTracker objects.
*/
type ARVRPositionalTrackerImplementer interface {
	Class
}

/*
   This class is used as a base class/interface class for implementing GDNative based ARVR interfaces and as a result exposes more of the internals of the ARVR server.
*/
type ARVRScriptInterface struct {
	ARVRInterface
}

func (o *ARVRScriptInterface) baseClass() string {
	return "ARVRScriptInterface"
}

/*
   Returns true if the required middleware is installed.
*/
func (o *ARVRScriptInterface) IsInstalled() bool {
	log.Println("Calling ARVRScriptInterface.IsInstalled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_installed", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return true is an HMD is available.
*/
func (o *ARVRScriptInterface) HmdIsPresent() bool {
	log.Println("Calling ARVRScriptInterface.HmdIsPresent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "hmd_is_present", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns true if this interface supports HMDs.
*/
func (o *ARVRScriptInterface) SupportsHmd() bool {
	log.Println("Calling ARVRScriptInterface.SupportsHmd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "supports_hmd", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns true if this interface has been initialized and is active.
*/
func (o *ARVRScriptInterface) IsInitialized() bool {
	log.Println("Calling ARVRScriptInterface.IsInitialized()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_initialized", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Initialize this interface.
*/
func (o *ARVRScriptInterface) Initialize() bool {
	log.Println("Calling ARVRScriptInterface.Initialize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "initialize", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Turn this interface off.
*/
func (o *ARVRScriptInterface) Uninitialize() {
	log.Println("Calling ARVRScriptInterface.Uninitialize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "uninitialize", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns true if we require stereoscopic rendering for this interface.
*/
func (o *ARVRScriptInterface) IsStereo() bool {
	log.Println("Calling ARVRScriptInterface.IsStereo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_stereo", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns the size at which we should render our scene to get optimal quality on the output device.
*/
func (o *ARVRScriptInterface) GetRecommendedRenderTargetsize() *Vector2 {
	log.Println("Calling ARVRScriptInterface.GetRecommendedRenderTargetsize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_recommended_render_targetsize", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Get the location and orientation transform used when rendering a specific eye.
*/
func (o *ARVRScriptInterface) GetTransformForEye(eye int64, camTransform *Transform) *Transform {
	log.Println("Calling ARVRScriptInterface.GetTransformForEye()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(eye)
	goArguments[1] = reflect.ValueOf(camTransform)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_transform_for_eye", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*
   Should return the projection 4x4 matrix for the requested eye.
*/
func (o *ARVRScriptInterface) X_GetProjectionForEye() {
	log.Println("Calling ARVRScriptInterface.X_GetProjectionForEye()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_get_projection_for_eye", goArguments, "")

	log.Println("Got return value!")

}

/*
   Outputs a finished render buffer to the AR/VR device for the given eye.
*/
func (o *ARVRScriptInterface) CommitForEye(eye int64, renderTarget *RID) {
	log.Println("Calling ARVRScriptInterface.CommitForEye()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(eye)
	goArguments[1] = reflect.ValueOf(renderTarget)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "commit_for_eye", goArguments, "")

	log.Println("Got return value!")

}

/*
   Gets called before rendering each frame so tracking data gets updated in time.
*/
func (o *ARVRScriptInterface) Process() {
	log.Println("Calling ARVRScriptInterface.Process()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "process", goArguments, "")

	log.Println("Got return value!")

}

/*
   ARVRScriptInterfaceImplementer is an interface for ARVRScriptInterface objects.
*/
type ARVRScriptInterfaceImplementer interface {
	Class
}

/*
   Base class for audio streams. Audio streams are used for music playback, or other types of streamed sounds that don't fit or require more flexibility than a [Sample].
*/
type AudioStream struct {
	Resource
}

func (o *AudioStream) baseClass() string {
	return "AudioStream"
}

/*
   AudioStreamImplementer is an interface for AudioStream objects.
*/
type AudioStreamImplementer interface {
	Class
}

/*

 */
type AudioStreamPlayback struct {
	Reference
}

func (o *AudioStreamPlayback) baseClass() string {
	return "AudioStreamPlayback"
}

/*
   AudioStreamPlaybackImplementer is an interface for AudioStreamPlayback objects.
*/
type AudioStreamPlaybackImplementer interface {
	Class
}

/*
   Randomly varies pitch on each start.
*/
type AudioStreamRandomPitch struct {
	AudioStream
}

func (o *AudioStreamRandomPitch) baseClass() string {
	return "AudioStreamRandomPitch"
}

/*

 */
func (o *AudioStreamRandomPitch) SetAudioStream(stream *AudioStream) {
	log.Println("Calling AudioStreamRandomPitch.SetAudioStream()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(stream)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_audio_stream", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamRandomPitch) GetAudioStream() *AudioStream {
	log.Println("Calling AudioStreamRandomPitch.GetAudioStream()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_audio_stream", goArguments, "*AudioStream")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*AudioStream)

	return returnValue

}

/*

 */
func (o *AudioStreamRandomPitch) SetRandomPitch(scale float64) {
	log.Println("Calling AudioStreamRandomPitch.SetRandomPitch()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_random_pitch", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamRandomPitch) GetRandomPitch() float64 {
	log.Println("Calling AudioStreamRandomPitch.GetRandomPitch()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_random_pitch", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   AudioStreamRandomPitchImplementer is an interface for AudioStreamRandomPitch objects.
*/
type AudioStreamRandomPitchImplementer interface {
	Class
}

/*
   Base resource for audio bus. Applies an audio effect on the bus that the resource is applied on.
*/
type AudioEffect struct {
	Resource
}

func (o *AudioEffect) baseClass() string {
	return "AudioEffect"
}

/*
   AudioEffectImplementer is an interface for AudioEffect objects.
*/
type AudioEffectImplementer interface {
	Class
}

/*

 */
type AudioBusLayout struct {
	Resource
}

func (o *AudioBusLayout) baseClass() string {
	return "AudioBusLayout"
}

/*
   AudioBusLayoutImplementer is an interface for AudioBusLayout objects.
*/
type AudioBusLayoutImplementer interface {
	Class
}

/*
   Amplifies the volume of an audio source. Increase gain of the audio being routed through the bus.
*/
type AudioEffectAmplify struct {
	AudioEffect
}

func (o *AudioEffectAmplify) baseClass() string {
	return "AudioEffectAmplify"
}

/*
   Sets the maximum volume.
*/
func (o *AudioEffectAmplify) SetVolumeDb(volume float64) {
	log.Println("Calling AudioEffectAmplify.SetVolumeDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(volume)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_volume_db", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the set maximum volume.
*/
func (o *AudioEffectAmplify) GetVolumeDb() float64 {
	log.Println("Calling AudioEffectAmplify.GetVolumeDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_volume_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   AudioEffectAmplifyImplementer is an interface for AudioEffectAmplify objects.
*/
type AudioEffectAmplifyImplementer interface {
	Class
}

/*

 */
type AudioEffectReverb struct {
	AudioEffect
}

func (o *AudioEffectReverb) baseClass() string {
	return "AudioEffectReverb"
}

/*

 */
func (o *AudioEffectReverb) SetPredelayMsec(msec float64) {
	log.Println("Calling AudioEffectReverb.SetPredelayMsec()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(msec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_predelay_msec", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectReverb) GetPredelayMsec() float64 {
	log.Println("Calling AudioEffectReverb.GetPredelayMsec()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_predelay_msec", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectReverb) SetPredelayFeedback(feedback float64) {
	log.Println("Calling AudioEffectReverb.SetPredelayFeedback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(feedback)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_predelay_feedback", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectReverb) GetPredelayFeedback() float64 {
	log.Println("Calling AudioEffectReverb.GetPredelayFeedback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_predelay_feedback", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectReverb) SetRoomSize(size float64) {
	log.Println("Calling AudioEffectReverb.SetRoomSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_room_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectReverb) GetRoomSize() float64 {
	log.Println("Calling AudioEffectReverb.GetRoomSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_room_size", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectReverb) SetDamping(amount float64) {
	log.Println("Calling AudioEffectReverb.SetDamping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_damping", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectReverb) GetDamping() float64 {
	log.Println("Calling AudioEffectReverb.GetDamping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_damping", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectReverb) SetSpread(amount float64) {
	log.Println("Calling AudioEffectReverb.SetSpread()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_spread", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectReverb) GetSpread() float64 {
	log.Println("Calling AudioEffectReverb.GetSpread()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_spread", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectReverb) SetDry(amount float64) {
	log.Println("Calling AudioEffectReverb.SetDry()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dry", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectReverb) GetDry() float64 {
	log.Println("Calling AudioEffectReverb.GetDry()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dry", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectReverb) SetWet(amount float64) {
	log.Println("Calling AudioEffectReverb.SetWet()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_wet", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectReverb) GetWet() float64 {
	log.Println("Calling AudioEffectReverb.GetWet()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_wet", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectReverb) SetHpf(amount float64) {
	log.Println("Calling AudioEffectReverb.SetHpf()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_hpf", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectReverb) GetHpf() float64 {
	log.Println("Calling AudioEffectReverb.GetHpf()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_hpf", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   AudioEffectReverbImplementer is an interface for AudioEffectReverb objects.
*/
type AudioEffectReverbImplementer interface {
	Class
}

/*

 */
type AudioEffectFilter struct {
	AudioEffect
}

func (o *AudioEffectFilter) baseClass() string {
	return "AudioEffectFilter"
}

/*

 */
func (o *AudioEffectFilter) SetCutoff(freq float64) {
	log.Println("Calling AudioEffectFilter.SetCutoff()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(freq)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cutoff", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectFilter) GetCutoff() float64 {
	log.Println("Calling AudioEffectFilter.GetCutoff()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cutoff", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectFilter) SetResonance(amount float64) {
	log.Println("Calling AudioEffectFilter.SetResonance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_resonance", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectFilter) GetResonance() float64 {
	log.Println("Calling AudioEffectFilter.GetResonance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_resonance", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectFilter) SetGain(amount float64) {
	log.Println("Calling AudioEffectFilter.SetGain()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gain", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectFilter) GetGain() float64 {
	log.Println("Calling AudioEffectFilter.GetGain()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gain", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectFilter) SetDb(amount int64) {
	log.Println("Calling AudioEffectFilter.SetDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectFilter) GetDb() int64 {
	log.Println("Calling AudioEffectFilter.GetDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_db", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   AudioEffectFilterImplementer is an interface for AudioEffectFilter objects.
*/
type AudioEffectFilterImplementer interface {
	Class
}

/*

 */
type AudioEffectEQ struct {
	AudioEffect
}

func (o *AudioEffectEQ) baseClass() string {
	return "AudioEffectEQ"
}

/*

 */
func (o *AudioEffectEQ) SetBandGainDb(bandIdx int64, volumeDb float64) {
	log.Println("Calling AudioEffectEQ.SetBandGainDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(bandIdx)
	goArguments[1] = reflect.ValueOf(volumeDb)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_band_gain_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectEQ) GetBandGainDb(bandIdx int64) float64 {
	log.Println("Calling AudioEffectEQ.GetBandGainDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bandIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_band_gain_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectEQ) GetBandCount() int64 {
	log.Println("Calling AudioEffectEQ.GetBandCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_band_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   AudioEffectEQImplementer is an interface for AudioEffectEQ objects.
*/
type AudioEffectEQImplementer interface {
	Class
}

/*

 */
type AudioEffectLowPassFilter struct {
	AudioEffectFilter
}

func (o *AudioEffectLowPassFilter) baseClass() string {
	return "AudioEffectLowPassFilter"
}

/*
   AudioEffectLowPassFilterImplementer is an interface for AudioEffectLowPassFilter objects.
*/
type AudioEffectLowPassFilterImplementer interface {
	Class
}

/*

 */
type AudioEffectHighPassFilter struct {
	AudioEffectFilter
}

func (o *AudioEffectHighPassFilter) baseClass() string {
	return "AudioEffectHighPassFilter"
}

/*
   AudioEffectHighPassFilterImplementer is an interface for AudioEffectHighPassFilter objects.
*/
type AudioEffectHighPassFilterImplementer interface {
	Class
}

/*

 */
type AudioEffectBandPassFilter struct {
	AudioEffectFilter
}

func (o *AudioEffectBandPassFilter) baseClass() string {
	return "AudioEffectBandPassFilter"
}

/*
   AudioEffectBandPassFilterImplementer is an interface for AudioEffectBandPassFilter objects.
*/
type AudioEffectBandPassFilterImplementer interface {
	Class
}

/*

 */
type AudioEffectNotchFilter struct {
	AudioEffectFilter
}

func (o *AudioEffectNotchFilter) baseClass() string {
	return "AudioEffectNotchFilter"
}

/*
   AudioEffectNotchFilterImplementer is an interface for AudioEffectNotchFilter objects.
*/
type AudioEffectNotchFilterImplementer interface {
	Class
}

/*

 */
type AudioEffectBandLimitFilter struct {
	AudioEffectFilter
}

func (o *AudioEffectBandLimitFilter) baseClass() string {
	return "AudioEffectBandLimitFilter"
}

/*
   AudioEffectBandLimitFilterImplementer is an interface for AudioEffectBandLimitFilter objects.
*/
type AudioEffectBandLimitFilterImplementer interface {
	Class
}

/*

 */
type AudioEffectLowShelfFilter struct {
	AudioEffectFilter
}

func (o *AudioEffectLowShelfFilter) baseClass() string {
	return "AudioEffectLowShelfFilter"
}

/*
   AudioEffectLowShelfFilterImplementer is an interface for AudioEffectLowShelfFilter objects.
*/
type AudioEffectLowShelfFilterImplementer interface {
	Class
}

/*

 */
type AudioEffectHighShelfFilter struct {
	AudioEffectFilter
}

func (o *AudioEffectHighShelfFilter) baseClass() string {
	return "AudioEffectHighShelfFilter"
}

/*
   AudioEffectHighShelfFilterImplementer is an interface for AudioEffectHighShelfFilter objects.
*/
type AudioEffectHighShelfFilterImplementer interface {
	Class
}

/*

 */
type AudioEffectEQ6 struct {
	AudioEffectEQ
}

func (o *AudioEffectEQ6) baseClass() string {
	return "AudioEffectEQ6"
}

/*
   AudioEffectEQ6Implementer is an interface for AudioEffectEQ6 objects.
*/
type AudioEffectEQ6Implementer interface {
	Class
}

/*

 */
type AudioEffectEQ10 struct {
	AudioEffectEQ
}

func (o *AudioEffectEQ10) baseClass() string {
	return "AudioEffectEQ10"
}

/*
   AudioEffectEQ10Implementer is an interface for AudioEffectEQ10 objects.
*/
type AudioEffectEQ10Implementer interface {
	Class
}

/*

 */
type AudioEffectEQ21 struct {
	AudioEffectEQ
}

func (o *AudioEffectEQ21) baseClass() string {
	return "AudioEffectEQ21"
}

/*
   AudioEffectEQ21Implementer is an interface for AudioEffectEQ21 objects.
*/
type AudioEffectEQ21Implementer interface {
	Class
}

/*

 */
type AudioEffectDistortion struct {
	AudioEffect
}

func (o *AudioEffectDistortion) baseClass() string {
	return "AudioEffectDistortion"
}

/*

 */
func (o *AudioEffectDistortion) SetMode(mode int64) {
	log.Println("Calling AudioEffectDistortion.SetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDistortion) GetMode() int64 {
	log.Println("Calling AudioEffectDistortion.GetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioEffectDistortion) SetPreGain(preGain float64) {
	log.Println("Calling AudioEffectDistortion.SetPreGain()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(preGain)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pre_gain", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDistortion) GetPreGain() float64 {
	log.Println("Calling AudioEffectDistortion.GetPreGain()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pre_gain", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectDistortion) SetKeepHfHz(keepHfHz float64) {
	log.Println("Calling AudioEffectDistortion.SetKeepHfHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(keepHfHz)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_keep_hf_hz", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDistortion) GetKeepHfHz() float64 {
	log.Println("Calling AudioEffectDistortion.GetKeepHfHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_keep_hf_hz", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectDistortion) SetDrive(drive float64) {
	log.Println("Calling AudioEffectDistortion.SetDrive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(drive)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_drive", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDistortion) GetDrive() float64 {
	log.Println("Calling AudioEffectDistortion.GetDrive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_drive", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectDistortion) SetPostGain(postGain float64) {
	log.Println("Calling AudioEffectDistortion.SetPostGain()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(postGain)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_post_gain", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDistortion) GetPostGain() float64 {
	log.Println("Calling AudioEffectDistortion.GetPostGain()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_post_gain", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   AudioEffectDistortionImplementer is an interface for AudioEffectDistortion objects.
*/
type AudioEffectDistortionImplementer interface {
	Class
}

/*

 */
type AudioEffectStereoEnhance struct {
	AudioEffect
}

func (o *AudioEffectStereoEnhance) baseClass() string {
	return "AudioEffectStereoEnhance"
}

/*

 */
func (o *AudioEffectStereoEnhance) SetPanPullout(amount float64) {
	log.Println("Calling AudioEffectStereoEnhance.SetPanPullout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pan_pullout", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectStereoEnhance) GetPanPullout() float64 {
	log.Println("Calling AudioEffectStereoEnhance.GetPanPullout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pan_pullout", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectStereoEnhance) SetTimePullout(amount float64) {
	log.Println("Calling AudioEffectStereoEnhance.SetTimePullout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_time_pullout", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectStereoEnhance) GetTimePullout() float64 {
	log.Println("Calling AudioEffectStereoEnhance.GetTimePullout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_time_pullout", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectStereoEnhance) SetSurround(amount float64) {
	log.Println("Calling AudioEffectStereoEnhance.SetSurround()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_surround", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectStereoEnhance) GetSurround() float64 {
	log.Println("Calling AudioEffectStereoEnhance.GetSurround()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_surround", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   AudioEffectStereoEnhanceImplementer is an interface for AudioEffectStereoEnhance objects.
*/
type AudioEffectStereoEnhanceImplementer interface {
	Class
}

/*

 */
type AudioEffectPanner struct {
	AudioEffect
}

func (o *AudioEffectPanner) baseClass() string {
	return "AudioEffectPanner"
}

/*

 */
func (o *AudioEffectPanner) SetPan(cpanume float64) {
	log.Println("Calling AudioEffectPanner.SetPan()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(cpanume)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pan", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectPanner) GetPan() float64 {
	log.Println("Calling AudioEffectPanner.GetPan()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pan", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   AudioEffectPannerImplementer is an interface for AudioEffectPanner objects.
*/
type AudioEffectPannerImplementer interface {
	Class
}

/*
   Adds a chorus audio effect. The effect applies a filter with voices to duplicate the audio source and manipulate it through the filter.
*/
type AudioEffectChorus struct {
	AudioEffect
}

func (o *AudioEffectChorus) baseClass() string {
	return "AudioEffectChorus"
}

/*
   Set the number of voices in the effect's filter.
*/
func (o *AudioEffectChorus) SetVoiceCount(voices int64) {
	log.Println("Calling AudioEffectChorus.SetVoiceCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(voices)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_voice_count", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the set voice count.
*/
func (o *AudioEffectChorus) GetVoiceCount() int64 {
	log.Println("Calling AudioEffectChorus.GetVoiceCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_voice_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the delay of the voice's signal.
*/
func (o *AudioEffectChorus) SetVoiceDelayMs(voiceIdx int64, delayMs float64) {
	log.Println("Calling AudioEffectChorus.SetVoiceDelayMs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(voiceIdx)
	goArguments[1] = reflect.ValueOf(delayMs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_voice_delay_ms", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the voice's set delay.
*/
func (o *AudioEffectChorus) GetVoiceDelayMs(voiceIdx int64) float64 {
	log.Println("Calling AudioEffectChorus.GetVoiceDelayMs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(voiceIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_voice_delay_ms", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the voice filter's rate.
*/
func (o *AudioEffectChorus) SetVoiceRateHz(voiceIdx int64, rateHz float64) {
	log.Println("Calling AudioEffectChorus.SetVoiceRateHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(voiceIdx)
	goArguments[1] = reflect.ValueOf(rateHz)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_voice_rate_hz", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the voice filter's set rate in cycles.
*/
func (o *AudioEffectChorus) GetVoiceRateHz(voiceIdx int64) float64 {
	log.Println("Calling AudioEffectChorus.GetVoiceRateHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(voiceIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_voice_rate_hz", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the filter depth of the voice's signal.
*/
func (o *AudioEffectChorus) SetVoiceDepthMs(voiceIdx int64, depthMs float64) {
	log.Println("Calling AudioEffectChorus.SetVoiceDepthMs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(voiceIdx)
	goArguments[1] = reflect.ValueOf(depthMs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_voice_depth_ms", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the voice's set filter depth.
*/
func (o *AudioEffectChorus) GetVoiceDepthMs(voiceIdx int64) float64 {
	log.Println("Calling AudioEffectChorus.GetVoiceDepthMs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(voiceIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_voice_depth_ms", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the volume level of the voice.
*/
func (o *AudioEffectChorus) SetVoiceLevelDb(voiceIdx int64, levelDb float64) {
	log.Println("Calling AudioEffectChorus.SetVoiceLevelDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(voiceIdx)
	goArguments[1] = reflect.ValueOf(levelDb)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_voice_level_db", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the voice's set maximum volume.
*/
func (o *AudioEffectChorus) GetVoiceLevelDb(voiceIdx int64) float64 {
	log.Println("Calling AudioEffectChorus.GetVoiceLevelDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(voiceIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_voice_level_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the cutoff frequency of the voice. The maximum frequency the voice may affect.
*/
func (o *AudioEffectChorus) SetVoiceCutoffHz(voiceIdx int64, cutoffHz float64) {
	log.Println("Calling AudioEffectChorus.SetVoiceCutoffHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(voiceIdx)
	goArguments[1] = reflect.ValueOf(cutoffHz)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_voice_cutoff_hz", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the voice's set cutoff frequency.
*/
func (o *AudioEffectChorus) GetVoiceCutoffHz(voiceIdx int64) float64 {
	log.Println("Calling AudioEffectChorus.GetVoiceCutoffHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(voiceIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_voice_cutoff_hz", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the pan level of the voice.
*/
func (o *AudioEffectChorus) SetVoicePan(voiceIdx int64, pan float64) {
	log.Println("Calling AudioEffectChorus.SetVoicePan()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(voiceIdx)
	goArguments[1] = reflect.ValueOf(pan)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_voice_pan", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the voice's set pan.
*/
func (o *AudioEffectChorus) GetVoicePan(voiceIdx int64) float64 {
	log.Println("Calling AudioEffectChorus.GetVoicePan()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(voiceIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_voice_pan", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the amount of effect.
*/
func (o *AudioEffectChorus) SetWet(amount float64) {
	log.Println("Calling AudioEffectChorus.SetWet()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_wet", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the set applied wetness of the effect.
*/
func (o *AudioEffectChorus) GetWet() float64 {
	log.Println("Calling AudioEffectChorus.GetWet()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_wet", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns the set applied dryness of the effect.
*/
func (o *AudioEffectChorus) SetDry(amount float64) {
	log.Println("Calling AudioEffectChorus.SetDry()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dry", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the set dry ratio.
*/
func (o *AudioEffectChorus) GetDry() float64 {
	log.Println("Calling AudioEffectChorus.GetDry()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dry", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   AudioEffectChorusImplementer is an interface for AudioEffectChorus objects.
*/
type AudioEffectChorusImplementer interface {
	Class
}

/*

 */
type AudioEffectDelay struct {
	AudioEffect
}

func (o *AudioEffectDelay) baseClass() string {
	return "AudioEffectDelay"
}

/*

 */
func (o *AudioEffectDelay) SetDry(amount float64) {
	log.Println("Calling AudioEffectDelay.SetDry()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dry", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDelay) GetDry() float64 {
	log.Println("Calling AudioEffectDelay.GetDry()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dry", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectDelay) SetTap1Active(amount bool) {
	log.Println("Calling AudioEffectDelay.SetTap1Active()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tap1_active", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDelay) IsTap1Active() bool {
	log.Println("Calling AudioEffectDelay.IsTap1Active()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_tap1_active", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *AudioEffectDelay) SetTap1DelayMs(amount float64) {
	log.Println("Calling AudioEffectDelay.SetTap1DelayMs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tap1_delay_ms", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDelay) GetTap1DelayMs() float64 {
	log.Println("Calling AudioEffectDelay.GetTap1DelayMs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tap1_delay_ms", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectDelay) SetTap1LevelDb(amount float64) {
	log.Println("Calling AudioEffectDelay.SetTap1LevelDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tap1_level_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDelay) GetTap1LevelDb() float64 {
	log.Println("Calling AudioEffectDelay.GetTap1LevelDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tap1_level_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectDelay) SetTap1Pan(amount float64) {
	log.Println("Calling AudioEffectDelay.SetTap1Pan()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tap1_pan", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDelay) GetTap1Pan() float64 {
	log.Println("Calling AudioEffectDelay.GetTap1Pan()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tap1_pan", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectDelay) SetTap2Active(amount bool) {
	log.Println("Calling AudioEffectDelay.SetTap2Active()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tap2_active", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDelay) IsTap2Active() bool {
	log.Println("Calling AudioEffectDelay.IsTap2Active()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_tap2_active", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *AudioEffectDelay) SetTap2DelayMs(amount float64) {
	log.Println("Calling AudioEffectDelay.SetTap2DelayMs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tap2_delay_ms", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDelay) GetTap2DelayMs() float64 {
	log.Println("Calling AudioEffectDelay.GetTap2DelayMs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tap2_delay_ms", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectDelay) SetTap2LevelDb(amount float64) {
	log.Println("Calling AudioEffectDelay.SetTap2LevelDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tap2_level_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDelay) GetTap2LevelDb() float64 {
	log.Println("Calling AudioEffectDelay.GetTap2LevelDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tap2_level_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectDelay) SetTap2Pan(amount float64) {
	log.Println("Calling AudioEffectDelay.SetTap2Pan()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tap2_pan", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDelay) GetTap2Pan() float64 {
	log.Println("Calling AudioEffectDelay.GetTap2Pan()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tap2_pan", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectDelay) SetFeedbackActive(amount bool) {
	log.Println("Calling AudioEffectDelay.SetFeedbackActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_feedback_active", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDelay) IsFeedbackActive() bool {
	log.Println("Calling AudioEffectDelay.IsFeedbackActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_feedback_active", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *AudioEffectDelay) SetFeedbackDelayMs(amount float64) {
	log.Println("Calling AudioEffectDelay.SetFeedbackDelayMs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_feedback_delay_ms", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDelay) GetFeedbackDelayMs() float64 {
	log.Println("Calling AudioEffectDelay.GetFeedbackDelayMs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_feedback_delay_ms", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectDelay) SetFeedbackLevelDb(amount float64) {
	log.Println("Calling AudioEffectDelay.SetFeedbackLevelDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_feedback_level_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDelay) GetFeedbackLevelDb() float64 {
	log.Println("Calling AudioEffectDelay.GetFeedbackLevelDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_feedback_level_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectDelay) SetFeedbackLowpass(amount float64) {
	log.Println("Calling AudioEffectDelay.SetFeedbackLowpass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_feedback_lowpass", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDelay) GetFeedbackLowpass() float64 {
	log.Println("Calling AudioEffectDelay.GetFeedbackLowpass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_feedback_lowpass", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   AudioEffectDelayImplementer is an interface for AudioEffectDelay objects.
*/
type AudioEffectDelayImplementer interface {
	Class
}

/*

 */
type AudioEffectCompressor struct {
	AudioEffect
}

func (o *AudioEffectCompressor) baseClass() string {
	return "AudioEffectCompressor"
}

/*

 */
func (o *AudioEffectCompressor) SetThreshold(threshold float64) {
	log.Println("Calling AudioEffectCompressor.SetThreshold()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(threshold)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_threshold", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectCompressor) GetThreshold() float64 {
	log.Println("Calling AudioEffectCompressor.GetThreshold()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_threshold", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectCompressor) SetRatio(ratio float64) {
	log.Println("Calling AudioEffectCompressor.SetRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ratio)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ratio", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectCompressor) GetRatio() float64 {
	log.Println("Calling AudioEffectCompressor.GetRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ratio", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectCompressor) SetGain(gain float64) {
	log.Println("Calling AudioEffectCompressor.SetGain()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(gain)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gain", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectCompressor) GetGain() float64 {
	log.Println("Calling AudioEffectCompressor.GetGain()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gain", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectCompressor) SetAttackUs(attackUs float64) {
	log.Println("Calling AudioEffectCompressor.SetAttackUs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(attackUs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_attack_us", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectCompressor) GetAttackUs() float64 {
	log.Println("Calling AudioEffectCompressor.GetAttackUs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_attack_us", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectCompressor) SetReleaseMs(releaseMs float64) {
	log.Println("Calling AudioEffectCompressor.SetReleaseMs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(releaseMs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_release_ms", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectCompressor) GetReleaseMs() float64 {
	log.Println("Calling AudioEffectCompressor.GetReleaseMs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_release_ms", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectCompressor) SetMix(mix float64) {
	log.Println("Calling AudioEffectCompressor.SetMix()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mix)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mix", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectCompressor) GetMix() float64 {
	log.Println("Calling AudioEffectCompressor.GetMix()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mix", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectCompressor) SetSidechain(sidechain string) {
	log.Println("Calling AudioEffectCompressor.SetSidechain()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sidechain)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sidechain", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectCompressor) GetSidechain() string {
	log.Println("Calling AudioEffectCompressor.GetSidechain()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sidechain", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   AudioEffectCompressorImplementer is an interface for AudioEffectCompressor objects.
*/
type AudioEffectCompressorImplementer interface {
	Class
}

/*

 */
type AudioEffectLimiter struct {
	AudioEffect
}

func (o *AudioEffectLimiter) baseClass() string {
	return "AudioEffectLimiter"
}

/*

 */
func (o *AudioEffectLimiter) SetCeilingDb(ceiling float64) {
	log.Println("Calling AudioEffectLimiter.SetCeilingDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ceiling)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ceiling_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectLimiter) GetCeilingDb() float64 {
	log.Println("Calling AudioEffectLimiter.GetCeilingDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ceiling_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectLimiter) SetThresholdDb(threshold float64) {
	log.Println("Calling AudioEffectLimiter.SetThresholdDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(threshold)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_threshold_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectLimiter) GetThresholdDb() float64 {
	log.Println("Calling AudioEffectLimiter.GetThresholdDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_threshold_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectLimiter) SetSoftClipDb(softClip float64) {
	log.Println("Calling AudioEffectLimiter.SetSoftClipDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(softClip)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_soft_clip_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectLimiter) GetSoftClipDb() float64 {
	log.Println("Calling AudioEffectLimiter.GetSoftClipDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_soft_clip_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectLimiter) SetSoftClipRatio(softClip float64) {
	log.Println("Calling AudioEffectLimiter.SetSoftClipRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(softClip)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_soft_clip_ratio", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectLimiter) GetSoftClipRatio() float64 {
	log.Println("Calling AudioEffectLimiter.GetSoftClipRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_soft_clip_ratio", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   AudioEffectLimiterImplementer is an interface for AudioEffectLimiter objects.
*/
type AudioEffectLimiterImplementer interface {
	Class
}

/*

 */
type AudioEffectPitchShift struct {
	AudioEffect
}

func (o *AudioEffectPitchShift) baseClass() string {
	return "AudioEffectPitchShift"
}

/*

 */
func (o *AudioEffectPitchShift) SetPitchScale(rate float64) {
	log.Println("Calling AudioEffectPitchShift.SetPitchScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rate)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pitch_scale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectPitchShift) GetPitchScale() float64 {
	log.Println("Calling AudioEffectPitchShift.GetPitchScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pitch_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   AudioEffectPitchShiftImplementer is an interface for AudioEffectPitchShift objects.
*/
type AudioEffectPitchShiftImplementer interface {
	Class
}

/*

 */
type AudioEffectPhaser struct {
	AudioEffect
}

func (o *AudioEffectPhaser) baseClass() string {
	return "AudioEffectPhaser"
}

/*

 */
func (o *AudioEffectPhaser) SetRangeMinHz(hz float64) {
	log.Println("Calling AudioEffectPhaser.SetRangeMinHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(hz)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_range_min_hz", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectPhaser) GetRangeMinHz() float64 {
	log.Println("Calling AudioEffectPhaser.GetRangeMinHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_range_min_hz", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectPhaser) SetRangeMaxHz(hz float64) {
	log.Println("Calling AudioEffectPhaser.SetRangeMaxHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(hz)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_range_max_hz", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectPhaser) GetRangeMaxHz() float64 {
	log.Println("Calling AudioEffectPhaser.GetRangeMaxHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_range_max_hz", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectPhaser) SetRateHz(hz float64) {
	log.Println("Calling AudioEffectPhaser.SetRateHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(hz)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rate_hz", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectPhaser) GetRateHz() float64 {
	log.Println("Calling AudioEffectPhaser.GetRateHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rate_hz", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectPhaser) SetFeedback(fbk float64) {
	log.Println("Calling AudioEffectPhaser.SetFeedback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fbk)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_feedback", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectPhaser) GetFeedback() float64 {
	log.Println("Calling AudioEffectPhaser.GetFeedback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_feedback", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectPhaser) SetDepth(depth float64) {
	log.Println("Calling AudioEffectPhaser.SetDepth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(depth)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_depth", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectPhaser) GetDepth() float64 {
	log.Println("Calling AudioEffectPhaser.GetDepth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_depth", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   AudioEffectPhaserImplementer is an interface for AudioEffectPhaser objects.
*/
type AudioEffectPhaserImplementer interface {
	Class
}

/*
   Direct access object to a space in the [Physics2DServer]. It's used mainly to do queries against objects and areas residing in a given space.
*/
type Physics2DDirectSpaceState struct {
	Object
}

func (o *Physics2DDirectSpaceState) baseClass() string {
	return "Physics2DDirectSpaceState"
}

/*
   Check whether a point is inside any shape. The shapes the point is inside of are returned in an array containing dictionaries with the following fields: shape: Shape index within the object the point is in. metadata: Metadata of the shape the point is in. This metadata is different from [method Object.get_meta], and is set with [method Physics2DServer.shape_set_data]. collider_id: Id of the object the point is in. collider: Object the point is inside of. rid: [RID] of the object the point is in. Additionally, the method can take an array of objects or [RID]\ s that are to be excluded from collisions, a bitmask representing the physics layers to check in, and another bitmask for the types of objects to check (see TYPE_MASK_* constants).
*/
func (o *Physics2DDirectSpaceState) IntersectPoint(point *Vector2, maxResults int64, exclude *Array, collisionLayer int64, typeMask int64) *Array {
	log.Println("Calling Physics2DDirectSpaceState.IntersectPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(point)
	goArguments[1] = reflect.ValueOf(maxResults)
	goArguments[2] = reflect.ValueOf(exclude)
	goArguments[3] = reflect.ValueOf(collisionLayer)
	goArguments[4] = reflect.ValueOf(typeMask)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "intersect_point", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Intersect a ray in a given space. The returned object is a dictionary with the following fields: position: Place where ray is stopped. normal: Normal of the object at the point where the ray was stopped. shape: Shape index within the object against which the ray was stopped. metadata: Metadata of the shape against which the ray was stopped. This metadata is different from [method Object.get_meta], and is set with [method Physics2DServer.shape_set_data]. collider_id: Id of the object against which the ray was stopped. collider: Object against which the ray was stopped. rid: [RID] of the object against which the ray was stopped. If the ray did not intersect anything, then an empty dictionary (dir.empty()==true) is returned instead. Additionally, the method can take an array of objects or [RID]\ s that are to be excluded from collisions, a bitmask representing the physics layers to check in, and another bitmask for the types of objects to check (see TYPE_MASK_* constants).
*/
func (o *Physics2DDirectSpaceState) IntersectRay(from *Vector2, to *Vector2, exclude *Array, collisionLayer int64, typeMask int64) *Dictionary {
	log.Println("Calling Physics2DDirectSpaceState.IntersectRay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(to)
	goArguments[2] = reflect.ValueOf(exclude)
	goArguments[3] = reflect.ValueOf(collisionLayer)
	goArguments[4] = reflect.ValueOf(typeMask)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "intersect_ray", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
   Check the intersections of a shape, given through a [Physics2DShapeQueryParameters] object, against the space. The intersected shapes are returned in an array containing dictionaries with the following fields: shape: Shape index within the object the shape intersected. metadata: Metadata of the shape intersected by the shape given through the [Physics2DShapeQueryParameters]. This metadata is different from [method Object.get_meta], and is set with [method Physics2DServer.shape_set_data]. collider_id: Id of the object the shape intersected. collider: Object the shape intersected. rid: [RID] of the object the shape intersected. The number of intersections can be limited with the second parameter, to reduce the processing time.
*/
func (o *Physics2DDirectSpaceState) IntersectShape(shape *Physics2DShapeQueryParameters, maxResults int64) *Array {
	log.Println("Calling Physics2DDirectSpaceState.IntersectShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(shape)
	goArguments[1] = reflect.ValueOf(maxResults)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "intersect_shape", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Check whether the shape can travel to a point. If it can, the method will return an array with two floats: The first is the distance the shape can move in that direction without colliding, and the second is the distance at which it will collide. If the shape can not move, the array will be empty.
*/
func (o *Physics2DDirectSpaceState) CastMotion(shape *Physics2DShapeQueryParameters) *Array {
	log.Println("Calling Physics2DDirectSpaceState.CastMotion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "cast_motion", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Check the intersections of a shape, given through a [Physics2DShapeQueryParameters] object, against the space. The resulting array contains a list of points where the shape intersects another. Like with [method intersect_shape], the number of returned results can be limited to save processing time.
*/
func (o *Physics2DDirectSpaceState) CollideShape(shape *Physics2DShapeQueryParameters, maxResults int64) *Array {
	log.Println("Calling Physics2DDirectSpaceState.CollideShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(shape)
	goArguments[1] = reflect.ValueOf(maxResults)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "collide_shape", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Check the intersections of a shape, given through a [Physics2DShapeQueryParameters] object, against the space. If it collides with more than a shape, the nearest one is selected. The returned object is a dictionary containing the following fields: pointo: Place where the shapes intersect. normal: Normal of the object at the point where the shapes intersect. shape: Shape index within the object against which the shape intersected. metadata: Metadata of the shape against which the shape intersected. This metadata is different from [method Object.get_meta], and is set with [method Physics2DServer.shape_set_data]. collider_id: Id of the object against which the shape intersected. collider: Object against which the shape intersected. rid: [RID] of the object against which the shape intersected. linear_velocity: The movement vector of the object the shape intersected, if it was a body. If it was an area, it is (0,0). If the shape did not intersect anything, then an empty dictionary (dir.empty()==true) is returned instead.
*/
func (o *Physics2DDirectSpaceState) GetRestInfo(shape *Physics2DShapeQueryParameters) *Dictionary {
	log.Println("Calling Physics2DDirectSpaceState.GetRestInfo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rest_info", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
   Physics2DDirectSpaceStateImplementer is an interface for Physics2DDirectSpaceState objects.
*/
type Physics2DDirectSpaceStateImplementer interface {
	Class
}

/*

 */
type Physics2DShapeQueryResult struct {
	Reference
}

func (o *Physics2DShapeQueryResult) baseClass() string {
	return "Physics2DShapeQueryResult"
}

/*

 */
func (o *Physics2DShapeQueryResult) GetResultCount() int64 {
	log.Println("Calling Physics2DShapeQueryResult.GetResultCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_result_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Physics2DShapeQueryResult) GetResultRid(idx int64) *RID {
	log.Println("Calling Physics2DShapeQueryResult.GetResultRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_result_rid", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *Physics2DShapeQueryResult) GetResultObjectId(idx int64) int64 {
	log.Println("Calling Physics2DShapeQueryResult.GetResultObjectId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_result_object_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Physics2DShapeQueryResult) GetResultObject(idx int64) *Object {
	log.Println("Calling Physics2DShapeQueryResult.GetResultObject()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_result_object", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*

 */
func (o *Physics2DShapeQueryResult) GetResultObjectShape(idx int64) int64 {
	log.Println("Calling Physics2DShapeQueryResult.GetResultObjectShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_result_object_shape", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Physics2DShapeQueryResultImplementer is an interface for Physics2DShapeQueryResult objects.
*/
type Physics2DShapeQueryResultImplementer interface {
	Class
}

/*

 */
type Physics2DTestMotionResult struct {
	Reference
}

func (o *Physics2DTestMotionResult) baseClass() string {
	return "Physics2DTestMotionResult"
}

/*

 */
func (o *Physics2DTestMotionResult) GetMotion() *Vector2 {
	log.Println("Calling Physics2DTestMotionResult.GetMotion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_motion", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Physics2DTestMotionResult) GetMotionRemainder() *Vector2 {
	log.Println("Calling Physics2DTestMotionResult.GetMotionRemainder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_motion_remainder", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Physics2DTestMotionResult) GetCollisionPoint() *Vector2 {
	log.Println("Calling Physics2DTestMotionResult.GetCollisionPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_point", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Physics2DTestMotionResult) GetCollisionNormal() *Vector2 {
	log.Println("Calling Physics2DTestMotionResult.GetCollisionNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_normal", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Physics2DTestMotionResult) GetColliderVelocity() *Vector2 {
	log.Println("Calling Physics2DTestMotionResult.GetColliderVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider_velocity", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Physics2DTestMotionResult) GetColliderId() int64 {
	log.Println("Calling Physics2DTestMotionResult.GetColliderId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Physics2DTestMotionResult) GetColliderRid() *RID {
	log.Println("Calling Physics2DTestMotionResult.GetColliderRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider_rid", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *Physics2DTestMotionResult) GetCollider() *Object {
	log.Println("Calling Physics2DTestMotionResult.GetCollider()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*

 */
func (o *Physics2DTestMotionResult) GetColliderShape() int64 {
	log.Println("Calling Physics2DTestMotionResult.GetColliderShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider_shape", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Physics2DTestMotionResultImplementer is an interface for Physics2DTestMotionResult objects.
*/
type Physics2DTestMotionResultImplementer interface {
	Class
}

/*
   This class contains the shape and other parameters for intersection/collision queries.
*/
type Physics2DShapeQueryParameters struct {
	Reference
}

func (o *Physics2DShapeQueryParameters) baseClass() string {
	return "Physics2DShapeQueryParameters"
}

/*
   Set the [Shape2D] that will be used for collision/intersection queries.
*/
func (o *Physics2DShapeQueryParameters) SetShape(shape *Resource) {
	log.Println("Calling Physics2DShapeQueryParameters.SetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shape", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the [RID] of the shape to be used in queries.
*/
func (o *Physics2DShapeQueryParameters) SetShapeRid(shape *RID) {
	log.Println("Calling Physics2DShapeQueryParameters.SetShapeRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shape_rid", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the [RID] of the shape queried.
*/
func (o *Physics2DShapeQueryParameters) GetShapeRid() *RID {
	log.Println("Calling Physics2DShapeQueryParameters.GetShapeRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shape_rid", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Set the transormation matrix of the shape. This is necessary to set its position/rotation/scale.
*/
func (o *Physics2DShapeQueryParameters) SetTransform(transform *Transform2D) {
	log.Println("Calling Physics2DShapeQueryParameters.SetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the transform matrix of the shape queried.
*/
func (o *Physics2DShapeQueryParameters) GetTransform() *Transform2D {
	log.Println("Calling Physics2DShapeQueryParameters.GetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Set the current movement speed of the shape.
*/
func (o *Physics2DShapeQueryParameters) SetMotion(motion *Vector2) {
	log.Println("Calling Physics2DShapeQueryParameters.SetMotion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(motion)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_motion", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current movement speed of the shape.
*/
func (o *Physics2DShapeQueryParameters) GetMotion() *Vector2 {
	log.Println("Calling Physics2DShapeQueryParameters.GetMotion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_motion", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set the collision margin for the shape. A collision margin is an amount (in pixels) that the shape will grow when computing collisions, to account for numerical imprecision.
*/
func (o *Physics2DShapeQueryParameters) SetMargin(margin float64) {
	log.Println("Calling Physics2DShapeQueryParameters.SetMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_margin", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the collision margin for the shape.
*/
func (o *Physics2DShapeQueryParameters) GetMargin() float64 {
	log.Println("Calling Physics2DShapeQueryParameters.GetMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_margin", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the physics layer the shape belongs to.
*/
func (o *Physics2DShapeQueryParameters) SetCollisionLayer(collisionLayer int64) {
	log.Println("Calling Physics2DShapeQueryParameters.SetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collisionLayer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the physics layer the shape belongs to.
*/
func (o *Physics2DShapeQueryParameters) GetCollisionLayer() int64 {
	log.Println("Calling Physics2DShapeQueryParameters.GetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the type of object the shape belongs to (see Physics2DDirectSpaceState.TYPE_MASK_*).
*/
func (o *Physics2DShapeQueryParameters) SetObjectTypeMask(objectTypeMask int64) {
	log.Println("Calling Physics2DShapeQueryParameters.SetObjectTypeMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(objectTypeMask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_object_type_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the type of object the shape belongs to.
*/
func (o *Physics2DShapeQueryParameters) GetObjectTypeMask() int64 {
	log.Println("Calling Physics2DShapeQueryParameters.GetObjectTypeMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_object_type_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the list of objects, or object [RID]\ s, that will be excluded from collisions.
*/
func (o *Physics2DShapeQueryParameters) SetExclude(exclude *Array) {
	log.Println("Calling Physics2DShapeQueryParameters.SetExclude()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(exclude)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_exclude", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the list of objects, or object [RID]\ s, that will be excluded from collisions.
*/
func (o *Physics2DShapeQueryParameters) GetExclude() *Array {
	log.Println("Calling Physics2DShapeQueryParameters.GetExclude()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_exclude", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Physics2DShapeQueryParametersImplementer is an interface for Physics2DShapeQueryParameters objects.
*/
type Physics2DShapeQueryParametersImplementer interface {
	Class
}

/*

 */
type PhysicsShapeQueryParameters struct {
	Reference
}

func (o *PhysicsShapeQueryParameters) baseClass() string {
	return "PhysicsShapeQueryParameters"
}

/*

 */
func (o *PhysicsShapeQueryParameters) SetShape(shape *Resource) {
	log.Println("Calling PhysicsShapeQueryParameters.SetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsShapeQueryParameters) SetShapeRid(shape *RID) {
	log.Println("Calling PhysicsShapeQueryParameters.SetShapeRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shape_rid", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsShapeQueryParameters) GetShapeRid() *RID {
	log.Println("Calling PhysicsShapeQueryParameters.GetShapeRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shape_rid", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *PhysicsShapeQueryParameters) SetTransform(transform *Transform) {
	log.Println("Calling PhysicsShapeQueryParameters.SetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsShapeQueryParameters) GetTransform() *Transform {
	log.Println("Calling PhysicsShapeQueryParameters.GetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_transform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*

 */
func (o *PhysicsShapeQueryParameters) SetMargin(margin float64) {
	log.Println("Calling PhysicsShapeQueryParameters.SetMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_margin", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsShapeQueryParameters) GetMargin() float64 {
	log.Println("Calling PhysicsShapeQueryParameters.GetMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_margin", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *PhysicsShapeQueryParameters) SetCollisionLayer(collisionLayer int64) {
	log.Println("Calling PhysicsShapeQueryParameters.SetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collisionLayer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsShapeQueryParameters) GetCollisionLayer() int64 {
	log.Println("Calling PhysicsShapeQueryParameters.GetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsShapeQueryParameters) SetObjectTypeMask(objectTypeMask int64) {
	log.Println("Calling PhysicsShapeQueryParameters.SetObjectTypeMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(objectTypeMask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_object_type_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsShapeQueryParameters) GetObjectTypeMask() int64 {
	log.Println("Calling PhysicsShapeQueryParameters.GetObjectTypeMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_object_type_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsShapeQueryParameters) SetExclude(exclude *Array) {
	log.Println("Calling PhysicsShapeQueryParameters.SetExclude()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(exclude)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_exclude", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsShapeQueryParameters) GetExclude() *Array {
	log.Println("Calling PhysicsShapeQueryParameters.GetExclude()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_exclude", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   PhysicsShapeQueryParametersImplementer is an interface for PhysicsShapeQueryParameters objects.
*/
type PhysicsShapeQueryParametersImplementer interface {
	Class
}

/*

 */
type PhysicsDirectSpaceState struct {
	Object
}

func (o *PhysicsDirectSpaceState) baseClass() string {
	return "PhysicsDirectSpaceState"
}

/*

 */
func (o *PhysicsDirectSpaceState) IntersectRay(from *Vector3, to *Vector3, exclude *Array, collisionLayer int64, typeMask int64) *Dictionary {
	log.Println("Calling PhysicsDirectSpaceState.IntersectRay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(to)
	goArguments[2] = reflect.ValueOf(exclude)
	goArguments[3] = reflect.ValueOf(collisionLayer)
	goArguments[4] = reflect.ValueOf(typeMask)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "intersect_ray", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*

 */
func (o *PhysicsDirectSpaceState) IntersectShape(shape *PhysicsShapeQueryParameters, maxResults int64) *Array {
	log.Println("Calling PhysicsDirectSpaceState.IntersectShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(shape)
	goArguments[1] = reflect.ValueOf(maxResults)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "intersect_shape", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *PhysicsDirectSpaceState) CastMotion(shape *PhysicsShapeQueryParameters, motion *Vector3) *Array {
	log.Println("Calling PhysicsDirectSpaceState.CastMotion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(shape)
	goArguments[1] = reflect.ValueOf(motion)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "cast_motion", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *PhysicsDirectSpaceState) CollideShape(shape *PhysicsShapeQueryParameters, maxResults int64) *Array {
	log.Println("Calling PhysicsDirectSpaceState.CollideShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(shape)
	goArguments[1] = reflect.ValueOf(maxResults)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "collide_shape", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *PhysicsDirectSpaceState) GetRestInfo(shape *PhysicsShapeQueryParameters) *Dictionary {
	log.Println("Calling PhysicsDirectSpaceState.GetRestInfo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rest_info", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
   PhysicsDirectSpaceStateImplementer is an interface for PhysicsDirectSpaceState objects.
*/
type PhysicsDirectSpaceStateImplementer interface {
	Class
}

/*

 */
type PhysicsShapeQueryResult struct {
	Reference
}

func (o *PhysicsShapeQueryResult) baseClass() string {
	return "PhysicsShapeQueryResult"
}

/*

 */
func (o *PhysicsShapeQueryResult) GetResultCount() int64 {
	log.Println("Calling PhysicsShapeQueryResult.GetResultCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_result_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsShapeQueryResult) GetResultRid(idx int64) *RID {
	log.Println("Calling PhysicsShapeQueryResult.GetResultRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_result_rid", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *PhysicsShapeQueryResult) GetResultObjectId(idx int64) int64 {
	log.Println("Calling PhysicsShapeQueryResult.GetResultObjectId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_result_object_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsShapeQueryResult) GetResultObject(idx int64) *Object {
	log.Println("Calling PhysicsShapeQueryResult.GetResultObject()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_result_object", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*

 */
func (o *PhysicsShapeQueryResult) GetResultObjectShape(idx int64) int64 {
	log.Println("Calling PhysicsShapeQueryResult.GetResultObjectShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_result_object_shape", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   PhysicsShapeQueryResultImplementer is an interface for PhysicsShapeQueryResult objects.
*/
type PhysicsShapeQueryResultImplementer interface {
	Class
}

/*

 */
type BitmapFont struct {
	Font
}

func (o *BitmapFont) baseClass() string {
	return "BitmapFont"
}

/*

 */
func (o *BitmapFont) CreateFromFnt(path string) int64 {
	log.Println("Calling BitmapFont.CreateFromFnt()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "create_from_fnt", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the total font height (ascent plus descent) in pixels.
*/
func (o *BitmapFont) SetHeight(px float64) {
	log.Println("Calling BitmapFont.SetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(px)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_height", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the font ascent (number of pixels above the baseline).
*/
func (o *BitmapFont) SetAscent(px float64) {
	log.Println("Calling BitmapFont.SetAscent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(px)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ascent", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a kerning pair to the [BitmapFont] as a difference. Kerning pairs are special cases where a typeface advance is determined by the next character.
*/
func (o *BitmapFont) AddKerningPair(charA int64, charB int64, kerning int64) {
	log.Println("Calling BitmapFont.AddKerningPair()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(charA)
	goArguments[1] = reflect.ValueOf(charB)
	goArguments[2] = reflect.ValueOf(kerning)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_kerning_pair", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return a kerning pair as a difference.
*/
func (o *BitmapFont) GetKerningPair(charA int64, charB int64) int64 {
	log.Println("Calling BitmapFont.GetKerningPair()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(charA)
	goArguments[1] = reflect.ValueOf(charB)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_kerning_pair", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Add a texture to the [BitmapFont].
*/
func (o *BitmapFont) AddTexture(texture *Texture) {
	log.Println("Calling BitmapFont.AddTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_texture", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a character to the font, where [i]character[/i] is the unicode value, [i]texture[/i] is the texture index, [i]rect[/i] is the region in the texture (in pixels!), [i]align[/i] is the (optional) alignment for the character and [i]advance[/i] is the (optional) advance.
*/
func (o *BitmapFont) AddChar(character int64, texture int64, rect *Rect2, align *Vector2, advance float64) {
	log.Println("Calling BitmapFont.AddChar()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(character)
	goArguments[1] = reflect.ValueOf(texture)
	goArguments[2] = reflect.ValueOf(rect)
	goArguments[3] = reflect.ValueOf(align)
	goArguments[4] = reflect.ValueOf(advance)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_char", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *BitmapFont) GetTextureCount() int64 {
	log.Println("Calling BitmapFont.GetTextureCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *BitmapFont) GetTexture(idx int64) *Texture {
	log.Println("Calling BitmapFont.GetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   Return the size of a character, optionally taking kerning into account if the next character is provided.
*/
func (o *BitmapFont) GetCharSize(char int64, next int64) *Vector2 {
	log.Println("Calling BitmapFont.GetCharSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(char)
	goArguments[1] = reflect.ValueOf(next)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_char_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *BitmapFont) SetDistanceFieldHint(enable bool) {
	log.Println("Calling BitmapFont.SetDistanceFieldHint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_distance_field_hint", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear all the font data.
*/
func (o *BitmapFont) Clear() {
	log.Println("Calling BitmapFont.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *BitmapFont) X_SetChars(arg0 *PoolIntArray) {
	log.Println("Calling BitmapFont.X_SetChars()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_chars", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *BitmapFont) X_GetChars() *PoolIntArray {
	log.Println("Calling BitmapFont.X_GetChars()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_chars", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*
   Undocumented
*/
func (o *BitmapFont) X_SetKernings(arg0 *PoolIntArray) {
	log.Println("Calling BitmapFont.X_SetKernings()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_kernings", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *BitmapFont) X_GetKernings() *PoolIntArray {
	log.Println("Calling BitmapFont.X_GetKernings()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_kernings", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*
   Undocumented
*/
func (o *BitmapFont) X_SetTextures(arg0 *Array) {
	log.Println("Calling BitmapFont.X_SetTextures()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_textures", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *BitmapFont) X_GetTextures() *Array {
	log.Println("Calling BitmapFont.X_GetTextures()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_textures", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *BitmapFont) SetFallback(fallback *BitmapFont) {
	log.Println("Calling BitmapFont.SetFallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fallback)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fallback", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *BitmapFont) GetFallback() *BitmapFont {
	log.Println("Calling BitmapFont.GetFallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fallback", goArguments, "*BitmapFont")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*BitmapFont)

	return returnValue

}

/*
   BitmapFontImplementer is an interface for BitmapFont objects.
*/
type BitmapFontImplementer interface {
	Class
}

/*
   Theme for skinning controls. Controls can be skinned individually, but for complex applications it's more efficient to just create a global theme that defines everything. This theme can be applied to any [Control], and it and its children will automatically use it. Theme resources can be alternatively loaded by writing them in a .theme file, see docs for more info.
*/
type Theme struct {
	Resource
}

func (o *Theme) baseClass() string {
	return "Theme"
}

/*

 */
func (o *Theme) SetIcon(name string, aType string, texture *Texture) {
	log.Println("Calling Theme.SetIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)
	goArguments[2] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_icon", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Theme) GetIcon(name string, aType string) *Texture {
	log.Println("Calling Theme.GetIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_icon", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *Theme) HasIcon(name string, aType string) bool {
	log.Println("Calling Theme.HasIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_icon", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Theme) ClearIcon(name string, aType string) {
	log.Println("Calling Theme.ClearIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_icon", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Theme) GetIconList(aType string) *PoolStringArray {
	log.Println("Calling Theme.GetIconList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_icon_list", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*

 */
func (o *Theme) SetStylebox(name string, aType string, texture *StyleBox) {
	log.Println("Calling Theme.SetStylebox()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)
	goArguments[2] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_stylebox", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Theme) GetStylebox(name string, aType string) *StyleBox {
	log.Println("Calling Theme.GetStylebox()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stylebox", goArguments, "*StyleBox")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*StyleBox)

	return returnValue

}

/*

 */
func (o *Theme) HasStylebox(name string, aType string) bool {
	log.Println("Calling Theme.HasStylebox()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_stylebox", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Theme) ClearStylebox(name string, aType string) {
	log.Println("Calling Theme.ClearStylebox()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_stylebox", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Theme) GetStyleboxList(aType string) *PoolStringArray {
	log.Println("Calling Theme.GetStyleboxList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stylebox_list", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*

 */
func (o *Theme) GetStyleboxTypes() *PoolStringArray {
	log.Println("Calling Theme.GetStyleboxTypes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stylebox_types", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*

 */
func (o *Theme) SetFont(name string, aType string, font *Font) {
	log.Println("Calling Theme.SetFont()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)
	goArguments[2] = reflect.ValueOf(font)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_font", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Theme) GetFont(name string, aType string) *Font {
	log.Println("Calling Theme.GetFont()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_font", goArguments, "*Font")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Font)

	return returnValue

}

/*

 */
func (o *Theme) HasFont(name string, aType string) bool {
	log.Println("Calling Theme.HasFont()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_font", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Theme) ClearFont(name string, aType string) {
	log.Println("Calling Theme.ClearFont()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_font", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Theme) GetFontList(aType string) *PoolStringArray {
	log.Println("Calling Theme.GetFontList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_font_list", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*

 */
func (o *Theme) SetColor(name string, aType string, color *Color) {
	log.Println("Calling Theme.SetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)
	goArguments[2] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Theme) GetColor(name string, aType string) *Color {
	log.Println("Calling Theme.GetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *Theme) HasColor(name string, aType string) bool {
	log.Println("Calling Theme.HasColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_color", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Theme) ClearColor(name string, aType string) {
	log.Println("Calling Theme.ClearColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Theme) GetColorList(aType string) *PoolStringArray {
	log.Println("Calling Theme.GetColorList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_color_list", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*

 */
func (o *Theme) SetConstant(name string, aType string, constant int64) {
	log.Println("Calling Theme.SetConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)
	goArguments[2] = reflect.ValueOf(constant)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_constant", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Theme) GetConstant(name string, aType string) int64 {
	log.Println("Calling Theme.GetConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_constant", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Theme) HasConstant(name string, aType string) bool {
	log.Println("Calling Theme.HasConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_constant", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Theme) ClearConstant(name string, aType string) {
	log.Println("Calling Theme.ClearConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_constant", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Theme) GetConstantList(aType string) *PoolStringArray {
	log.Println("Calling Theme.GetConstantList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_constant_list", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*

 */
func (o *Theme) SetDefaultFont(font *Font) {
	log.Println("Calling Theme.SetDefaultFont()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(font)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_default_font", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Theme) GetDefaultFont() *Font {
	log.Println("Calling Theme.GetDefaultFont()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_default_font", goArguments, "*Font")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Font)

	return returnValue

}

/*

 */
func (o *Theme) GetTypeList(aType string) *PoolStringArray {
	log.Println("Calling Theme.GetTypeList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_type_list", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Undocumented
*/
func (o *Theme) X_EmitThemeChanged() {
	log.Println("Calling Theme.X_EmitThemeChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_emit_theme_changed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Theme) CopyDefaultTheme() {
	log.Println("Calling Theme.CopyDefaultTheme()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "copy_default_theme", goArguments, "")

	log.Println("Got return value!")

}

/*
   ThemeImplementer is an interface for Theme objects.
*/
type ThemeImplementer interface {
	Class
}

/*
   Font contains a unicode compatible character set, as well as the ability to draw it with variable width, ascent, descent and kerning. For creating fonts from TTF files (or other font formats), see the editor support for fonts. TODO check wikipedia for graph of ascent/baseline/descent/height/etc.
*/
type Font struct {
	Resource
}

func (o *Font) baseClass() string {
	return "Font"
}

/*
   Draw "string" into a canvas item using the font at a given position, with "modulate" color, and optionally clipping the width. "position" specifies the baseline, not the top. To draw from the top, [i]ascent[/i] must be added to the Y axis.
*/
func (o *Font) Draw(canvasItem *RID, position *Vector2, string string, modulate *Color, clipW int64) {
	log.Println("Calling Font.Draw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(canvasItem)
	goArguments[1] = reflect.ValueOf(position)
	goArguments[2] = reflect.ValueOf(string)
	goArguments[3] = reflect.ValueOf(modulate)
	goArguments[4] = reflect.ValueOf(clipW)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the font ascent (number of pixels above the baseline).
*/
func (o *Font) GetAscent() float64 {
	log.Println("Calling Font.GetAscent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ascent", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the font descent (number of pixels below the baseline).
*/
func (o *Font) GetDescent() float64 {
	log.Println("Calling Font.GetDescent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_descent", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the total font height (ascent plus descent) in pixels.
*/
func (o *Font) GetHeight() float64 {
	log.Println("Calling Font.GetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_height", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Font) IsDistanceFieldHint() bool {
	log.Println("Calling Font.IsDistanceFieldHint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_distance_field_hint", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return the size of a string, taking kerning and advance into account.
*/
func (o *Font) GetStringSize(string string) *Vector2 {
	log.Println("Calling Font.GetStringSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(string)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_string_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Draw character "char" into a canvas item using the font at a given position, with "modulate" color, and optionally kerning if "next" is passed. clipping the width. "position" specifies the baseline, not the top. To draw from the top, [i]ascent[/i] must be added to the Y axis. The width used by the character is returned, making this function useful for drawing strings character by character.
*/
func (o *Font) DrawChar(canvasItem *RID, position *Vector2, char int64, next int64, modulate *Color) float64 {
	log.Println("Calling Font.DrawChar()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(canvasItem)
	goArguments[1] = reflect.ValueOf(position)
	goArguments[2] = reflect.ValueOf(char)
	goArguments[3] = reflect.ValueOf(next)
	goArguments[4] = reflect.ValueOf(modulate)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "draw_char", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   After editing a font (changing size, ascent, char rects, etc.). Call this function to propagate changes to controls that might use it.
*/
func (o *Font) UpdateChanges() {
	log.Println("Calling Font.UpdateChanges()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "update_changes", goArguments, "")

	log.Println("Got return value!")

}

/*
   FontImplementer is an interface for Font objects.
*/
type FontImplementer interface {
	Class
}

/*
   A [Texture] based on an [Image]. Can be created from an [Image].
*/
type ImageTexture struct {
	Texture
}

func (o *ImageTexture) baseClass() string {
	return "ImageTexture"
}

/*
   Create a new [ImageTexture] with "width" and "height". "format" one of [Image].FORMAT_*. "flags" one or more of [Texture].FLAG_*.
*/
func (o *ImageTexture) Create(width int64, height int64, format int64, flags int64) {
	log.Println("Calling ImageTexture.Create()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(width)
	goArguments[1] = reflect.ValueOf(height)
	goArguments[2] = reflect.ValueOf(format)
	goArguments[3] = reflect.ValueOf(flags)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create", goArguments, "")

	log.Println("Got return value!")

}

/*
   Create a new [ImageTexture] from an [Image] with "flags" from [Texture].FLAG_*.
*/
func (o *ImageTexture) CreateFromImage(image *Image, flags int64) {
	log.Println("Calling ImageTexture.CreateFromImage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(image)
	goArguments[1] = reflect.ValueOf(flags)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create_from_image", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the format of the [ImageTexture], one of [Image].FORMAT_*.
*/
func (o *ImageTexture) GetFormat() int64 {
	log.Println("Calling ImageTexture.GetFormat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_format", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Load an [ImageTexure].
*/
func (o *ImageTexture) Load(path string) {
	log.Println("Calling ImageTexture.Load()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "load", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the [Image] of this [ImageTexture].
*/
func (o *ImageTexture) SetData(image *Image) {
	log.Println("Calling ImageTexture.SetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(image)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_data", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the storage type. One of [ImageTexture].STORAGE_*.
*/
func (o *ImageTexture) SetStorage(mode int64) {
	log.Println("Calling ImageTexture.SetStorage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_storage", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the storage type. One of [ImageTexture].STORAGE_*.
*/
func (o *ImageTexture) GetStorage() int64 {
	log.Println("Calling ImageTexture.GetStorage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_storage", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the storage quality in case of [ImageTexture].STORAGE_COMPRESS_LOSSY.
*/
func (o *ImageTexture) SetLossyStorageQuality(quality float64) {
	log.Println("Calling ImageTexture.SetLossyStorageQuality()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(quality)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_lossy_storage_quality", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the storage quality for [ImageTexture].STORAGE_COMPRESS_LOSSY.
*/
func (o *ImageTexture) GetLossyStorageQuality() float64 {
	log.Println("Calling ImageTexture.GetLossyStorageQuality()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_lossy_storage_quality", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ImageTexture) SetSizeOverride(size *Vector2) {
	log.Println("Calling ImageTexture.SetSizeOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_size_override", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ImageTexture) X_ReloadHook(rid *RID) {
	log.Println("Calling ImageTexture.X_ReloadHook()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rid)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_reload_hook", goArguments, "")

	log.Println("Got return value!")

}

/*
   ImageTextureImplementer is an interface for ImageTexture objects.
*/
type ImageTextureImplementer interface {
	Class
}

/*
   A texture works by registering an image in the video hardware, which then can be used in 3D models or 2D [Sprite] or GUI [Control].
*/
type Texture struct {
	Resource
}

func (o *Texture) baseClass() string {
	return "Texture"
}

/*
   Return the texture width.
*/
func (o *Texture) GetWidth() int64 {
	log.Println("Calling Texture.GetWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_width", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the texture height.
*/
func (o *Texture) GetHeight() int64 {
	log.Println("Calling Texture.GetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_height", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the texture size.
*/
func (o *Texture) GetSize() *Vector2 {
	log.Println("Calling Texture.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Texture) HasAlpha() bool {
	log.Println("Calling Texture.HasAlpha()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_alpha", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Change the texture flags.
*/
func (o *Texture) SetFlags(flags int64) {
	log.Println("Calling Texture.SetFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flags)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flags", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current texture flags.
*/
func (o *Texture) GetFlags() int64 {
	log.Println("Calling Texture.GetFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_flags", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Texture) Draw(canvasItem *RID, position *Vector2, modulate *Color, transpose bool, normalMap *Texture) {
	log.Println("Calling Texture.Draw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(canvasItem)
	goArguments[1] = reflect.ValueOf(position)
	goArguments[2] = reflect.ValueOf(modulate)
	goArguments[3] = reflect.ValueOf(transpose)
	goArguments[4] = reflect.ValueOf(normalMap)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Texture) DrawRect(canvasItem *RID, rect *Rect2, tile bool, modulate *Color, transpose bool, normalMap *Texture) {
	log.Println("Calling Texture.DrawRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 6, 6)
	goArguments[0] = reflect.ValueOf(canvasItem)
	goArguments[1] = reflect.ValueOf(rect)
	goArguments[2] = reflect.ValueOf(tile)
	goArguments[3] = reflect.ValueOf(modulate)
	goArguments[4] = reflect.ValueOf(transpose)
	goArguments[5] = reflect.ValueOf(normalMap)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_rect", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Texture) DrawRectRegion(canvasItem *RID, rect *Rect2, srcRect *Rect2, modulate *Color, transpose bool, normalMap *Texture, clipUv bool) {
	log.Println("Calling Texture.DrawRectRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 7, 7)
	goArguments[0] = reflect.ValueOf(canvasItem)
	goArguments[1] = reflect.ValueOf(rect)
	goArguments[2] = reflect.ValueOf(srcRect)
	goArguments[3] = reflect.ValueOf(modulate)
	goArguments[4] = reflect.ValueOf(transpose)
	goArguments[5] = reflect.ValueOf(normalMap)
	goArguments[6] = reflect.ValueOf(clipUv)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_rect_region", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Texture) GetData() *Image {
	log.Println("Calling Texture.GetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_data", goArguments, "*Image")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Image)

	return returnValue

}

/*
   TextureImplementer is an interface for Texture objects.
*/
type TextureImplementer interface {
	Class
}

/*
   Texture Based 3x3 scale style. This stylebox performs a 3x3 scaling of a texture, where only the center cell is fully stretched. This allows for the easy creation of bordered styles.
*/
type StyleBoxTexture struct {
	StyleBox
}

func (o *StyleBoxTexture) baseClass() string {
	return "StyleBoxTexture"
}

/*

 */
func (o *StyleBoxTexture) SetTexture(texture *Resource) {
	log.Println("Calling StyleBoxTexture.SetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxTexture) GetTexture() *Resource {
	log.Println("Calling StyleBoxTexture.GetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture", goArguments, "*Resource")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Resource)

	return returnValue

}

/*

 */
func (o *StyleBoxTexture) SetNormalMap(normalMap *Resource) {
	log.Println("Calling StyleBoxTexture.SetNormalMap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(normalMap)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_normal_map", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxTexture) GetNormalMap() *Resource {
	log.Println("Calling StyleBoxTexture.GetNormalMap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_normal_map", goArguments, "*Resource")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Resource)

	return returnValue

}

/*

 */
func (o *StyleBoxTexture) SetMarginSize(margin int64, size float64) {
	log.Println("Calling StyleBoxTexture.SetMarginSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_margin_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxTexture) GetMarginSize(margin int64) float64 {
	log.Println("Calling StyleBoxTexture.GetMarginSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_margin_size", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *StyleBoxTexture) SetExpandMarginSize(margin int64, size float64) {
	log.Println("Calling StyleBoxTexture.SetExpandMarginSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_expand_margin_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxTexture) SetExpandMarginAll(size float64) {
	log.Println("Calling StyleBoxTexture.SetExpandMarginAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_expand_margin_all", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxTexture) SetExpandMarginIndividual(sizeLeft float64, sizeTop float64, sizeRight float64, sizeBottom float64) {
	log.Println("Calling StyleBoxTexture.SetExpandMarginIndividual()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(sizeLeft)
	goArguments[1] = reflect.ValueOf(sizeTop)
	goArguments[2] = reflect.ValueOf(sizeRight)
	goArguments[3] = reflect.ValueOf(sizeBottom)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_expand_margin_individual", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxTexture) GetExpandMarginSize(margin int64) float64 {
	log.Println("Calling StyleBoxTexture.GetExpandMarginSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_expand_margin_size", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *StyleBoxTexture) SetRegionRect(region *Rect2) {
	log.Println("Calling StyleBoxTexture.SetRegionRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(region)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_region_rect", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxTexture) GetRegionRect() *Rect2 {
	log.Println("Calling StyleBoxTexture.GetRegionRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_region_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*

 */
func (o *StyleBoxTexture) SetDrawCenter(enable bool) {
	log.Println("Calling StyleBoxTexture.SetDrawCenter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_draw_center", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxTexture) IsDrawCenterEnabled() bool {
	log.Println("Calling StyleBoxTexture.IsDrawCenterEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_draw_center_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *StyleBoxTexture) SetModulate(color *Color) {
	log.Println("Calling StyleBoxTexture.SetModulate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_modulate", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxTexture) GetModulate() *Color {
	log.Println("Calling StyleBoxTexture.GetModulate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_modulate", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *StyleBoxTexture) SetHAxisStretchMode(mode int64) {
	log.Println("Calling StyleBoxTexture.SetHAxisStretchMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_h_axis_stretch_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxTexture) GetHAxisStretchMode() int64 {
	log.Println("Calling StyleBoxTexture.GetHAxisStretchMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_h_axis_stretch_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *StyleBoxTexture) SetVAxisStretchMode(mode int64) {
	log.Println("Calling StyleBoxTexture.SetVAxisStretchMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_v_axis_stretch_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxTexture) GetVAxisStretchMode() int64 {
	log.Println("Calling StyleBoxTexture.GetVAxisStretchMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_v_axis_stretch_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   StyleBoxTextureImplementer is an interface for StyleBoxTexture objects.
*/
type StyleBoxTextureImplementer interface {
	Class
}

/*
   Panel is a [Control] that displays an opaque background. It's commonly used as a parent and container for other types of [Control] nodes.
*/
type Panel struct {
	Control
}

func (o *Panel) baseClass() string {
	return "Panel"
}

/*
   PanelImplementer is an interface for Panel objects.
*/
type PanelImplementer interface {
	Class
}

/*
   Button is the standard themed button. It can contain text and an icon, and will display them according to the current [Theme].
*/
type Button struct {
	BaseButton
}

func (o *Button) baseClass() string {
	return "Button"
}

/*

 */
func (o *Button) SetText(text string) {
	log.Println("Calling Button.SetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_text", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Button) GetText() string {
	log.Println("Calling Button.GetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *Button) SetButtonIcon(texture *Texture) {
	log.Println("Calling Button.SetButtonIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_button_icon", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Button) GetButtonIcon() *Texture {
	log.Println("Calling Button.GetButtonIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_button_icon", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *Button) SetFlat(enabled bool) {
	log.Println("Calling Button.SetFlat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flat", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Button) SetClipText(enabled bool) {
	log.Println("Calling Button.SetClipText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_clip_text", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Button) GetClipText() bool {
	log.Println("Calling Button.GetClipText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_clip_text", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Button) SetTextAlign(align int64) {
	log.Println("Calling Button.SetTextAlign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(align)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_text_align", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Button) GetTextAlign() int64 {
	log.Println("Calling Button.GetTextAlign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_text_align", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Button) IsFlat() bool {
	log.Println("Calling Button.IsFlat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_flat", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   ButtonImplementer is an interface for Button objects.
*/
type ButtonImplementer interface {
	Class
}

/*
   StyleBox is [Resource] that provides an abstract base class for drawing stylized boxes for the UI. StyleBoxes are used for drawing the styles of buttons, line edit backgrounds, tree backgrounds, etc. and also for testing a transparency mask for pointer signals. If mask test fails on a StyleBox assigned as mask to a control, clicks and motion signals will go through it to the one below.
*/
type StyleBox struct {
	Resource
}

func (o *StyleBox) baseClass() string {
	return "StyleBox"
}

/*
   Test a position in a rectangle, return whether it passes the mask test.
*/
func (o *StyleBox) TestMask(point *Vector2, rect *Rect2) bool {
	log.Println("Calling StyleBox.TestMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(point)
	goArguments[1] = reflect.ValueOf(rect)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "test_mask", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the default offset "offset" of the margin "margin" (see MARGIN_* enum) for a StyleBox, Controls that draw styleboxes with context inside need to know the margin, so the border of the stylebox is not occluded.
*/
func (o *StyleBox) SetDefaultMargin(margin int64, offset float64) {
	log.Println("Calling StyleBox.SetDefaultMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_default_margin", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the default offset of the margin "margin" (see MARGIN_* enum) of a StyleBox, Controls that draw styleboxes with context inside need to know the margin, so the border of the stylebox is not occluded.
*/
func (o *StyleBox) GetDefaultMargin(margin int64) float64 {
	log.Println("Calling StyleBox.GetDefaultMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_default_margin", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the offset of margin "margin" (see MARGIN_* enum).
*/
func (o *StyleBox) GetMargin(margin int64) float64 {
	log.Println("Calling StyleBox.GetMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_margin", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the minimum size that this stylebox can be shrunk to.
*/
func (o *StyleBox) GetMinimumSize() *Vector2 {
	log.Println("Calling StyleBox.GetMinimumSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_minimum_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *StyleBox) GetCenterSize() *Vector2 {
	log.Println("Calling StyleBox.GetCenterSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_center_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the "offset" of a stylebox, this is a helper function, like writing [code]Vector2(style.get_margin(MARGIN_LEFT), style.get_margin(MARGIN_TOP))[/code].
*/
func (o *StyleBox) GetOffset() *Vector2 {
	log.Println("Calling StyleBox.GetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *StyleBox) Draw(canvasItem *RID, rect *Rect2) {
	log.Println("Calling StyleBox.Draw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(canvasItem)
	goArguments[1] = reflect.ValueOf(rect)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw", goArguments, "")

	log.Println("Got return value!")

}

/*
   StyleBoxImplementer is an interface for StyleBox objects.
*/
type StyleBoxImplementer interface {
	Class
}

/*
   This kind of buttons are primarily used when the interaction with the button causes a context change (like linking to a web page).
*/
type LinkButton struct {
	BaseButton
}

func (o *LinkButton) baseClass() string {
	return "LinkButton"
}

/*
   Sets the text of the button.
*/
func (o *LinkButton) SetText(text string) {
	log.Println("Calling LinkButton.SetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_text", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the text of the button.
*/
func (o *LinkButton) GetText() string {
	log.Println("Calling LinkButton.GetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Sets the underline mode for this button, the argument must be one of the [LinkButton] constants (see constants section).
*/
func (o *LinkButton) SetUnderlineMode(underlineMode int64) {
	log.Println("Calling LinkButton.SetUnderlineMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(underlineMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_underline_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the underline mode for this button.
*/
func (o *LinkButton) GetUnderlineMode() int64 {
	log.Println("Calling LinkButton.GetUnderlineMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_underline_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   LinkButtonImplementer is an interface for LinkButton objects.
*/
type LinkButtonImplementer interface {
	Class
}

/*
   Encapsulates a [ColorPicker] making it accesible by pressing a button, pressing the button will toggle the [ColorPicker] visibility
*/
type ColorPickerButton struct {
	Button
}

func (o *ColorPickerButton) baseClass() string {
	return "ColorPickerButton"
}

/*
   Set new color to ColorRect. [codeblock] var cr = get_node("colorrect_node") cr.set_frame_color(Color(1, 0, 0, 1)) # Set color rect node to red [/codeblock]
*/
func (o *ColorPickerButton) SetPickColor(color *Color) {
	log.Println("Calling ColorPickerButton.SetPickColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pick_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ColorPickerButton) GetPickColor() *Color {
	log.Println("Calling ColorPickerButton.GetPickColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pick_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *ColorPickerButton) GetPicker() *ColorPicker {
	log.Println("Calling ColorPickerButton.GetPicker()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_picker", goArguments, "*ColorPicker")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*ColorPicker)

	return returnValue

}

/*
   See [method ColorPicker.set_edit_alpha]
*/
func (o *ColorPickerButton) SetEditAlpha(show bool) {
	log.Println("Calling ColorPickerButton.SetEditAlpha()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(show)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_edit_alpha", goArguments, "")

	log.Println("Got return value!")

}

/*
   See [method ColorPicker.is_edit_alpha]
*/
func (o *ColorPickerButton) IsEditingAlpha() bool {
	log.Println("Calling ColorPickerButton.IsEditingAlpha()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_editing_alpha", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *ColorPickerButton) X_ColorChanged(arg0 *Color) {
	log.Println("Calling ColorPickerButton.X_ColorChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_color_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   ColorPickerButtonImplementer is an interface for ColorPickerButton objects.
*/
type ColorPickerButtonImplementer interface {
	Class
}

/*
   Empty stylebox (really does not display anything).
*/
type StyleBoxEmpty struct {
	StyleBox
}

func (o *StyleBoxEmpty) baseClass() string {
	return "StyleBoxEmpty"
}

/*
   StyleBoxEmptyImplementer is an interface for StyleBoxEmpty objects.
*/
type StyleBoxEmptyImplementer interface {
	Class
}

/*
   This is a helper class to generate a flat [Button] (see [method Button.set_flat]), creating a ToolButton is equivalent to: [codeblock] var btn = Button.new() btn.set_flat(true) [/codeblock]
*/
type ToolButton struct {
	Button
}

func (o *ToolButton) baseClass() string {
	return "ToolButton"
}

/*
   ToolButtonImplementer is an interface for ToolButton objects.
*/
type ToolButtonImplementer interface {
	Class
}

/*
   OptionButton is a type button that provides a selectable list of items when pressed. The item selected becomes the "current" item and is displayed as the button text.
*/
type OptionButton struct {
	Button
}

func (o *OptionButton) baseClass() string {
	return "OptionButton"
}

/*
   Undocumented
*/
func (o *OptionButton) X_Selected(arg0 int64) {
	log.Println("Calling OptionButton.X_Selected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_selected", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add an item, with text "label" and (optionally) id. If no "id" is passed, "id" becomes the item index. New items are appended at the end.
*/
func (o *OptionButton) AddItem(label string, id int64) {
	log.Println("Calling OptionButton.AddItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(label)
	goArguments[1] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_item", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add an item, with a "texture" icon, text "label" and (optionally) id. If no "id" is passed, "id" becomes the item index. New items are appended at the end.
*/
func (o *OptionButton) AddIconItem(texture *Texture, label string, id int64) {
	log.Println("Calling OptionButton.AddIconItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(texture)
	goArguments[1] = reflect.ValueOf(label)
	goArguments[2] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_icon_item", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the text of an item at index "idx".
*/
func (o *OptionButton) SetItemText(idx int64, text string) {
	log.Println("Calling OptionButton.SetItemText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_text", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the icon of an item at index "idx".
*/
func (o *OptionButton) SetItemIcon(idx int64, texture *Texture) {
	log.Println("Calling OptionButton.SetItemIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_icon", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *OptionButton) SetItemDisabled(idx int64, disabled bool) {
	log.Println("Calling OptionButton.SetItemDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(disabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the ID of an item at index "idx".
*/
func (o *OptionButton) SetItemId(idx int64, id int64) {
	log.Println("Calling OptionButton.SetItemId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_id", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *OptionButton) SetItemMetadata(idx int64, metadata *Variant) {
	log.Println("Calling OptionButton.SetItemMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(metadata)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_metadata", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the text of the item at index "idx".
*/
func (o *OptionButton) GetItemText(idx int64) string {
	log.Println("Calling OptionButton.GetItemText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the icon of the item at index "idx".
*/
func (o *OptionButton) GetItemIcon(idx int64) *Texture {
	log.Println("Calling OptionButton.GetItemIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_icon", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   Return the ID of the item at index "idx".
*/
func (o *OptionButton) GetItemId(idx int64) int64 {
	log.Println("Calling OptionButton.GetItemId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *OptionButton) GetItemMetadata(idx int64) *Variant {
	log.Println("Calling OptionButton.GetItemMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_metadata", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *OptionButton) IsItemDisabled(idx int64) bool {
	log.Println("Calling OptionButton.IsItemDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_item_disabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return the amount of items in the OptionButton.
*/
func (o *OptionButton) GetItemCount() int64 {
	log.Println("Calling OptionButton.GetItemCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Add a separator to the list of items. Separators help to group items. Separator also takes up an index and is appended at the end.
*/
func (o *OptionButton) AddSeparator() {
	log.Println("Calling OptionButton.AddSeparator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_separator", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear all the items in the [OptionButton].
*/
func (o *OptionButton) Clear() {
	log.Println("Calling OptionButton.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Select an item by index and make it the current item.
*/
func (o *OptionButton) Select(idx int64) {
	log.Println("Calling OptionButton.Select()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "select", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current item index
*/
func (o *OptionButton) GetSelected() int64 {
	log.Println("Calling OptionButton.GetSelected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_selected", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *OptionButton) GetSelectedId() int64 {
	log.Println("Calling OptionButton.GetSelectedId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_selected_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *OptionButton) GetSelectedMetadata() *Variant {
	log.Println("Calling OptionButton.GetSelectedMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_selected_metadata", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *OptionButton) RemoveItem(idx int64) {
	log.Println("Calling OptionButton.RemoveItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_item", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *OptionButton) X_SelectInt(arg0 int64) {
	log.Println("Calling OptionButton.X_SelectInt()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_select_int", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *OptionButton) X_SetItems(arg0 *Array) {
	log.Println("Calling OptionButton.X_SetItems()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_items", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *OptionButton) X_GetItems() *Array {
	log.Println("Calling OptionButton.X_GetItems()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_items", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   OptionButtonImplementer is an interface for OptionButton objects.
*/
type OptionButtonImplementer interface {
	Class
}

/*
   Special button that brings up a [PopupMenu] when clicked. That's pretty much all it does, as it's just a helper class when building GUIs.
*/
type MenuButton struct {
	Button
}

func (o *MenuButton) baseClass() string {
	return "MenuButton"
}

/*
   Return the [PopupMenu] contained in this button.
*/
func (o *MenuButton) GetPopup() *PopupMenu {
	log.Println("Calling MenuButton.GetPopup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_popup", goArguments, "*PopupMenu")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PopupMenu)

	return returnValue

}

/*
   Undocumented
*/
func (o *MenuButton) X_UnhandledKeyInput(arg0 *InputEvent) {
	log.Println("Calling MenuButton.X_UnhandledKeyInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_unhandled_key_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *MenuButton) X_SetItems(arg0 *Array) {
	log.Println("Calling MenuButton.X_SetItems()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_items", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *MenuButton) X_GetItems() *Array {
	log.Println("Calling MenuButton.X_GetItems()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_items", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   MenuButtonImplementer is an interface for MenuButton objects.
*/
type MenuButtonImplementer interface {
	Class
}

/*
   Group of [Button]. All direct and indirect children buttons become radios. Only one allows being pressed.
*/
type ButtonGroup struct {
	Resource
}

func (o *ButtonGroup) baseClass() string {
	return "ButtonGroup"
}

/*
   Return the pressed button.
*/
func (o *ButtonGroup) GetPressedButton() *BaseButton {
	log.Println("Calling ButtonGroup.GetPressedButton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pressed_button", goArguments, "*BaseButton")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*BaseButton)

	return returnValue

}

/*
   ButtonGroupImplementer is an interface for ButtonGroup objects.
*/
type ButtonGroupImplementer interface {
	Class
}

/*
   A checkbox allows the user to make a binary choice (choosing only one of two posible options), for example Answer 'yes' or 'no'.
*/
type CheckBox struct {
	Button
}

func (o *CheckBox) baseClass() string {
	return "CheckBox"
}

/*
   CheckBoxImplementer is an interface for CheckBox objects.
*/
type CheckBoxImplementer interface {
	Class
}

/*
   CheckButton is a toggle button displayed as a check field.
*/
type CheckButton struct {
	Button
}

func (o *CheckButton) baseClass() string {
	return "CheckButton"
}

/*
   CheckButtonImplementer is an interface for CheckButton objects.
*/
type CheckButtonImplementer interface {
	Class
}

/*
   Label displays plain text on the screen. It gives you control over the horizontal and vertical alignment, and can wrap the text inside the node's bounding rectangle. It doesn't support bold, italics or other formatting. For that, use [RichTextLabel] instead.
*/
type Label struct {
	Control
}

func (o *Label) baseClass() string {
	return "Label"
}

/*
   Sets the alignment mode to any of the ALIGN_* enumeration values.
*/
func (o *Label) SetAlign(align int64) {
	log.Println("Calling Label.SetAlign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(align)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_align", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the alignment mode (any of the ALIGN_* enumeration values).
*/
func (o *Label) GetAlign() int64 {
	log.Println("Calling Label.GetAlign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_align", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Sets the vertical alignment mode to any of the VALIGN_* enumeration values.
*/
func (o *Label) SetValign(valign int64) {
	log.Println("Calling Label.SetValign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(valign)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_valign", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the vertical alignment mode (any of the VALIGN_* enumeration values).
*/
func (o *Label) GetValign() int64 {
	log.Println("Calling Label.GetValign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_valign", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the label text. Text can contain newlines.
*/
func (o *Label) SetText(text string) {
	log.Println("Calling Label.SetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_text", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the label text. Text can contain newlines.
*/
func (o *Label) GetText() string {
	log.Println("Calling Label.GetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Set [i]autowrap[/i] mode. When enabled, autowrap will fit text to the control width, breaking sentences when they exceed the available horizontal space. When disabled, the label minimum width becomes the width of the longest row, and the minimum height large enough to fit all rows.
*/
func (o *Label) SetAutowrap(enable bool) {
	log.Println("Calling Label.SetAutowrap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_autowrap", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the state of the [i]autowrap[/i] mode (see [method set_autowrap]).
*/
func (o *Label) HasAutowrap() bool {
	log.Println("Calling Label.HasAutowrap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_autowrap", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Cuts off the rest of the text if it is too wide.
*/
func (o *Label) SetClipText(enable bool) {
	log.Println("Calling Label.SetClipText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_clip_text", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return [code]true[/code] if text would be cut off if it is too wide.
*/
func (o *Label) IsClippingText() bool {
	log.Println("Calling Label.IsClippingText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_clipping_text", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Display text in all capitals.
*/
func (o *Label) SetUppercase(enable bool) {
	log.Println("Calling Label.SetUppercase()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_uppercase", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return [code]true[/code] if text is displayed in all capitals.
*/
func (o *Label) IsUppercase() bool {
	log.Println("Calling Label.IsUppercase()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_uppercase", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns the font size in pixels.
*/
func (o *Label) GetLineHeight() int64 {
	log.Println("Calling Label.GetLineHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_line_height", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the amount of lines of text the Label has.
*/
func (o *Label) GetLineCount() int64 {
	log.Println("Calling Label.GetLineCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_line_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Label) GetVisibleLineCount() int64 {
	log.Println("Calling Label.GetVisibleLineCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_visible_line_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the total length of the text.
*/
func (o *Label) GetTotalCharacterCount() int64 {
	log.Println("Calling Label.GetTotalCharacterCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_total_character_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Restricts the number of characters to display. Set to -1 to disable.
*/
func (o *Label) SetVisibleCharacters(amount int64) {
	log.Println("Calling Label.SetVisibleCharacters()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_visible_characters", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the restricted number of characters to display. Returns -1 if unrestricted.
*/
func (o *Label) GetVisibleCharacters() int64 {
	log.Println("Calling Label.GetVisibleCharacters()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_visible_characters", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Restricts the number of characters to display (as a percentage of the total text).
*/
func (o *Label) SetPercentVisible(percentVisible float64) {
	log.Println("Calling Label.SetPercentVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(percentVisible)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_percent_visible", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the restricted number of characters to display (as a percentage of the total text).
*/
func (o *Label) GetPercentVisible() float64 {
	log.Println("Calling Label.GetPercentVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_percent_visible", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Sets the number of lines to skip before displaying. Useful for scrolling text.
*/
func (o *Label) SetLinesSkipped(linesSkipped int64) {
	log.Println("Calling Label.SetLinesSkipped()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(linesSkipped)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_lines_skipped", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the the number of lines to skipped before displaying.
*/
func (o *Label) GetLinesSkipped() int64 {
	log.Println("Calling Label.GetLinesSkipped()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_lines_skipped", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Restricts the number of lines to display. Set to -1 to disable.
*/
func (o *Label) SetMaxLinesVisible(linesVisible int64) {
	log.Println("Calling Label.SetMaxLinesVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(linesVisible)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_lines_visible", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the restricted number of lines to display. Returns -1 if unrestricted.
*/
func (o *Label) GetMaxLinesVisible() int64 {
	log.Println("Calling Label.GetMaxLinesVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_max_lines_visible", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   LabelImplementer is an interface for Label objects.
*/
type LabelImplementer interface {
	Class
}

/*
   General purpose progress bar. Shows fill percentage from right to left.
*/
type ProgressBar struct {
	Range
}

func (o *ProgressBar) baseClass() string {
	return "ProgressBar"
}

/*

 */
func (o *ProgressBar) SetPercentVisible(visible bool) {
	log.Println("Calling ProgressBar.SetPercentVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(visible)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_percent_visible", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProgressBar) IsPercentVisible() bool {
	log.Println("Calling ProgressBar.IsPercentVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_percent_visible", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   ProgressBarImplementer is an interface for ProgressBar objects.
*/
type ProgressBarImplementer interface {
	Class
}

/*
   LineEdit provides a single line string editor, used for text fields.
*/
type LineEdit struct {
	Control
}

func (o *LineEdit) baseClass() string {
	return "LineEdit"
}

/*
   Undocumented
*/
func (o *LineEdit) X_ToggleDrawCaret() {
	log.Println("Calling LineEdit.X_ToggleDrawCaret()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_toggle_draw_caret", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *LineEdit) X_EditorSettingsChanged() {
	log.Println("Calling LineEdit.X_EditorSettingsChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_editor_settings_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set text alignment of the [LineEdit].
*/
func (o *LineEdit) SetAlign(align int64) {
	log.Println("Calling LineEdit.SetAlign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(align)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_align", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the align mode of the [LineEdit].
*/
func (o *LineEdit) GetAlign() int64 {
	log.Println("Calling LineEdit.GetAlign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_align", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *LineEdit) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling LineEdit.X_GuiInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_gui_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear the [LineEdit] text.
*/
func (o *LineEdit) Clear() {
	log.Println("Calling LineEdit.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Select the whole string.
*/
func (o *LineEdit) SelectAll() {
	log.Println("Calling LineEdit.SelectAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "select_all", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the text in the [LineEdit], clearing the existing one and the selection.
*/
func (o *LineEdit) SetText(text string) {
	log.Println("Calling LineEdit.SetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_text", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the text in the [LineEdit].
*/
func (o *LineEdit) GetText() string {
	log.Println("Calling LineEdit.GetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Set the placeholder text.
*/
func (o *LineEdit) SetPlaceholder(text string) {
	log.Println("Calling LineEdit.SetPlaceholder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_placeholder", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the placeholder text.
*/
func (o *LineEdit) GetPlaceholder() string {
	log.Println("Calling LineEdit.GetPlaceholder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_placeholder", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Set transparency of the placeholder text.
*/
func (o *LineEdit) SetPlaceholderAlpha(alpha float64) {
	log.Println("Calling LineEdit.SetPlaceholderAlpha()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(alpha)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_placeholder_alpha", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return transparency of the placeholder text.
*/
func (o *LineEdit) GetPlaceholderAlpha() float64 {
	log.Println("Calling LineEdit.GetPlaceholderAlpha()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_placeholder_alpha", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the cursor position inside the [LineEdit], causing it to scroll if needed.
*/
func (o *LineEdit) SetCursorPosition(position int64) {
	log.Println("Calling LineEdit.SetCursorPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cursor_position", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the cursor position inside the [LineEdit].
*/
func (o *LineEdit) GetCursorPosition() int64 {
	log.Println("Calling LineEdit.GetCursorPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cursor_position", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *LineEdit) SetExpandToTextLength(enabled bool) {
	log.Println("Calling LineEdit.SetExpandToTextLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_expand_to_text_length", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *LineEdit) GetExpandToTextLength() bool {
	log.Println("Calling LineEdit.GetExpandToTextLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_expand_to_text_length", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the line edit caret to blink.
*/
func (o *LineEdit) CursorSetBlinkEnabled(enabled bool) {
	log.Println("Calling LineEdit.CursorSetBlinkEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "cursor_set_blink_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Gets whether the line edit caret is blinking.
*/
func (o *LineEdit) CursorGetBlinkEnabled() bool {
	log.Println("Calling LineEdit.CursorGetBlinkEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "cursor_get_blink_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the line edit caret blink speed. Cannot be less then or equal to 0.
*/
func (o *LineEdit) CursorSetBlinkSpeed(blinkSpeed float64) {
	log.Println("Calling LineEdit.CursorSetBlinkSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(blinkSpeed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "cursor_set_blink_speed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Gets the line edit caret blink speed.
*/
func (o *LineEdit) CursorGetBlinkSpeed() float64 {
	log.Println("Calling LineEdit.CursorGetBlinkSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "cursor_get_blink_speed", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the maximum amount of characters the [LineEdit] can edit, and cropping existing text in case it exceeds that limit. Setting 0 removes the limit.
*/
func (o *LineEdit) SetMaxLength(chars int64) {
	log.Println("Calling LineEdit.SetMaxLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(chars)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_length", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the maximum amount of characters the [LineEdit] can edit. If 0 is returned, no limit exists.
*/
func (o *LineEdit) GetMaxLength() int64 {
	log.Println("Calling LineEdit.GetMaxLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_max_length", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Append text at cursor, scrolling the [LineEdit] when needed.
*/
func (o *LineEdit) AppendAtCursor(text string) {
	log.Println("Calling LineEdit.AppendAtCursor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "append_at_cursor", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the [i]editable[/i] status of the [LineEdit]. When disabled, existing text can't be modified and new text can't be added.
*/
func (o *LineEdit) SetEditable(enabled bool) {
	log.Println("Calling LineEdit.SetEditable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_editable", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the [i]editable[/i] status of the [LineEdit] (see [method set_editable]).
*/
func (o *LineEdit) IsEditable() bool {
	log.Println("Calling LineEdit.IsEditable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_editable", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the [i]secret[/i] status of the [LineEdit]. When enabled, every character is displayed as "*".
*/
func (o *LineEdit) SetSecret(enabled bool) {
	log.Println("Calling LineEdit.SetSecret()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_secret", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the [i]secret[/i] status of the [LineEdit] (see [method set_secret]).
*/
func (o *LineEdit) IsSecret() bool {
	log.Println("Calling LineEdit.IsSecret()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_secret", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Select the text inside [LineEdit] by the given character positions. [code]from[/code] is default to the beginning. [code]to[/code] is default to the end. [codeblock] select() # select all select(5) # select from the fifth character to the end. select(2, 5) # select from the second to the fifth character. [/codeblock]
*/
func (o *LineEdit) Select(from int64, to int64) {
	log.Println("Calling LineEdit.Select()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(to)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "select", goArguments, "")

	log.Println("Got return value!")

}

/*
   Execute a given action as defined in the MENU_* enum.
*/
func (o *LineEdit) MenuOption(option int64) {
	log.Println("Calling LineEdit.MenuOption()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(option)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "menu_option", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the [PopupMenu] of this [LineEdit].
*/
func (o *LineEdit) GetMenu() *PopupMenu {
	log.Println("Calling LineEdit.GetMenu()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_menu", goArguments, "*PopupMenu")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PopupMenu)

	return returnValue

}

/*
   LineEditImplementer is an interface for LineEdit objects.
*/
type LineEditImplementer interface {
	Class
}

/*
   TextEdit is meant for editing large, multiline text. It also has facilities for editing code, such as syntax highlighting support and multiple levels of undo/redo.
*/
type TextEdit struct {
	Control
}

func (o *TextEdit) baseClass() string {
	return "TextEdit"
}

/*
   Undocumented
*/
func (o *TextEdit) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling TextEdit.X_GuiInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_gui_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *TextEdit) X_ScrollMoved(arg0 float64) {
	log.Println("Calling TextEdit.X_ScrollMoved()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_scroll_moved", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *TextEdit) X_CursorChangedEmit() {
	log.Println("Calling TextEdit.X_CursorChangedEmit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_cursor_changed_emit", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *TextEdit) X_TextChangedEmit() {
	log.Println("Calling TextEdit.X_TextChangedEmit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_text_changed_emit", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *TextEdit) X_PushCurrentOp() {
	log.Println("Calling TextEdit.X_PushCurrentOp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_push_current_op", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *TextEdit) X_ClickSelectionHeld() {
	log.Println("Calling TextEdit.X_ClickSelectionHeld()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_click_selection_held", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *TextEdit) X_ToggleDrawCaret() {
	log.Println("Calling TextEdit.X_ToggleDrawCaret()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_toggle_draw_caret", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *TextEdit) X_VScrollInput() {
	log.Println("Calling TextEdit.X_VScrollInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_v_scroll_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the entire text.
*/
func (o *TextEdit) SetText(text string) {
	log.Println("Calling TextEdit.SetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_text", goArguments, "")

	log.Println("Got return value!")

}

/*
   Insert a given text at the cursor position.
*/
func (o *TextEdit) InsertTextAtCursor(text string) {
	log.Println("Calling TextEdit.InsertTextAtCursor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "insert_text_at_cursor", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the amount of total lines in the text.
*/
func (o *TextEdit) GetLineCount() int64 {
	log.Println("Calling TextEdit.GetLineCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_line_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the whole text.
*/
func (o *TextEdit) GetText() string {
	log.Println("Calling TextEdit.GetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the text of a specific line.
*/
func (o *TextEdit) GetLine(line int64) string {
	log.Println("Calling TextEdit.GetLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(line)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_line", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *TextEdit) CursorSetColumn(column int64, adjustViewport bool) {
	log.Println("Calling TextEdit.CursorSetColumn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(adjustViewport)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "cursor_set_column", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextEdit) CursorSetLine(line int64, adjustViewport bool) {
	log.Println("Calling TextEdit.CursorSetLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(line)
	goArguments[1] = reflect.ValueOf(adjustViewport)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "cursor_set_line", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the column the editing cursor is at.
*/
func (o *TextEdit) CursorGetColumn() int64 {
	log.Println("Calling TextEdit.CursorGetColumn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "cursor_get_column", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the line the editing cursor is at.
*/
func (o *TextEdit) CursorGetLine() int64 {
	log.Println("Calling TextEdit.CursorGetLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "cursor_get_line", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the text editor caret to blink.
*/
func (o *TextEdit) CursorSetBlinkEnabled(enable bool) {
	log.Println("Calling TextEdit.CursorSetBlinkEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "cursor_set_blink_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Gets whether the text editor caret is blinking.
*/
func (o *TextEdit) CursorGetBlinkEnabled() bool {
	log.Println("Calling TextEdit.CursorGetBlinkEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "cursor_get_blink_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the text editor caret blink speed. Cannot be less then or equal to 0.
*/
func (o *TextEdit) CursorSetBlinkSpeed(blinkSpeed float64) {
	log.Println("Calling TextEdit.CursorSetBlinkSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(blinkSpeed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "cursor_set_blink_speed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Gets the text editor caret blink speed.
*/
func (o *TextEdit) CursorGetBlinkSpeed() float64 {
	log.Println("Calling TextEdit.CursorGetBlinkSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "cursor_get_blink_speed", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the text editor caret to block mode.
*/
func (o *TextEdit) CursorSetBlockMode(enable bool) {
	log.Println("Calling TextEdit.CursorSetBlockMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "cursor_set_block_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Gets whether the text editor caret is in block mode.
*/
func (o *TextEdit) CursorIsBlockMode() bool {
	log.Println("Calling TextEdit.CursorIsBlockMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "cursor_is_block_mode", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the text editor as read-only. Text can be displayed but not edited.
*/
func (o *TextEdit) SetReadonly(enable bool) {
	log.Println("Calling TextEdit.SetReadonly()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_readonly", goArguments, "")

	log.Println("Got return value!")

}

/*
   Enable text wrapping when it goes beyond he edge of what is visible.
*/
func (o *TextEdit) SetWrap(enable bool) {
	log.Println("Calling TextEdit.SetWrap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_wrap", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the maximum amount of characters editable.
*/
func (o *TextEdit) SetMaxChars(amount int64) {
	log.Println("Calling TextEdit.SetMaxChars()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_chars", goArguments, "")

	log.Println("Got return value!")

}

/*
   Cut the current selection.
*/
func (o *TextEdit) Cut() {
	log.Println("Calling TextEdit.Cut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "cut", goArguments, "")

	log.Println("Got return value!")

}

/*
   Copy the current selection.
*/
func (o *TextEdit) Copy() {
	log.Println("Calling TextEdit.Copy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "copy", goArguments, "")

	log.Println("Got return value!")

}

/*
   Paste the current selection.
*/
func (o *TextEdit) Paste() {
	log.Println("Calling TextEdit.Paste()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "paste", goArguments, "")

	log.Println("Got return value!")

}

/*
   Select all the text.
*/
func (o *TextEdit) SelectAll() {
	log.Println("Calling TextEdit.SelectAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "select_all", goArguments, "")

	log.Println("Got return value!")

}

/*
   Perform selection, from line/column to line/column.
*/
func (o *TextEdit) Select(fromLine int64, fromColumn int64, toLine int64, toColumn int64) {
	log.Println("Calling TextEdit.Select()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(fromLine)
	goArguments[1] = reflect.ValueOf(fromColumn)
	goArguments[2] = reflect.ValueOf(toLine)
	goArguments[3] = reflect.ValueOf(toColumn)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "select", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if the selection is active.
*/
func (o *TextEdit) IsSelectionActive() bool {
	log.Println("Calling TextEdit.IsSelectionActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_selection_active", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return the selection begin line.
*/
func (o *TextEdit) GetSelectionFromLine() int64 {
	log.Println("Calling TextEdit.GetSelectionFromLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_selection_from_line", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the selection begin column.
*/
func (o *TextEdit) GetSelectionFromColumn() int64 {
	log.Println("Calling TextEdit.GetSelectionFromColumn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_selection_from_column", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the selection end line.
*/
func (o *TextEdit) GetSelectionToLine() int64 {
	log.Println("Calling TextEdit.GetSelectionToLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_selection_to_line", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the selection end column.
*/
func (o *TextEdit) GetSelectionToColumn() int64 {
	log.Println("Calling TextEdit.GetSelectionToColumn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_selection_to_column", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the text inside the selection.
*/
func (o *TextEdit) GetSelectionText() string {
	log.Println("Calling TextEdit.GetSelectionText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_selection_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *TextEdit) GetWordUnderCursor() string {
	log.Println("Calling TextEdit.GetWordUnderCursor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_word_under_cursor", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Perform a search inside the text. Search flags can be specified in the SEARCH_* enum.
*/
func (o *TextEdit) Search(key string, flags int64, fromLine int64, fromColumn int64) *PoolIntArray {
	log.Println("Calling TextEdit.Search()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(key)
	goArguments[1] = reflect.ValueOf(flags)
	goArguments[2] = reflect.ValueOf(fromLine)
	goArguments[3] = reflect.ValueOf(fromColumn)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "search", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*
   Perform undo operation.
*/
func (o *TextEdit) Undo() {
	log.Println("Calling TextEdit.Undo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "undo", goArguments, "")

	log.Println("Got return value!")

}

/*
   Perform redo operation.
*/
func (o *TextEdit) Redo() {
	log.Println("Calling TextEdit.Redo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "redo", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear the undo history.
*/
func (o *TextEdit) ClearUndoHistory() {
	log.Println("Calling TextEdit.ClearUndoHistory()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_undo_history", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set to enable showing line numbers.
*/
func (o *TextEdit) SetShowLineNumbers(enable bool) {
	log.Println("Calling TextEdit.SetShowLineNumbers()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_show_line_numbers", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns true if line numbers are enabled.
*/
func (o *TextEdit) IsShowLineNumbersEnabled() bool {
	log.Println("Calling TextEdit.IsShowLineNumbersEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_show_line_numbers_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set to enable highlighting all occurrences of the current selection.
*/
func (o *TextEdit) SetHighlightAllOccurrences(enable bool) {
	log.Println("Calling TextEdit.SetHighlightAllOccurrences()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_highlight_all_occurrences", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns true if highlight all occurrences is enabled.
*/
func (o *TextEdit) IsHighlightAllOccurrencesEnabled() bool {
	log.Println("Calling TextEdit.IsHighlightAllOccurrencesEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_highlight_all_occurrences_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set to enable the syntax coloring.
*/
func (o *TextEdit) SetSyntaxColoring(enable bool) {
	log.Println("Calling TextEdit.SetSyntaxColoring()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_syntax_coloring", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if the syntax coloring is enabled.
*/
func (o *TextEdit) IsSyntaxColoringEnabled() bool {
	log.Println("Calling TextEdit.IsSyntaxColoringEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_syntax_coloring_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *TextEdit) SetSmoothScrollEnable(enable bool) {
	log.Println("Calling TextEdit.SetSmoothScrollEnable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_smooth_scroll_enable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextEdit) IsSmoothScrollEnabled() bool {
	log.Println("Calling TextEdit.IsSmoothScrollEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_smooth_scroll_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *TextEdit) SetVScrollSpeed(speed float64) {
	log.Println("Calling TextEdit.SetVScrollSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(speed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_v_scroll_speed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextEdit) GetVScrollSpeed() float64 {
	log.Println("Calling TextEdit.GetVScrollSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_v_scroll_speed", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Add a keyword and its color.
*/
func (o *TextEdit) AddKeywordColor(keyword string, color *Color) {
	log.Println("Calling TextEdit.AddKeywordColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(keyword)
	goArguments[1] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_keyword_color", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add color region (given the delimiters) and its colors.
*/
func (o *TextEdit) AddColorRegion(beginKey string, endKey string, color *Color, lineOnly bool) {
	log.Println("Calling TextEdit.AddColorRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(beginKey)
	goArguments[1] = reflect.ValueOf(endKey)
	goArguments[2] = reflect.ValueOf(color)
	goArguments[3] = reflect.ValueOf(lineOnly)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_color_region", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear all the syntax coloring information.
*/
func (o *TextEdit) ClearColors() {
	log.Println("Calling TextEdit.ClearColors()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_colors", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextEdit) MenuOption(option int64) {
	log.Println("Calling TextEdit.MenuOption()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(option)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "menu_option", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextEdit) GetMenu() *PopupMenu {
	log.Println("Calling TextEdit.GetMenu()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_menu", goArguments, "*PopupMenu")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PopupMenu)

	return returnValue

}

/*
   TextEditImplementer is an interface for TextEdit objects.
*/
type TextEditImplementer interface {
	Class
}

/*
   Horizontal scroll bar. See [ScrollBar]. This one goes from left (min) to right (max).
*/
type HScrollBar struct {
	ScrollBar
}

func (o *HScrollBar) baseClass() string {
	return "HScrollBar"
}

/*
   HScrollBarImplementer is an interface for HScrollBar objects.
*/
type HScrollBarImplementer interface {
	Class
}

/*

 */
type VScrollBar struct {
	ScrollBar
}

func (o *VScrollBar) baseClass() string {
	return "VScrollBar"
}

/*
   VScrollBarImplementer is an interface for VScrollBar objects.
*/
type VScrollBarImplementer interface {
	Class
}

/*
   Horizontal slider. See [Slider]. This one goes from left (min) to right (max).
*/
type HSlider struct {
	Slider
}

func (o *HSlider) baseClass() string {
	return "HSlider"
}

/*
   HSliderImplementer is an interface for HSlider objects.
*/
type HSliderImplementer interface {
	Class
}

/*
   Vertical slider. See [Slider]. This one goes from left (min) to right (max).
*/
type VSlider struct {
	Slider
}

func (o *VSlider) baseClass() string {
	return "VSlider"
}

/*
   VSliderImplementer is an interface for VSlider objects.
*/
type VSliderImplementer interface {
	Class
}

/*
   GraphEdit manages the showing of GraphNodes it contains, as well as connections and disconnections between them. Signals are sent for each of these two events. Disconnection between GraphNodes slots is disabled by default. It is greatly advised to enable low processor usage mode (see [method OS.set_low_processor_usage_mode]) when using GraphEdits.
*/
type GraphEdit struct {
	Control
}

func (o *GraphEdit) baseClass() string {
	return "GraphEdit"
}

/*
   Create a connection between 'from_port' slot of 'from' GraphNode and 'to_port' slot of 'to' GraphNode. If the connection already exists, no connection is created.
*/
func (o *GraphEdit) ConnectNode(from string, fromPort int64, to string, toPort int64) int64 {
	log.Println("Calling GraphEdit.ConnectNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(fromPort)
	goArguments[2] = reflect.ValueOf(to)
	goArguments[3] = reflect.ValueOf(toPort)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "connect_node", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return true if the 'from_port' slot of 'from' GraphNode is connected to the 'to_port' slot of 'to' GraphNode.
*/
func (o *GraphEdit) IsNodeConnected(from string, fromPort int64, to string, toPort int64) bool {
	log.Println("Calling GraphEdit.IsNodeConnected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(fromPort)
	goArguments[2] = reflect.ValueOf(to)
	goArguments[3] = reflect.ValueOf(toPort)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_node_connected", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Remove the connection between 'from_port' slot of 'from' GraphNode and 'to_port' slot of 'to' GraphNode, if connection exists.
*/
func (o *GraphEdit) DisconnectNode(from string, fromPort int64, to string, toPort int64) {
	log.Println("Calling GraphEdit.DisconnectNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(fromPort)
	goArguments[2] = reflect.ValueOf(to)
	goArguments[3] = reflect.ValueOf(toPort)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "disconnect_node", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return an Array containing the list of connections. A connection consists in a structure of the form {from_slot: 0, from: "GraphNode name 0", to_slot: 1, to: "GraphNode name 1" }
*/
func (o *GraphEdit) GetConnectionList() *Array {
	log.Println("Calling GraphEdit.GetConnectionList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_list", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Return the scroll offset.
*/
func (o *GraphEdit) GetScrollOfs() *Vector2 {
	log.Println("Calling GraphEdit.GetScrollOfs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scroll_ofs", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *GraphEdit) SetScrollOfs(ofs *Vector2) {
	log.Println("Calling GraphEdit.SetScrollOfs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ofs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scroll_ofs", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the zoom value of the GraphEdit. Zoom value is between [0.01; 1.728].
*/
func (o *GraphEdit) SetZoom(pZoom float64) {
	log.Println("Calling GraphEdit.SetZoom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pZoom)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_zoom", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current zoom value.
*/
func (o *GraphEdit) GetZoom() float64 {
	log.Println("Calling GraphEdit.GetZoom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_zoom", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *GraphEdit) SetSnap(pixels int64) {
	log.Println("Calling GraphEdit.SetSnap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pixels)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_snap", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GraphEdit) GetSnap() int64 {
	log.Println("Calling GraphEdit.GetSnap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_snap", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *GraphEdit) SetUseSnap(enable bool) {
	log.Println("Calling GraphEdit.SetUseSnap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_snap", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GraphEdit) IsUsingSnap() bool {
	log.Println("Calling GraphEdit.IsUsingSnap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_using_snap", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Enable the disconnection of existing connections in the visual GraphEdit by left-clicking a connection and releasing into the void.
*/
func (o *GraphEdit) SetRightDisconnects(enable bool) {
	log.Println("Calling GraphEdit.SetRightDisconnects()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_right_disconnects", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true is the disconnection of connections is enable in the visual GraphEdit. False otherwise.
*/
func (o *GraphEdit) IsRightDisconnectsEnabled() bool {
	log.Println("Calling GraphEdit.IsRightDisconnectsEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_right_disconnects_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *GraphEdit) X_GraphNodeMoved(arg0 *Object) {
	log.Println("Calling GraphEdit.X_GraphNodeMoved()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_graph_node_moved", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *GraphEdit) X_GraphNodeRaised(arg0 *Object) {
	log.Println("Calling GraphEdit.X_GraphNodeRaised()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_graph_node_raised", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *GraphEdit) X_TopLayerInput(arg0 *InputEvent) {
	log.Println("Calling GraphEdit.X_TopLayerInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_top_layer_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *GraphEdit) X_TopLayerDraw() {
	log.Println("Calling GraphEdit.X_TopLayerDraw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_top_layer_draw", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *GraphEdit) X_ScrollMoved(arg0 float64) {
	log.Println("Calling GraphEdit.X_ScrollMoved()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_scroll_moved", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *GraphEdit) X_ZoomMinus() {
	log.Println("Calling GraphEdit.X_ZoomMinus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_zoom_minus", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *GraphEdit) X_ZoomReset() {
	log.Println("Calling GraphEdit.X_ZoomReset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_zoom_reset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *GraphEdit) X_ZoomPlus() {
	log.Println("Calling GraphEdit.X_ZoomPlus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_zoom_plus", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *GraphEdit) X_SnapToggled() {
	log.Println("Calling GraphEdit.X_SnapToggled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_snap_toggled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *GraphEdit) X_SnapValueChanged(arg0 float64) {
	log.Println("Calling GraphEdit.X_SnapValueChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_snap_value_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *GraphEdit) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling GraphEdit.X_GuiInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_gui_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *GraphEdit) X_UpdateScrollOffset() {
	log.Println("Calling GraphEdit.X_UpdateScrollOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_update_scroll_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *GraphEdit) X_ConnectionsLayerDraw() {
	log.Println("Calling GraphEdit.X_ConnectionsLayerDraw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_connections_layer_draw", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GraphEdit) SetSelected(node *Object) {
	log.Println("Calling GraphEdit.SetSelected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_selected", goArguments, "")

	log.Println("Got return value!")

}

/*
   GraphEditImplementer is an interface for GraphEdit objects.
*/
type GraphEditImplementer interface {
	Class
}

/*
   SpinBox is a numerical input text field. It allows entering integers and floats.
*/
type SpinBox struct {
	Range
}

func (o *SpinBox) baseClass() string {
	return "SpinBox"
}

/*
   Undocumented
*/
func (o *SpinBox) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling SpinBox.X_GuiInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_gui_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *SpinBox) X_TextEntered(arg0 string) {
	log.Println("Calling SpinBox.X_TextEntered()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_text_entered", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set a specific suffix.
*/
func (o *SpinBox) SetSuffix(suffix string) {
	log.Println("Calling SpinBox.SetSuffix()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(suffix)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_suffix", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the specific suffix.
*/
func (o *SpinBox) GetSuffix() string {
	log.Println("Calling SpinBox.GetSuffix()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_suffix", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Set a prefix.
*/
func (o *SpinBox) SetPrefix(prefix string) {
	log.Println("Calling SpinBox.SetPrefix()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(prefix)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_prefix", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpinBox) GetPrefix() string {
	log.Println("Calling SpinBox.GetPrefix()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_prefix", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Set whether the spinbox is editable.
*/
func (o *SpinBox) SetEditable(editable bool) {
	log.Println("Calling SpinBox.SetEditable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(editable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_editable", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return if the spinbox is editable.
*/
func (o *SpinBox) IsEditable() bool {
	log.Println("Calling SpinBox.IsEditable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_editable", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpinBox) X_LineEditFocusExit() {
	log.Println("Calling SpinBox.X_LineEditFocusExit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_line_edit_focus_exit", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpinBox) GetLineEdit() *LineEdit {
	log.Println("Calling SpinBox.GetLineEdit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_line_edit", goArguments, "*LineEdit")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*LineEdit)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpinBox) X_LineEditInput(arg0 *InputEvent) {
	log.Println("Calling SpinBox.X_LineEditInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_line_edit_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *SpinBox) X_RangeClickTimeout() {
	log.Println("Calling SpinBox.X_RangeClickTimeout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_range_click_timeout", goArguments, "")

	log.Println("Got return value!")

}

/*
   SpinBoxImplementer is an interface for SpinBox objects.
*/
type SpinBoxImplementer interface {
	Class
}

/*
   Windowdialog is the base class for all window-based dialogs. It's a by-default toplevel [Control] that draws a window decoration and allows motion and resizing.
*/
type WindowDialog struct {
	Popup
}

func (o *WindowDialog) baseClass() string {
	return "WindowDialog"
}

/*
   Undocumented
*/
func (o *WindowDialog) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling WindowDialog.X_GuiInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_gui_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the title of the window.
*/
func (o *WindowDialog) SetTitle(title string) {
	log.Println("Calling WindowDialog.SetTitle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(title)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_title", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the title of the window.
*/
func (o *WindowDialog) GetTitle() string {
	log.Println("Calling WindowDialog.GetTitle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_title", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *WindowDialog) SetResizable(resizable bool) {
	log.Println("Calling WindowDialog.SetResizable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(resizable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_resizable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *WindowDialog) GetResizable() bool {
	log.Println("Calling WindowDialog.GetResizable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_resizable", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *WindowDialog) X_Closed() {
	log.Println("Calling WindowDialog.X_Closed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_closed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the close [TextureButton].
*/
func (o *WindowDialog) GetCloseButton() *TextureButton {
	log.Println("Calling WindowDialog.GetCloseButton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_close_button", goArguments, "*TextureButton")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TextureButton)

	return returnValue

}

/*
   WindowDialogImplementer is an interface for WindowDialog objects.
*/
type WindowDialogImplementer interface {
	Class
}

/*
   FileDialog is a preset dialog used to choose files and directories in the filesystem. It supports filter masks.
*/
type FileDialog struct {
	ConfirmationDialog
}

func (o *FileDialog) baseClass() string {
	return "FileDialog"
}

/*
   Undocumented
*/
func (o *FileDialog) X_UnhandledInput(arg0 *InputEvent) {
	log.Println("Calling FileDialog.X_UnhandledInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_unhandled_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *FileDialog) X_TreeSelected() {
	log.Println("Calling FileDialog.X_TreeSelected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_tree_selected", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *FileDialog) X_TreeDbSelected() {
	log.Println("Calling FileDialog.X_TreeDbSelected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_tree_db_selected", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *FileDialog) X_DirEntered(arg0 string) {
	log.Println("Calling FileDialog.X_DirEntered()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_dir_entered", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *FileDialog) X_FileEntered(arg0 string) {
	log.Println("Calling FileDialog.X_FileEntered()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_file_entered", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *FileDialog) X_ActionPressed() {
	log.Println("Calling FileDialog.X_ActionPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_action_pressed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *FileDialog) X_CancelPressed() {
	log.Println("Calling FileDialog.X_CancelPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_cancel_pressed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *FileDialog) X_FilterSelected(arg0 int64) {
	log.Println("Calling FileDialog.X_FilterSelected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_filter_selected", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *FileDialog) X_SaveConfirmPressed() {
	log.Println("Calling FileDialog.X_SaveConfirmPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_save_confirm_pressed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear all the added filters in the dialog.
*/
func (o *FileDialog) ClearFilters() {
	log.Println("Calling FileDialog.ClearFilters()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_filters", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a custom filter. Filter format is: "mask ; description", example (C++): dialog->add_filter("*.png ; PNG Images");
*/
func (o *FileDialog) AddFilter(filter string) {
	log.Println("Calling FileDialog.AddFilter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(filter)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_filter", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *FileDialog) SetFilters(filters *PoolStringArray) {
	log.Println("Calling FileDialog.SetFilters()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(filters)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_filters", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *FileDialog) GetFilters() *PoolStringArray {
	log.Println("Calling FileDialog.GetFilters()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_filters", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Get the current working directory of the file dialog.
*/
func (o *FileDialog) GetCurrentDir() string {
	log.Println("Calling FileDialog.GetCurrentDir()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_dir", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the current selected file of the file dialog (empty if none).
*/
func (o *FileDialog) GetCurrentFile() string {
	log.Println("Calling FileDialog.GetCurrentFile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_file", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the current selected path (directory and file) of the file dialog (empty if none).
*/
func (o *FileDialog) GetCurrentPath() string {
	log.Println("Calling FileDialog.GetCurrentPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Set the current working directory of the file dialog.
*/
func (o *FileDialog) SetCurrentDir(dir string) {
	log.Println("Calling FileDialog.SetCurrentDir()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(dir)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_current_dir", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the current selected file name of the file dialog.
*/
func (o *FileDialog) SetCurrentFile(file string) {
	log.Println("Calling FileDialog.SetCurrentFile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(file)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_current_file", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the current selected file path of the file dialog.
*/
func (o *FileDialog) SetCurrentPath(path string) {
	log.Println("Calling FileDialog.SetCurrentPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_current_path", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the file dialog mode from the MODE_* enum.
*/
func (o *FileDialog) SetMode(mode int64) {
	log.Println("Calling FileDialog.SetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the file dialog mode from the MODE_* enum.
*/
func (o *FileDialog) GetMode() int64 {
	log.Println("Calling FileDialog.GetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the vertical box container of the dialog, custom controls can be added to it.
*/
func (o *FileDialog) GetVbox() *VBoxContainer {
	log.Println("Calling FileDialog.GetVbox()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vbox", goArguments, "*VBoxContainer")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*VBoxContainer)

	return returnValue

}

/*
   Set the file access permission of the dialog(Must be one of [ACCESS_RESOURCES], [ACCESS_USERDATA] or [ACCESS_FILESYSTEM]).
*/
func (o *FileDialog) SetAccess(access int64) {
	log.Println("Calling FileDialog.SetAccess()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(access)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_access", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the file access permission of the dialog.
*/
func (o *FileDialog) GetAccess() int64 {
	log.Println("Calling FileDialog.GetAccess()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_access", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the dialog should show hidden files.
*/
func (o *FileDialog) SetShowHiddenFiles(show bool) {
	log.Println("Calling FileDialog.SetShowHiddenFiles()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(show)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_show_hidden_files", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if the diaog allows show hidden files.
*/
func (o *FileDialog) IsShowingHiddenFiles() bool {
	log.Println("Calling FileDialog.IsShowingHiddenFiles()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_showing_hidden_files", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *FileDialog) X_SelectDrive(arg0 int64) {
	log.Println("Calling FileDialog.X_SelectDrive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_select_drive", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *FileDialog) X_MakeDir() {
	log.Println("Calling FileDialog.X_MakeDir()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_make_dir", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *FileDialog) X_MakeDirConfirm() {
	log.Println("Calling FileDialog.X_MakeDirConfirm()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_make_dir_confirm", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *FileDialog) X_UpdateFileList() {
	log.Println("Calling FileDialog.X_UpdateFileList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_update_file_list", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *FileDialog) X_UpdateDir() {
	log.Println("Calling FileDialog.X_UpdateDir()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_update_dir", goArguments, "")

	log.Println("Got return value!")

}

/*
   Invalidate and update the current dialog content list.
*/
func (o *FileDialog) Invalidate() {
	log.Println("Calling FileDialog.Invalidate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "invalidate", goArguments, "")

	log.Println("Got return value!")

}

/*
   FileDialogImplementer is an interface for FileDialog objects.
*/
type FileDialogImplementer interface {
	Class
}

/*
   PopupMenu is the typical Control that displays a list of options. They are popular in toolbars or context menus.
*/
type PopupMenu struct {
	Popup
}

func (o *PopupMenu) baseClass() string {
	return "PopupMenu"
}

/*
   Undocumented
*/
func (o *PopupMenu) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling PopupMenu.X_GuiInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_gui_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a new item with text "label" and icon "texture". An id can optionally be provided, as well as an accelerator keybinding. If no id is provided, one will be created from the index.
*/
func (o *PopupMenu) AddIconItem(texture *Texture, label string, id int64, accel int64) {
	log.Println("Calling PopupMenu.AddIconItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(texture)
	goArguments[1] = reflect.ValueOf(label)
	goArguments[2] = reflect.ValueOf(id)
	goArguments[3] = reflect.ValueOf(accel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_icon_item", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a new item with text "label". An id can optionally be provided, as well as an accelerator keybinding. If no id is provided, one will be created from the index.
*/
func (o *PopupMenu) AddItem(label string, id int64, accel int64) {
	log.Println("Calling PopupMenu.AddItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(label)
	goArguments[1] = reflect.ValueOf(id)
	goArguments[2] = reflect.ValueOf(accel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_item", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a new checkable item with text "label" and icon "texture". An id can optionally be provided, as well as an accelerator. If no id is provided, one will be created from the index. Note that checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually.
*/
func (o *PopupMenu) AddIconCheckItem(texture *Texture, label string, id int64, accel int64) {
	log.Println("Calling PopupMenu.AddIconCheckItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(texture)
	goArguments[1] = reflect.ValueOf(label)
	goArguments[2] = reflect.ValueOf(id)
	goArguments[3] = reflect.ValueOf(accel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_icon_check_item", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a new checkable item with text "label". An id can optionally be provided, as well as an accelerator. If no id is provided, one will be created from the index. Note that checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually.
*/
func (o *PopupMenu) AddCheckItem(label string, id int64, accel int64) {
	log.Println("Calling PopupMenu.AddCheckItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(label)
	goArguments[1] = reflect.ValueOf(id)
	goArguments[2] = reflect.ValueOf(accel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_check_item", goArguments, "")

	log.Println("Got return value!")

}

/*
   Adds an item with a submenu. The submenu is the name of a child PopupMenu node that would be shown when the item is clicked. An id can optionally be provided, but if is isn't provided, one will be created from the index.
*/
func (o *PopupMenu) AddSubmenuItem(label string, submenu string, id int64) {
	log.Println("Calling PopupMenu.AddSubmenuItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(label)
	goArguments[1] = reflect.ValueOf(submenu)
	goArguments[2] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_submenu_item", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PopupMenu) AddIconShortcut(texture *Texture, shortcut *ShortCut, id int64, global bool) {
	log.Println("Calling PopupMenu.AddIconShortcut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(texture)
	goArguments[1] = reflect.ValueOf(shortcut)
	goArguments[2] = reflect.ValueOf(id)
	goArguments[3] = reflect.ValueOf(global)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_icon_shortcut", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PopupMenu) AddShortcut(shortcut *ShortCut, id int64, global bool) {
	log.Println("Calling PopupMenu.AddShortcut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(shortcut)
	goArguments[1] = reflect.ValueOf(id)
	goArguments[2] = reflect.ValueOf(global)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_shortcut", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PopupMenu) AddIconCheckShortcut(texture *Texture, shortcut *ShortCut, id int64, global bool) {
	log.Println("Calling PopupMenu.AddIconCheckShortcut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(texture)
	goArguments[1] = reflect.ValueOf(shortcut)
	goArguments[2] = reflect.ValueOf(id)
	goArguments[3] = reflect.ValueOf(global)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_icon_check_shortcut", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PopupMenu) AddCheckShortcut(shortcut *ShortCut, id int64, global bool) {
	log.Println("Calling PopupMenu.AddCheckShortcut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(shortcut)
	goArguments[1] = reflect.ValueOf(id)
	goArguments[2] = reflect.ValueOf(global)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_check_shortcut", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the text of the item at index "idx".
*/
func (o *PopupMenu) SetItemText(idx int64, text string) {
	log.Println("Calling PopupMenu.SetItemText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_text", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PopupMenu) SetItemIcon(idx int64, icon *Texture) {
	log.Println("Calling PopupMenu.SetItemIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(icon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_icon", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the checkstate status of the item at index "idx".
*/
func (o *PopupMenu) SetItemChecked(idx int64, checked bool) {
	log.Println("Calling PopupMenu.SetItemChecked()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(checked)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_checked", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the id of the item at index "idx".
*/
func (o *PopupMenu) SetItemId(idx int64, id int64) {
	log.Println("Calling PopupMenu.SetItemId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_id", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the accelerator of the item at index "idx". Accelerators are special combinations of keys that activate the item, no matter which control is focused.
*/
func (o *PopupMenu) SetItemAccelerator(idx int64, accel int64) {
	log.Println("Calling PopupMenu.SetItemAccelerator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(accel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_accelerator", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the metadata of an item, which might be of any type. You can later get it with [method get_item_metadata], which provides a simple way of assigning context data to items.
*/
func (o *PopupMenu) SetItemMetadata(idx int64, metadata *Variant) {
	log.Println("Calling PopupMenu.SetItemMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(metadata)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_metadata", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets whether the item at index "idx" is disabled or not. When it is disabled it can't be selected, or its action invoked.
*/
func (o *PopupMenu) SetItemDisabled(idx int64, disabled bool) {
	log.Println("Calling PopupMenu.SetItemDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(disabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the submenu of the item at index "idx". The submenu is the name of a child PopupMenu node that would be shown when the item is clicked.
*/
func (o *PopupMenu) SetItemSubmenu(idx int64, submenu string) {
	log.Println("Calling PopupMenu.SetItemSubmenu()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(submenu)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_submenu", goArguments, "")

	log.Println("Got return value!")

}

/*
   Mark the item at index "idx" as a seperator, which means that it would be displayed as a mere line.
*/
func (o *PopupMenu) SetItemAsSeparator(idx int64, enable bool) {
	log.Println("Calling PopupMenu.SetItemAsSeparator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_as_separator", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether the item at index "idx" has a checkbox. Note that checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually.
*/
func (o *PopupMenu) SetItemAsCheckable(idx int64, enable bool) {
	log.Println("Calling PopupMenu.SetItemAsCheckable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_as_checkable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PopupMenu) SetItemTooltip(idx int64, tooltip string) {
	log.Println("Calling PopupMenu.SetItemTooltip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(tooltip)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_tooltip", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PopupMenu) SetItemShortcut(idx int64, shortcut *ShortCut, global bool) {
	log.Println("Calling PopupMenu.SetItemShortcut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(shortcut)
	goArguments[2] = reflect.ValueOf(global)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_shortcut", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PopupMenu) ToggleItemChecked(idx int64) {
	log.Println("Calling PopupMenu.ToggleItemChecked()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "toggle_item_checked", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the text of the item at index "idx".
*/
func (o *PopupMenu) GetItemText(idx int64) string {
	log.Println("Calling PopupMenu.GetItemText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the icon of the item at index "idx".
*/
func (o *PopupMenu) GetItemIcon(idx int64) *Texture {
	log.Println("Calling PopupMenu.GetItemIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_icon", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   Return the checkstate status of the item at index "idx".
*/
func (o *PopupMenu) IsItemChecked(idx int64) bool {
	log.Println("Calling PopupMenu.IsItemChecked()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_item_checked", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return the id of the item at index "idx".
*/
func (o *PopupMenu) GetItemId(idx int64) int64 {
	log.Println("Calling PopupMenu.GetItemId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Find and return the index of the item containing a given id.
*/
func (o *PopupMenu) GetItemIndex(id int64) int64 {
	log.Println("Calling PopupMenu.GetItemIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_index", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the accelerator of the item at index "idx". Accelerators are special combinations of keys that activate the item, no matter which control is focused.
*/
func (o *PopupMenu) GetItemAccelerator(idx int64) int64 {
	log.Println("Calling PopupMenu.GetItemAccelerator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_accelerator", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the metadata of an item, which might be of any type. You can set it with [method set_item_metadata], which provides a simple way of assigning context data to items.
*/
func (o *PopupMenu) GetItemMetadata(idx int64) *Variant {
	log.Println("Calling PopupMenu.GetItemMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_metadata", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Return whether the item at index "idx" is disabled. When it is disabled it can't be selected, or its action invoked.
*/
func (o *PopupMenu) IsItemDisabled(idx int64) bool {
	log.Println("Calling PopupMenu.IsItemDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_item_disabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return the submenu name of the item at index "idx".
*/
func (o *PopupMenu) GetItemSubmenu(idx int64) string {
	log.Println("Calling PopupMenu.GetItemSubmenu()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_submenu", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return whether the item is a seperator. If it is, it would be displayed as a line.
*/
func (o *PopupMenu) IsItemSeparator(idx int64) bool {
	log.Println("Calling PopupMenu.IsItemSeparator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_item_separator", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return whether the item at index "idx" has a checkbox. Note that checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually.
*/
func (o *PopupMenu) IsItemCheckable(idx int64) bool {
	log.Println("Calling PopupMenu.IsItemCheckable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_item_checkable", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *PopupMenu) GetItemTooltip(idx int64) string {
	log.Println("Calling PopupMenu.GetItemTooltip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_tooltip", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *PopupMenu) GetItemShortcut(idx int64) *ShortCut {
	log.Println("Calling PopupMenu.GetItemShortcut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_shortcut", goArguments, "*ShortCut")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*ShortCut)

	return returnValue

}

/*
   Return the amount of items.
*/
func (o *PopupMenu) GetItemCount() int64 {
	log.Println("Calling PopupMenu.GetItemCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Removes the item at index "idx" from the menu. Note that the indexes of items after the removed item are going to be shifted by one.
*/
func (o *PopupMenu) RemoveItem(idx int64) {
	log.Println("Calling PopupMenu.RemoveItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_item", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a separator between items. Separators also occupy an index.
*/
func (o *PopupMenu) AddSeparator() {
	log.Println("Calling PopupMenu.AddSeparator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_separator", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear the popup menu, in effect removing all items.
*/
func (o *PopupMenu) Clear() {
	log.Println("Calling PopupMenu.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *PopupMenu) X_SetItems(arg0 *Array) {
	log.Println("Calling PopupMenu.X_SetItems()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_items", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *PopupMenu) X_GetItems() *Array {
	log.Println("Calling PopupMenu.X_GetItems()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_items", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Sets whether or not the PopupMenu will hide on item selection.
*/
func (o *PopupMenu) SetHideOnItemSelection(enable bool) {
	log.Println("Calling PopupMenu.SetHideOnItemSelection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_hide_on_item_selection", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns a boolean that indicates whether or not the PopupMenu will hide on item selection.
*/
func (o *PopupMenu) IsHideOnItemSelection() bool {
	log.Println("Calling PopupMenu.IsHideOnItemSelection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_hide_on_item_selection", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Sets whether or not the PopupMenu will hide on checkable item selection.
*/
func (o *PopupMenu) SetHideOnCheckableItemSelection(enable bool) {
	log.Println("Calling PopupMenu.SetHideOnCheckableItemSelection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_hide_on_checkable_item_selection", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns a boolean that indicates whether or not the PopupMenu will hide on checkable item selection.
*/
func (o *PopupMenu) IsHideOnCheckableItemSelection() bool {
	log.Println("Calling PopupMenu.IsHideOnCheckableItemSelection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_hide_on_checkable_item_selection", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *PopupMenu) X_SubmenuTimeout() {
	log.Println("Calling PopupMenu.X_SubmenuTimeout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_submenu_timeout", goArguments, "")

	log.Println("Got return value!")

}

/*
   PopupMenuImplementer is an interface for PopupMenu objects.
*/
type PopupMenuImplementer interface {
	Class
}

/*
   Class for displaying popups with a panel background. In some cases it might be simpler to use than [Popup], since it provides a configurable background. If you are making windows, better check [WindowDialog].
*/
type PopupPanel struct {
	Popup
}

func (o *PopupPanel) baseClass() string {
	return "PopupPanel"
}

/*
   PopupPanelImplementer is an interface for PopupPanel objects.
*/
type PopupPanelImplementer interface {
	Class
}

/*
   A GraphNode is a container defined by a title. It can have 1 or more input and output slots, which can be enabled (shown) or disabled (not shown) and have different (incompatible) types. Colors can also be assigned to slots. A tuple of input and output slots is defined for each GUI element included in the GraphNode. Input and output connections are left and right slots, but only enabled slots are counted as connections.
*/
type GraphNode struct {
	Container
}

func (o *GraphNode) baseClass() string {
	return "GraphNode"
}

/*
   Set the title of the GraphNode.
*/
func (o *GraphNode) SetTitle(title string) {
	log.Println("Calling GraphNode.SetTitle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(title)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_title", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the title of the GraphNode.
*/
func (o *GraphNode) GetTitle() string {
	log.Println("Calling GraphNode.GetTitle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_title", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *GraphNode) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling GraphNode.X_GuiInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_gui_input", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GraphNode) SetSlot(idx int64, enableLeft bool, typeLeft int64, colorLeft *Color, enableRight bool, typeRight int64, colorRight *Color, customLeft *Texture, customRight *Texture) {
	log.Println("Calling GraphNode.SetSlot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 9, 9)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(enableLeft)
	goArguments[2] = reflect.ValueOf(typeLeft)
	goArguments[3] = reflect.ValueOf(colorLeft)
	goArguments[4] = reflect.ValueOf(enableRight)
	goArguments[5] = reflect.ValueOf(typeRight)
	goArguments[6] = reflect.ValueOf(colorRight)
	goArguments[7] = reflect.ValueOf(customLeft)
	goArguments[8] = reflect.ValueOf(customRight)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_slot", goArguments, "")

	log.Println("Got return value!")

}

/*
   Disable input and output slot whose index is 'idx'.
*/
func (o *GraphNode) ClearSlot(idx int64) {
	log.Println("Calling GraphNode.ClearSlot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_slot", goArguments, "")

	log.Println("Got return value!")

}

/*
   Disable all input and output slots of the GraphNode.
*/
func (o *GraphNode) ClearAllSlots() {
	log.Println("Calling GraphNode.ClearAllSlots()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_all_slots", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if left (input) slot 'idx' is enabled. False otherwise.
*/
func (o *GraphNode) IsSlotEnabledLeft(idx int64) bool {
	log.Println("Calling GraphNode.IsSlotEnabledLeft()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_slot_enabled_left", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return the (integer) type of left (input) 'idx' slot.
*/
func (o *GraphNode) GetSlotTypeLeft(idx int64) int64 {
	log.Println("Calling GraphNode.GetSlotTypeLeft()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_slot_type_left", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the color set to 'idx' left (input) slot.
*/
func (o *GraphNode) GetSlotColorLeft(idx int64) *Color {
	log.Println("Calling GraphNode.GetSlotColorLeft()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_slot_color_left", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Return true if right (output) slot 'idx' is enabled. False otherwise.
*/
func (o *GraphNode) IsSlotEnabledRight(idx int64) bool {
	log.Println("Calling GraphNode.IsSlotEnabledRight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_slot_enabled_right", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return the (integer) type of right (output) 'idx' slot.
*/
func (o *GraphNode) GetSlotTypeRight(idx int64) int64 {
	log.Println("Calling GraphNode.GetSlotTypeRight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_slot_type_right", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the color set to 'idx' right (output) slot.
*/
func (o *GraphNode) GetSlotColorRight(idx int64) *Color {
	log.Println("Calling GraphNode.GetSlotColorRight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_slot_color_right", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Set the offset of the GraphNode.
*/
func (o *GraphNode) SetOffset(offset *Vector2) {
	log.Println("Calling GraphNode.SetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the offset of the GraphNode.
*/
func (o *GraphNode) GetOffset() *Vector2 {
	log.Println("Calling GraphNode.GetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *GraphNode) SetComment(comment bool) {
	log.Println("Calling GraphNode.SetComment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(comment)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_comment", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GraphNode) IsComment() bool {
	log.Println("Calling GraphNode.IsComment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_comment", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *GraphNode) SetResizable(resizable bool) {
	log.Println("Calling GraphNode.SetResizable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(resizable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_resizable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GraphNode) IsResizable() bool {
	log.Println("Calling GraphNode.IsResizable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_resizable", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *GraphNode) SetSelected(selected bool) {
	log.Println("Calling GraphNode.SetSelected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(selected)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_selected", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GraphNode) IsSelected() bool {
	log.Println("Calling GraphNode.IsSelected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_selected", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return the number of enabled output slots (connections) of the GraphNode.
*/
func (o *GraphNode) GetConnectionOutputCount() int64 {
	log.Println("Calling GraphNode.GetConnectionOutputCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_output_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the number of enabled input slots (connections) to the GraphNode.
*/
func (o *GraphNode) GetConnectionInputCount() int64 {
	log.Println("Calling GraphNode.GetConnectionInputCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_input_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the position of the output connection 'idx'.
*/
func (o *GraphNode) GetConnectionOutputPosition(idx int64) *Vector2 {
	log.Println("Calling GraphNode.GetConnectionOutputPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_output_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the type of the output connection 'idx'.
*/
func (o *GraphNode) GetConnectionOutputType(idx int64) int64 {
	log.Println("Calling GraphNode.GetConnectionOutputType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_output_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the color of the output connection 'idx'.
*/
func (o *GraphNode) GetConnectionOutputColor(idx int64) *Color {
	log.Println("Calling GraphNode.GetConnectionOutputColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_output_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Return the position of the input connection 'idx'.
*/
func (o *GraphNode) GetConnectionInputPosition(idx int64) *Vector2 {
	log.Println("Calling GraphNode.GetConnectionInputPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_input_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the type of the input connection 'idx'.
*/
func (o *GraphNode) GetConnectionInputType(idx int64) int64 {
	log.Println("Calling GraphNode.GetConnectionInputType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_input_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the color of the input connection 'idx'.
*/
func (o *GraphNode) GetConnectionInputColor(idx int64) *Color {
	log.Println("Calling GraphNode.GetConnectionInputColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_input_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Show the close button on the GraphNode if 'show' is true (disabled by default). If enabled, a connection on the signal close_request is needed for the close button to work.
*/
func (o *GraphNode) SetShowCloseButton(show bool) {
	log.Println("Calling GraphNode.SetShowCloseButton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(show)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_show_close_button", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns true if the close button is shown. False otherwise.
*/
func (o *GraphNode) IsCloseButtonVisible() bool {
	log.Println("Calling GraphNode.IsCloseButtonVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_close_button_visible", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *GraphNode) SetOverlay(overlay int64) {
	log.Println("Calling GraphNode.SetOverlay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(overlay)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_overlay", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GraphNode) GetOverlay() int64 {
	log.Println("Calling GraphNode.GetOverlay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_overlay", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   GraphNodeImplementer is an interface for GraphNode objects.
*/
type GraphNodeImplementer interface {
	Class
}

/*
   This shows a tree of items that can be selected, expanded and collapsed. The tree can have multiple columns with custom controls like text editing, buttons and popups. It can be useful for structural displaying and interactions. Trees are built via code, using [TreeItem] objects to create the structure. They have a single root but multiple root can be simulated if a dummy hidden root is added. [codeblock] func _ready(): var tree = Tree.new() var root = tree.create_item() tree.set_hide_root(true) var child1 = tree.create_item(root) var child2 = tree.create_item(root) var subchild1 = tree.create_item(child1) subchild1.set_text(0, "Subchild1") [/codeblock]
*/
type Tree struct {
	Control
}

func (o *Tree) baseClass() string {
	return "Tree"
}

/*
   Undocumented
*/
func (o *Tree) X_RangeClickTimeout() {
	log.Println("Calling Tree.X_RangeClickTimeout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_range_click_timeout", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Tree) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling Tree.X_GuiInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_gui_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Tree) X_PopupSelect(arg0 int64) {
	log.Println("Calling Tree.X_PopupSelect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_popup_select", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Tree) X_TextEditorEnter(arg0 string) {
	log.Println("Calling Tree.X_TextEditorEnter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_text_editor_enter", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Tree) X_TextEditorModalClose() {
	log.Println("Calling Tree.X_TextEditorModalClose()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_text_editor_modal_close", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Tree) X_ValueEditorChanged(arg0 float64) {
	log.Println("Calling Tree.X_ValueEditorChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_value_editor_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Tree) X_ScrollMoved(arg0 float64) {
	log.Println("Calling Tree.X_ScrollMoved()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_scroll_moved", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear the tree. This erases all of the items.
*/
func (o *Tree) Clear() {
	log.Println("Calling Tree.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Create an item in the tree and add it as the last child of [code]parent[/code]. If parent is not given, it will be added as the last child of the root, or it'll the be the root itself if the tree is empty.
*/
func (o *Tree) CreateItem(parent *Object) *Object {
	log.Println("Calling Tree.CreateItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(parent)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "create_item", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*
   Get the root item of the tree.
*/
func (o *Tree) GetRoot() *TreeItem {
	log.Println("Calling Tree.GetRoot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_root", goArguments, "*TreeItem")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TreeItem)

	return returnValue

}

/*
   Set the minimum width of a column.
*/
func (o *Tree) SetColumnMinWidth(column int64, minWidth int64) {
	log.Println("Calling Tree.SetColumnMinWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(minWidth)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_column_min_width", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether a column will have the "Expand" flag of [Control].
*/
func (o *Tree) SetColumnExpand(column int64, expand bool) {
	log.Println("Calling Tree.SetColumnExpand()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(expand)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_column_expand", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the width of the given column in pixels.
*/
func (o *Tree) GetColumnWidth(column int64) int64 {
	log.Println("Calling Tree.GetColumnWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_column_width", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set whether the root of the tree should be hidden.
*/
func (o *Tree) SetHideRoot(enable bool) {
	log.Println("Calling Tree.SetHideRoot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_hide_root", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the next selected item after the given one.
*/
func (o *Tree) GetNextSelected(from *Object) *TreeItem {
	log.Println("Calling Tree.GetNextSelected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(from)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_next_selected", goArguments, "*TreeItem")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TreeItem)

	return returnValue

}

/*
   Get the currently selected item.
*/
func (o *Tree) GetSelected() *TreeItem {
	log.Println("Calling Tree.GetSelected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_selected", goArguments, "*TreeItem")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TreeItem)

	return returnValue

}

/*
   Get the column number of the current selection.
*/
func (o *Tree) GetSelectedColumn() int64 {
	log.Println("Calling Tree.GetSelectedColumn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_selected_column", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the index of the last pressed button.
*/
func (o *Tree) GetPressedButton() int64 {
	log.Println("Calling Tree.GetPressedButton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pressed_button", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the selection mode. Use one of the [code]SELECT_*[/code] constants.
*/
func (o *Tree) SetSelectMode(mode int64) {
	log.Println("Calling Tree.SetSelectMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_select_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the amount of columns.
*/
func (o *Tree) SetColumns(amount int64) {
	log.Println("Calling Tree.SetColumns()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_columns", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the amount of columns.
*/
func (o *Tree) GetColumns() int64 {
	log.Println("Calling Tree.GetColumns()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_columns", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the current edited item. This is only available for custom cell mode.
*/
func (o *Tree) GetEdited() *TreeItem {
	log.Println("Calling Tree.GetEdited()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_edited", goArguments, "*TreeItem")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TreeItem)

	return returnValue

}

/*
   Get the column of the cell for the current edited icon. This is only available for custom cell mode.
*/
func (o *Tree) GetEditedColumn() int64 {
	log.Println("Calling Tree.GetEditedColumn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_edited_column", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the rectangle for custom popups. Helper to create custom cell controls that display a popup. See [method TreeItem.set_cell_mode].
*/
func (o *Tree) GetCustomPopupRect() *Rect2 {
	log.Println("Calling Tree.GetCustomPopupRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_custom_popup_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Get the rectangle area of the the specified item. If column is specified, only get the position and size of that column, otherwise get the rectangle containing all columns.
*/
func (o *Tree) GetItemAreaRect(item *Object, column int64) *Rect2 {
	log.Println("Calling Tree.GetItemAreaRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(item)
	goArguments[1] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_area_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Get the tree item at the specified position (relative to the tree origin position).
*/
func (o *Tree) GetItemAtPosition(position *Vector2) *TreeItem {
	log.Println("Calling Tree.GetItemAtPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_at_position", goArguments, "*TreeItem")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TreeItem)

	return returnValue

}

/*
   Get the column index under the given point.
*/
func (o *Tree) GetColumnAtPosition(position *Vector2) int64 {
	log.Println("Calling Tree.GetColumnAtPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_column_at_position", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Tree) GetDropSectionAtPosition(position *Vector2) int64 {
	log.Println("Calling Tree.GetDropSectionAtPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_drop_section_at_position", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Make the current selected item visible. This will scroll the tree to make sure the selected item is in sight.
*/
func (o *Tree) EnsureCursorIsVisible() {
	log.Println("Calling Tree.EnsureCursorIsVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "ensure_cursor_is_visible", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether the column titles visibility.
*/
func (o *Tree) SetColumnTitlesVisible(visible bool) {
	log.Println("Calling Tree.SetColumnTitlesVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(visible)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_column_titles_visible", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get whether the column titles are being shown.
*/
func (o *Tree) AreColumnTitlesVisible() bool {
	log.Println("Calling Tree.AreColumnTitlesVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "are_column_titles_visible", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the title of a column.
*/
func (o *Tree) SetColumnTitle(column int64, title string) {
	log.Println("Calling Tree.SetColumnTitle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(title)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_column_title", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the title of the given column.
*/
func (o *Tree) GetColumnTitle(column int64) string {
	log.Println("Calling Tree.GetColumnTitle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_column_title", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the current scrolling position.
*/
func (o *Tree) GetScroll() *Vector2 {
	log.Println("Calling Tree.GetScroll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scroll", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set whether the folding arrow should be hidden.
*/
func (o *Tree) SetHideFolding(hide bool) {
	log.Println("Calling Tree.SetHideFolding()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(hide)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_hide_folding", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get whether the folding arrow is hidden.
*/
func (o *Tree) IsFoldingHidden() bool {
	log.Println("Calling Tree.IsFoldingHidden()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_folding_hidden", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the drop mode as an OR combination of flags. See [code]DROP_MODE_*[/code] constants.
*/
func (o *Tree) SetDropModeFlags(flags int64) {
	log.Println("Calling Tree.SetDropModeFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flags)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_drop_mode_flags", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the flags of the current drop mode.
*/
func (o *Tree) GetDropModeFlags() int64 {
	log.Println("Calling Tree.GetDropModeFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_drop_mode_flags", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set whether or not a right mouse button click can select items.
*/
func (o *Tree) SetAllowRmbSelect(allow bool) {
	log.Println("Calling Tree.SetAllowRmbSelect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(allow)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_allow_rmb_select", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get whether a right click can select items.
*/
func (o *Tree) GetAllowRmbSelect() bool {
	log.Println("Calling Tree.GetAllowRmbSelect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_allow_rmb_select", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Tree) SetAllowReselect(allow bool) {
	log.Println("Calling Tree.SetAllowReselect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(allow)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_allow_reselect", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Tree) GetAllowReselect() bool {
	log.Println("Calling Tree.GetAllowReselect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_allow_reselect", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   TreeImplementer is an interface for Tree objects.
*/
type TreeImplementer interface {
	Class
}

/*
   This control provides a selectable list of items that may be in a single (or multiple columns) with option of text, icons, or both text and icon. Tooltips are supported and may be different for every item in the list. Selectable items in the list may be selected or deselected and multiple selection may be enabled. Selection with right mouse button may also be enabled to allow use of popup context menus. Items may also be 'activated' with a double click (or Enter key).
*/
type ItemList struct {
	Control
}

func (o *ItemList) baseClass() string {
	return "ItemList"
}

/*
   Adds an item to the item list with specified text. Specify an icon of null for a list item with no icon. If selectable is true the list item will be selectable.
*/
func (o *ItemList) AddItem(text string, icon *Texture, selectable bool) {
	log.Println("Calling ItemList.AddItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(text)
	goArguments[1] = reflect.ValueOf(icon)
	goArguments[2] = reflect.ValueOf(selectable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_item", goArguments, "")

	log.Println("Got return value!")

}

/*
   Adds an item to the item list with no text, only an icon.
*/
func (o *ItemList) AddIconItem(icon *Texture, selectable bool) {
	log.Println("Calling ItemList.AddIconItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(icon)
	goArguments[1] = reflect.ValueOf(selectable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_icon_item", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets text of item at specified index.
*/
func (o *ItemList) SetItemText(idx int64, text string) {
	log.Println("Calling ItemList.SetItemText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_text", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the text for specified item index.
*/
func (o *ItemList) GetItemText(idx int64) string {
	log.Println("Calling ItemList.GetItemText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Set (or replace) icon of the item at the specified index.
*/
func (o *ItemList) SetItemIcon(idx int64, icon *Texture) {
	log.Println("Calling ItemList.SetItemIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(icon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_icon", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ItemList) GetItemIcon(idx int64) *Texture {
	log.Println("Calling ItemList.GetItemIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_icon", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *ItemList) SetItemIconRegion(idx int64, rect *Rect2) {
	log.Println("Calling ItemList.SetItemIconRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(rect)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_icon_region", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ItemList) GetItemIconRegion(idx int64) *Rect2 {
	log.Println("Calling ItemList.GetItemIconRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_icon_region", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Allow or disallow selection of the item at the specified index.
*/
func (o *ItemList) SetItemSelectable(idx int64, selectable bool) {
	log.Println("Calling ItemList.SetItemSelectable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(selectable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_selectable", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether or not the item at the specified index is selectable.
*/
func (o *ItemList) IsItemSelectable(idx int64) bool {
	log.Println("Calling ItemList.IsItemSelectable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_item_selectable", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Disable (or enable) item at specified index. Disabled items are not be selectable and do not fire activation (Enter or double-click) signals.
*/
func (o *ItemList) SetItemDisabled(idx int64, disabled bool) {
	log.Println("Calling ItemList.SetItemDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(disabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether or not the item at the specified index is disabled
*/
func (o *ItemList) IsItemDisabled(idx int64) bool {
	log.Println("Calling ItemList.IsItemDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_item_disabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Sets a value (of any type) to be stored with the item at the specified index.
*/
func (o *ItemList) SetItemMetadata(idx int64, metadata *Variant) {
	log.Println("Calling ItemList.SetItemMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(metadata)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_metadata", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ItemList) GetItemMetadata(idx int64) *Variant {
	log.Println("Calling ItemList.GetItemMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_metadata", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *ItemList) SetItemCustomBgColor(idx int64, customBgColor *Color) {
	log.Println("Calling ItemList.SetItemCustomBgColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(customBgColor)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_custom_bg_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ItemList) GetItemCustomBgColor(idx int64) *Color {
	log.Println("Calling ItemList.GetItemCustomBgColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_custom_bg_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Sets whether the tooltip is enabled for specified item index.
*/
func (o *ItemList) SetItemTooltipEnabled(idx int64, enable bool) {
	log.Println("Calling ItemList.SetItemTooltipEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_tooltip_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether the tooptip is enabled for specified item index.
*/
func (o *ItemList) IsItemTooltipEnabled(idx int64) bool {
	log.Println("Calling ItemList.IsItemTooltipEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_item_tooltip_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Sets tooltip hint for item at specified index.
*/
func (o *ItemList) SetItemTooltip(idx int64, tooltip string) {
	log.Println("Calling ItemList.SetItemTooltip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(tooltip)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_tooltip", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return tooltip hint for specified item index.
*/
func (o *ItemList) GetItemTooltip(idx int64) string {
	log.Println("Calling ItemList.GetItemTooltip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_tooltip", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Select the item at the specified index. Note: This method does not trigger the item selection signal.
*/
func (o *ItemList) Select(idx int64, single bool) {
	log.Println("Calling ItemList.Select()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(single)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "select", goArguments, "")

	log.Println("Got return value!")

}

/*
   Ensure item at specified index is not selected.
*/
func (o *ItemList) Unselect(idx int64) {
	log.Println("Calling ItemList.Unselect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "unselect", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether or not item at the specified index is currently selected.
*/
func (o *ItemList) IsSelected(idx int64) bool {
	log.Println("Calling ItemList.IsSelected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_selected", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns the list of selected indexes.
*/
func (o *ItemList) GetSelectedItems() *PoolIntArray {
	log.Println("Calling ItemList.GetSelectedItems()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_selected_items", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*
   Return count of items currently in the item list.
*/
func (o *ItemList) GetItemCount() int64 {
	log.Println("Calling ItemList.GetItemCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Remove item at specified index from the list.
*/
func (o *ItemList) RemoveItem(idx int64) {
	log.Println("Calling ItemList.RemoveItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_item", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove all items from the list.
*/
func (o *ItemList) Clear() {
	log.Println("Calling ItemList.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sorts items in the list by their text.
*/
func (o *ItemList) SortItemsByText() {
	log.Println("Calling ItemList.SortItemsByText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "sort_items_by_text", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the size (width) all columns in the list are to use.
*/
func (o *ItemList) SetFixedColumnWidth(width int64) {
	log.Println("Calling ItemList.SetFixedColumnWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(width)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fixed_column_width", goArguments, "")

	log.Println("Got return value!")

}

/*
   If column size has been fixed to a value, return that value.
*/
func (o *ItemList) GetFixedColumnWidth() int64 {
	log.Println("Calling ItemList.GetFixedColumnWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fixed_column_width", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Sets a fixed size (width) to use for all columns of the list.
*/
func (o *ItemList) SetSameColumnWidth(enable bool) {
	log.Println("Calling ItemList.SetSameColumnWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_same_column_width", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether or not all columns of the list are of the same size.
*/
func (o *ItemList) IsSameColumnWidth() bool {
	log.Println("Calling ItemList.IsSameColumnWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_same_column_width", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set maximum number of lines to use for the list.
*/
func (o *ItemList) SetMaxTextLines(lines int64) {
	log.Println("Calling ItemList.SetMaxTextLines()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(lines)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_text_lines", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return total number of lines currently in use by the list.
*/
func (o *ItemList) GetMaxTextLines() int64 {
	log.Println("Calling ItemList.GetMaxTextLines()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_max_text_lines", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set maximum number of columns to use for the list.
*/
func (o *ItemList) SetMaxColumns(amount int64) {
	log.Println("Calling ItemList.SetMaxColumns()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_columns", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return total number of columns in use by the list.
*/
func (o *ItemList) GetMaxColumns() int64 {
	log.Println("Calling ItemList.GetMaxColumns()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_max_columns", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ItemList) SetSelectMode(mode int64) {
	log.Println("Calling ItemList.SetSelectMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_select_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ItemList) GetSelectMode() int64 {
	log.Println("Calling ItemList.GetSelectMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_select_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ItemList) SetIconMode(mode int64) {
	log.Println("Calling ItemList.SetIconMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_icon_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ItemList) GetIconMode() int64 {
	log.Println("Calling ItemList.GetIconMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_icon_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ItemList) SetFixedIconSize(size *Vector2) {
	log.Println("Calling ItemList.SetFixedIconSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fixed_icon_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ItemList) GetFixedIconSize() *Vector2 {
	log.Println("Calling ItemList.GetFixedIconSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fixed_icon_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *ItemList) SetIconScale(scale float64) {
	log.Println("Calling ItemList.SetIconScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_icon_scale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ItemList) GetIconScale() float64 {
	log.Println("Calling ItemList.GetIconScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_icon_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Allow (or disallow) selection of (selectable) items in the list using right mouse button.
*/
func (o *ItemList) SetAllowRmbSelect(allow bool) {
	log.Println("Calling ItemList.SetAllowRmbSelect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(allow)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_allow_rmb_select", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether or not items may be selected via right mouse clicking.
*/
func (o *ItemList) GetAllowRmbSelect() bool {
	log.Println("Calling ItemList.GetAllowRmbSelect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_allow_rmb_select", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *ItemList) SetAutoHeight(enable bool) {
	log.Println("Calling ItemList.SetAutoHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_auto_height", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ItemList) HasAutoHeight() bool {
	log.Println("Calling ItemList.HasAutoHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_auto_height", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Given a position within the control return the item (if any) at that point.
*/
func (o *ItemList) GetItemAtPosition(position *Vector2, exact bool) int64 {
	log.Println("Calling ItemList.GetItemAtPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(position)
	goArguments[1] = reflect.ValueOf(exact)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_at_position", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Ensure selection is visible, adjusting the scroll position as necessary.
*/
func (o *ItemList) EnsureCurrentIsVisible() {
	log.Println("Calling ItemList.EnsureCurrentIsVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "ensure_current_is_visible", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the current vertical scroll bar for the List.
*/
func (o *ItemList) GetVScroll() *VScrollBar {
	log.Println("Calling ItemList.GetVScroll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_v_scroll", goArguments, "*VScrollBar")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*VScrollBar)

	return returnValue

}

/*
   Undocumented
*/
func (o *ItemList) X_ScrollChanged(arg0 float64) {
	log.Println("Calling ItemList.X_ScrollChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_scroll_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ItemList) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling ItemList.X_GuiInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_gui_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ItemList) X_SetItems(arg0 *Array) {
	log.Println("Calling ItemList.X_SetItems()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_items", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ItemList) X_GetItems() *Array {
	log.Println("Calling ItemList.X_GetItems()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_items", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   ItemListImplementer is an interface for ItemList objects.
*/
type ItemListImplementer interface {
	Class
}

/*
   Tabbed Container. Contains several children controls, but shows only one at the same time. Clicking on the top tabs allows to change the currently visible one. Children controls of this one automatically.
*/
type TabContainer struct {
	Control
}

func (o *TabContainer) baseClass() string {
	return "TabContainer"
}

/*
   Undocumented
*/
func (o *TabContainer) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling TabContainer.X_GuiInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_gui_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the amount of tabs.
*/
func (o *TabContainer) GetTabCount() int64 {
	log.Println("Calling TabContainer.GetTabCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Bring a tab (and the Control it represents) to the front, and hide the rest.
*/
func (o *TabContainer) SetCurrentTab(tabIdx int64) {
	log.Println("Calling TabContainer.SetCurrentTab()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tabIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_current_tab", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current tab index that is being shown.
*/
func (o *TabContainer) GetCurrentTab() int64 {
	log.Println("Calling TabContainer.GetCurrentTab()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_tab", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the previous tab index that was being shown.
*/
func (o *TabContainer) GetPreviousTab() int64 {
	log.Println("Calling TabContainer.GetPreviousTab()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_previous_tab", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *TabContainer) GetCurrentTabControl() *Control {
	log.Println("Calling TabContainer.GetCurrentTabControl()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_tab_control", goArguments, "*Control")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Control)

	return returnValue

}

/*
   Return the current tab control that is being shown.
*/
func (o *TabContainer) GetTabControl(idx int64) *Control {
	log.Println("Calling TabContainer.GetTabControl()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_control", goArguments, "*Control")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Control)

	return returnValue

}

/*
   Set tab alignment, from the ALIGN_* enum. Moves tabs to the left, right or center.
*/
func (o *TabContainer) SetTabAlign(align int64) {
	log.Println("Calling TabContainer.SetTabAlign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(align)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tab_align", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return tab alignment, from the ALIGN_* enum.
*/
func (o *TabContainer) GetTabAlign() int64 {
	log.Println("Calling TabContainer.GetTabAlign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_align", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set whether the tabs should be visible or hidden.
*/
func (o *TabContainer) SetTabsVisible(visible bool) {
	log.Println("Calling TabContainer.SetTabsVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(visible)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tabs_visible", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether the tabs should be visible or hidden.
*/
func (o *TabContainer) AreTabsVisible() bool {
	log.Println("Calling TabContainer.AreTabsVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "are_tabs_visible", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set a title for the tab. Tab titles are by default the children node name, but this can be overridden.
*/
func (o *TabContainer) SetTabTitle(tabIdx int64, title string) {
	log.Println("Calling TabContainer.SetTabTitle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(tabIdx)
	goArguments[1] = reflect.ValueOf(title)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tab_title", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the title for the tab. Tab titles are by default the children node name, but this can be overridden.
*/
func (o *TabContainer) GetTabTitle(tabIdx int64) string {
	log.Println("Calling TabContainer.GetTabTitle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tabIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_title", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Set an icon for a tab.
*/
func (o *TabContainer) SetTabIcon(tabIdx int64, icon *Texture) {
	log.Println("Calling TabContainer.SetTabIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(tabIdx)
	goArguments[1] = reflect.ValueOf(icon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tab_icon", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TabContainer) GetTabIcon(tabIdx int64) *Texture {
	log.Println("Calling TabContainer.GetTabIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tabIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_icon", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TabContainer) SetTabDisabled(tabIdx int64, disabled bool) {
	log.Println("Calling TabContainer.SetTabDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(tabIdx)
	goArguments[1] = reflect.ValueOf(disabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tab_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TabContainer) GetTabDisabled(tabIdx int64) bool {
	log.Println("Calling TabContainer.GetTabDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tabIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_disabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *TabContainer) SetPopup(popup *Object) {
	log.Println("Calling TabContainer.SetPopup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(popup)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_popup", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TabContainer) GetPopup() *Popup {
	log.Println("Calling TabContainer.GetPopup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_popup", goArguments, "*Popup")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Popup)

	return returnValue

}

/*
   Undocumented
*/
func (o *TabContainer) X_ChildRenamedCallback() {
	log.Println("Calling TabContainer.X_ChildRenamedCallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_child_renamed_callback", goArguments, "")

	log.Println("Got return value!")

}

/*
   TabContainerImplementer is an interface for TabContainer objects.
*/
type TabContainerImplementer interface {
	Class
}

/*
   Simple tabs control, similar to [TabContainer] but is only in charge of drawing tabs, not interact with children.
*/
type Tabs struct {
	Control
}

func (o *Tabs) baseClass() string {
	return "Tabs"
}

/*
   Undocumented
*/
func (o *Tabs) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling Tabs.X_GuiInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_gui_input", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Tabs) GetTabCount() int64 {
	log.Println("Calling Tabs.GetTabCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Tabs) SetCurrentTab(tabIdx int64) {
	log.Println("Calling Tabs.SetCurrentTab()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tabIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_current_tab", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Tabs) GetCurrentTab() int64 {
	log.Println("Calling Tabs.GetCurrentTab()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_tab", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Tabs) SetTabTitle(tabIdx int64, title string) {
	log.Println("Calling Tabs.SetTabTitle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(tabIdx)
	goArguments[1] = reflect.ValueOf(title)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tab_title", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Tabs) GetTabTitle(tabIdx int64) string {
	log.Println("Calling Tabs.GetTabTitle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tabIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_title", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *Tabs) SetTabIcon(tabIdx int64, icon *Texture) {
	log.Println("Calling Tabs.SetTabIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(tabIdx)
	goArguments[1] = reflect.ValueOf(icon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tab_icon", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Tabs) GetTabIcon(tabIdx int64) *Texture {
	log.Println("Calling Tabs.GetTabIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tabIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_icon", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *Tabs) SetTabDisabled(tabIdx int64, disabled bool) {
	log.Println("Calling Tabs.SetTabDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(tabIdx)
	goArguments[1] = reflect.ValueOf(disabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tab_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Tabs) GetTabDisabled(tabIdx int64) bool {
	log.Println("Calling Tabs.GetTabDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tabIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_disabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Tabs) RemoveTab(tabIdx int64) {
	log.Println("Calling Tabs.RemoveTab()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tabIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_tab", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Tabs) AddTab(title string, icon *Texture) {
	log.Println("Calling Tabs.AddTab()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(title)
	goArguments[1] = reflect.ValueOf(icon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_tab", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Tabs) SetTabAlign(align int64) {
	log.Println("Calling Tabs.SetTabAlign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(align)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tab_align", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Tabs) GetTabAlign() int64 {
	log.Println("Calling Tabs.GetTabAlign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_align", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Tabs) EnsureTabVisible(idx int64) {
	log.Println("Calling Tabs.EnsureTabVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "ensure_tab_visible", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns tab [Rect2] with local position and size.
*/
func (o *Tabs) GetTabRect(tabIdx int64) *Rect2 {
	log.Println("Calling Tabs.GetTabRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tabIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Rearrange tab.
*/
func (o *Tabs) MoveTab(from int64, to int64) {
	log.Println("Calling Tabs.MoveTab()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(to)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "move_tab", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Tabs) SetTabCloseDisplayPolicy(policy int64) {
	log.Println("Calling Tabs.SetTabCloseDisplayPolicy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(policy)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tab_close_display_policy", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Tabs) GetTabCloseDisplayPolicy() int64 {
	log.Println("Calling Tabs.GetTabCloseDisplayPolicy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_close_display_policy", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   TabsImplementer is an interface for Tabs objects.
*/
type TabsImplementer interface {
	Class
}

/*
   Horizontal separator. See [Separator]. It is used to separate objects vertically, though (but it looks horizontal!).
*/
type HSeparator struct {
	Separator
}

func (o *HSeparator) baseClass() string {
	return "HSeparator"
}

/*
   HSeparatorImplementer is an interface for HSeparator objects.
*/
type HSeparatorImplementer interface {
	Class
}

/*
   Vertical version of [Separator]. It is used to separate objects horizontally, though (but it looks vertical!).
*/
type VSeparator struct {
	Separator
}

func (o *VSeparator) baseClass() string {
	return "VSeparator"
}

/*
   VSeparatorImplementer is an interface for VSeparator objects.
*/
type VSeparatorImplementer interface {
	Class
}

/*
   This is a simple color picker [Control]. It's useful for selecting a color from an RGB/RGBA colorspace.
*/
type ColorPicker struct {
	BoxContainer
}

func (o *ColorPicker) baseClass() string {
	return "ColorPicker"
}

/*
   Select the current color.
*/
func (o *ColorPicker) SetPickColor(color *Color) {
	log.Println("Calling ColorPicker.SetPickColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pick_color", goArguments, "")

	log.Println("Got return value!")

}

/*
   Gets the current color.
*/
func (o *ColorPicker) GetPickColor() *Color {
	log.Println("Calling ColorPicker.GetPickColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pick_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Set whether this color picker is using raw mode or not, see [method is_raw_mode].
*/
func (o *ColorPicker) SetRawMode(mode bool) {
	log.Println("Calling ColorPicker.SetRawMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_raw_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether this color picker is in raw mode or not, raw mode will allow the color R, G, B component values to go beyond 1, you have to consider that the max value for color components is 1, going beyond that value will not have effect in the color, but can be used for special operations that require it (like tinting without darkening or rendering sprites in HDR).
*/
func (o *ColorPicker) IsRawMode() bool {
	log.Println("Calling ColorPicker.IsRawMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_raw_mode", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set true if you want the color to have an alpha channel (transparency), or false if you want a solid color.
*/
func (o *ColorPicker) SetEditAlpha(show bool) {
	log.Println("Calling ColorPicker.SetEditAlpha()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(show)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_edit_alpha", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether the color has transparency or not.
*/
func (o *ColorPicker) IsEditingAlpha() bool {
	log.Println("Calling ColorPicker.IsEditingAlpha()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_editing_alpha", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Adds the current selected to color to a list of colors (presets), the presets will be displayed in the color picker and the user will be able to select them, notice that the presets list is only for this color picker.
*/
func (o *ColorPicker) AddPreset(color *Color) {
	log.Println("Calling ColorPicker.AddPreset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_preset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ColorPicker) X_ValueChanged(arg0 float64) {
	log.Println("Calling ColorPicker.X_ValueChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_value_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ColorPicker) X_HtmlEntered(arg0 string) {
	log.Println("Calling ColorPicker.X_HtmlEntered()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_html_entered", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ColorPicker) X_TextTypeToggled() {
	log.Println("Calling ColorPicker.X_TextTypeToggled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_text_type_toggled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ColorPicker) X_AddPresetPressed() {
	log.Println("Calling ColorPicker.X_AddPresetPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_add_preset_pressed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ColorPicker) X_ScreenPickPressed() {
	log.Println("Calling ColorPicker.X_ScreenPickPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_screen_pick_pressed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ColorPicker) X_SampleDraw() {
	log.Println("Calling ColorPicker.X_SampleDraw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_sample_draw", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ColorPicker) X_HsvDraw(arg0 int64, arg1 *Object) {
	log.Println("Calling ColorPicker.X_HsvDraw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(arg0)
	goArguments[1] = reflect.ValueOf(arg1)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_hsv_draw", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ColorPicker) X_UvInput(arg0 *InputEvent) {
	log.Println("Calling ColorPicker.X_UvInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_uv_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ColorPicker) X_WInput(arg0 *InputEvent) {
	log.Println("Calling ColorPicker.X_WInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_w_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ColorPicker) X_PresetInput(arg0 *InputEvent) {
	log.Println("Calling ColorPicker.X_PresetInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_preset_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ColorPicker) X_ScreenInput(arg0 *InputEvent) {
	log.Println("Calling ColorPicker.X_ScreenInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_screen_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   ColorPickerImplementer is an interface for ColorPicker objects.
*/
type ColorPickerImplementer interface {
	Class
}

/*
   Label that displays rich text. Rich text can contain custom text, fonts, images and some basic formatting. It also adapts itself to given width/heights.
*/
type RichTextLabel struct {
	Control
}

func (o *RichTextLabel) baseClass() string {
	return "RichTextLabel"
}

/*
   Undocumented
*/
func (o *RichTextLabel) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling RichTextLabel.X_GuiInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_gui_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *RichTextLabel) X_ScrollChanged(arg0 float64) {
	log.Println("Calling RichTextLabel.X_ScrollChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_scroll_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the raw text, stripping out the formatting information.
*/
func (o *RichTextLabel) GetText() string {
	log.Println("Calling RichTextLabel.GetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *RichTextLabel) AddText(text string) {
	log.Println("Calling RichTextLabel.AddText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_text", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) SetText(text string) {
	log.Println("Calling RichTextLabel.SetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_text", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) AddImage(image *Texture) {
	log.Println("Calling RichTextLabel.AddImage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(image)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_image", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) Newline() {
	log.Println("Calling RichTextLabel.Newline()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "newline", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) RemoveLine(line int64) bool {
	log.Println("Calling RichTextLabel.RemoveLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(line)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "remove_line", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *RichTextLabel) PushFont(font *Font) {
	log.Println("Calling RichTextLabel.PushFont()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(font)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "push_font", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) PushColor(color *Color) {
	log.Println("Calling RichTextLabel.PushColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "push_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) PushAlign(align int64) {
	log.Println("Calling RichTextLabel.PushAlign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(align)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "push_align", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) PushIndent(level int64) {
	log.Println("Calling RichTextLabel.PushIndent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(level)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "push_indent", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) PushList(aType int64) {
	log.Println("Calling RichTextLabel.PushList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "push_list", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) PushMeta(data *Variant) {
	log.Println("Calling RichTextLabel.PushMeta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "push_meta", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) PushUnderline() {
	log.Println("Calling RichTextLabel.PushUnderline()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "push_underline", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) PushTable(columns int64) {
	log.Println("Calling RichTextLabel.PushTable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(columns)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "push_table", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) SetTableColumnExpand(column int64, expand bool, ratio int64) {
	log.Println("Calling RichTextLabel.SetTableColumnExpand()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(expand)
	goArguments[2] = reflect.ValueOf(ratio)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_table_column_expand", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) PushCell() {
	log.Println("Calling RichTextLabel.PushCell()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "push_cell", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) Pop() {
	log.Println("Calling RichTextLabel.Pop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "pop", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) Clear() {
	log.Println("Calling RichTextLabel.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) SetMetaUnderline(enable bool) {
	log.Println("Calling RichTextLabel.SetMetaUnderline()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_meta_underline", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) IsMetaUnderlined() bool {
	log.Println("Calling RichTextLabel.IsMetaUnderlined()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_meta_underlined", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *RichTextLabel) SetScrollActive(active bool) {
	log.Println("Calling RichTextLabel.SetScrollActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(active)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scroll_active", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) IsScrollActive() bool {
	log.Println("Calling RichTextLabel.IsScrollActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_scroll_active", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *RichTextLabel) SetScrollFollow(follow bool) {
	log.Println("Calling RichTextLabel.SetScrollFollow()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(follow)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scroll_follow", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) IsScrollFollowing() bool {
	log.Println("Calling RichTextLabel.IsScrollFollowing()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_scroll_following", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *RichTextLabel) GetVScroll() *VScrollBar {
	log.Println("Calling RichTextLabel.GetVScroll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_v_scroll", goArguments, "*VScrollBar")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*VScrollBar)

	return returnValue

}

/*

 */
func (o *RichTextLabel) ScrollToLine(line int64) {
	log.Println("Calling RichTextLabel.ScrollToLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(line)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "scroll_to_line", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) SetTabSize(spaces int64) {
	log.Println("Calling RichTextLabel.SetTabSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(spaces)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tab_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) GetTabSize() int64 {
	log.Println("Calling RichTextLabel.GetTabSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set to true if selecting the text inside this richtext is allowed.
*/
func (o *RichTextLabel) SetSelectionEnabled(enabled bool) {
	log.Println("Calling RichTextLabel.SetSelectionEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_selection_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if selecting the text inside this richtext is allowed.
*/
func (o *RichTextLabel) IsSelectionEnabled() bool {
	log.Println("Calling RichTextLabel.IsSelectionEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_selection_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *RichTextLabel) ParseBbcode(bbcode string) int64 {
	log.Println("Calling RichTextLabel.ParseBbcode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bbcode)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "parse_bbcode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *RichTextLabel) AppendBbcode(bbcode string) int64 {
	log.Println("Calling RichTextLabel.AppendBbcode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bbcode)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "append_bbcode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *RichTextLabel) SetBbcode(text string) {
	log.Println("Calling RichTextLabel.SetBbcode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bbcode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) GetBbcode() string {
	log.Println("Calling RichTextLabel.GetBbcode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bbcode", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *RichTextLabel) SetVisibleCharacters(amount int64) {
	log.Println("Calling RichTextLabel.SetVisibleCharacters()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_visible_characters", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) GetVisibleCharacters() int64 {
	log.Println("Calling RichTextLabel.GetVisibleCharacters()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_visible_characters", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *RichTextLabel) SetPercentVisible(percentVisible float64) {
	log.Println("Calling RichTextLabel.SetPercentVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(percentVisible)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_percent_visible", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) GetPercentVisible() float64 {
	log.Println("Calling RichTextLabel.GetPercentVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_percent_visible", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *RichTextLabel) GetTotalCharacterCount() int64 {
	log.Println("Calling RichTextLabel.GetTotalCharacterCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_total_character_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *RichTextLabel) SetUseBbcode(enable bool) {
	log.Println("Calling RichTextLabel.SetUseBbcode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_bbcode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) IsUsingBbcode() bool {
	log.Println("Calling RichTextLabel.IsUsingBbcode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_using_bbcode", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *RichTextLabel) GetLineCount() int64 {
	log.Println("Calling RichTextLabel.GetLineCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_line_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *RichTextLabel) GetVisibleLineCount() int64 {
	log.Println("Calling RichTextLabel.GetVisibleLineCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_visible_line_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   RichTextLabelImplementer is an interface for RichTextLabel objects.
*/
type RichTextLabelImplementer interface {
	Class
}

/*
   Vertical split container. See [SplitContainer]. This goes from left to right.
*/
type VSplitContainer struct {
	SplitContainer
}

func (o *VSplitContainer) baseClass() string {
	return "VSplitContainer"
}

/*
   VSplitContainerImplementer is an interface for VSplitContainer objects.
*/
type VSplitContainerImplementer interface {
	Class
}

/*
   Horizontal split container. See [SplitContainer]. This goes from left to right.
*/
type HSplitContainer struct {
	SplitContainer
}

func (o *HSplitContainer) baseClass() string {
	return "HSplitContainer"
}

/*
   HSplitContainerImplementer is an interface for HSplitContainer objects.
*/
type HSplitContainerImplementer interface {
	Class
}

/*
   Vertical box container. See [BoxContainer].
*/
type VBoxContainer struct {
	BoxContainer
}

func (o *VBoxContainer) baseClass() string {
	return "VBoxContainer"
}

/*
   VBoxContainerImplementer is an interface for VBoxContainer objects.
*/
type VBoxContainerImplementer interface {
	Class
}

/*
   Simple margin container. Adds a left margin to anything contained.
*/
type MarginContainer struct {
	Container
}

func (o *MarginContainer) baseClass() string {
	return "MarginContainer"
}

/*
   MarginContainerImplementer is an interface for MarginContainer objects.
*/
type MarginContainerImplementer interface {
	Class
}

/*
   Horizontal box container. See [BoxContainer].
*/
type HBoxContainer struct {
	BoxContainer
}

func (o *HBoxContainer) baseClass() string {
	return "HBoxContainer"
}

/*
   HBoxContainerImplementer is an interface for HBoxContainer objects.
*/
type HBoxContainerImplementer interface {
	Class
}

/*
   Grid container will arrange its children in a grid like structure, the grid columns are specified using the [method set_columns] method and the number of rows will be equal to the number of children in the container divided by the number of columns, for example: if the container has 5 children, and 2 columns, there will be 3 rows in the container. Notice that grid layout will preserve the columns and rows for every size of the container.
*/
type GridContainer struct {
	Container
}

func (o *GridContainer) baseClass() string {
	return "GridContainer"
}

/*
   Sets the numbers of columns in the container, then reorder its children to accommodate the new layout
*/
func (o *GridContainer) SetColumns(columns int64) {
	log.Println("Calling GridContainer.SetColumns()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(columns)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_columns", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the number of columns in this container
*/
func (o *GridContainer) GetColumns() int64 {
	log.Println("Calling GridContainer.GetColumns()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_columns", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   GridContainerImplementer is an interface for GridContainer objects.
*/
type GridContainerImplementer interface {
	Class
}

/*
   Reference frame for GUI. It's just like an empty control, except a red box is displayed while editing around its size at all times.
*/
type ReferenceRect struct {
	Control
}

func (o *ReferenceRect) baseClass() string {
	return "ReferenceRect"
}

/*
   ReferenceRectImplementer is an interface for ReferenceRect objects.
*/
type ReferenceRectImplementer interface {
	Class
}

/*
   Panel container type. This container fits controls inside of the delimited area of a stylebox. It's useful for giving controls an outline.
*/
type PanelContainer struct {
	Container
}

func (o *PanelContainer) baseClass() string {
	return "PanelContainer"
}

/*
   PanelContainerImplementer is an interface for PanelContainer objects.
*/
type PanelContainerImplementer interface {
	Class
}

/*
   Nodes are the base bricks with which Godot games are developed. They can be set as children of other nodes, resulting in a tree arrangement. A given node can contain any number of nodes as children (but there is only one scene tree root node) with the requirement that all siblings (direct children of a node) should have unique names. Any tree of nodes is called a [i]scene[/i]. Scenes can be saved to the disk and then instanced into other scenes. This allows for very high flexibility in the architecture and data model of the projects. Nodes can optionally be added to groups. This makes it easy to reach a number of nodes from the code (for example an "enemies" group) to perform grouped actions. [b]Scene tree:[/b] The [SceneTree] contains the active tree of nodes. When a node is added to the scene tree, it receives the NOTIFICATION_ENTER_TREE notification and its [method _enter_tree] callback is triggered. Children nodes are always added [i]after[/i] their parent node, i.e. the [method _enter_tree] callback of a parent node will be triggered before its child's. Once all nodes have been added in the scene tree, they receive the NOTIFICATION_READY notification and their respective [method _ready] callbacks are triggered. For groups of nodes, the [method _ready] callback is called in reverse order, from the children up to the parent nodes. It means that when adding a scene to the scene tree, the following order will be used for the callbacks: [method _enter_tree] of the parent, [method _enter_tree] of the children, [method _ready] of the children and finally [method _ready] of the parent (and that recursively for the whole scene). [b]Processing:[/b] Nodes can be set to the "process" state, so that they receive a callback on each frame requesting them to process (do something). Normal processing (callback [method _process], toggled with [method set_process]) happens as fast as possible and is dependent on the frame rate, so the processing time [i]delta[/i] is variable. Fixed processing (callback [method _fixed_process], toggled with [method set_fixed_process]) happens a fixed amount of times per second (by default 60) and is useful to link itself to the physics. Nodes can also process input events. When set, the [method _input] function will be called for each input that the program receives. In many cases, this can be overkill (unless used for simple projects), and the [method _unhandled_input] function might be preferred; it is called when the input event was not handled by anyone else (typically, GUI [Control] nodes), ensuring that the node only receives the events that were meant for it. To keep track of the scene hierarchy (especially when instancing scenes into other scenes), an "owner" can be set for the node with [method set_owner]. This keeps track of who instanced what. This is mostly useful when writing editors and tools, though. Finally, when a node is freed with [method free] or [method queue_free], it will also free all its children. [b]Networking with nodes:[/b] After connecting to a server (or making one, see [NetworkedMultiplayerENet]) it is possible to use the built-in RPC (remote procedure call) system to easily communicate over the network. By calling [method rpc] with a method name, it will be called locally, and in all connected peers (peers = clients and the server that accepts connections), with behaviour varying depending on the network mode ([method set_network_mode]) on the receiving peer. To identify which [Node] receives the RPC call Godot will use its [NodePath] (make sure node names are the same on all peers).
*/
type Node struct {
	Object
}

func (o *Node) baseClass() string {
	return "Node"
}

/*
   Called during the processing step of the main loop. Processing happens at every frame and as fast as possible, so the [code]delta[/code] time since the previous frame is not constant. It is only called if processing has been enabled with [method set_process]. Corresponds to the NOTIFICATION_PROCESS notification in [method Object._notification].
*/
func (o *Node) X_Process(delta float64) {
	log.Println("Calling Node.X_Process()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(delta)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_process", goArguments, "")

	log.Println("Got return value!")

}

/*
   Called during the fixed processing step of the main loop. Fixed processing means that the frame rate is synced to the physics, i.e. the [code]delta[/code] variable should be constant. It is only called if fixed processing has been enabled with [method set_fixed_process]. Corresponds to the NOTIFICATION_FIXED_PROCESS notification in [method Object._notification].
*/
func (o *Node) X_FixedProcess(delta float64) {
	log.Println("Calling Node.X_FixedProcess()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(delta)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_fixed_process", goArguments, "")

	log.Println("Got return value!")

}

/*
   Called when the node enters the [SceneTree] (e.g. upon instancing, scene changing or after calling [method add_child] in a script). If the node has children, its [method _enter_tree] callback will be called first, and then that of the children. Corresponds to the NOTIFICATION_ENTER_TREE notification in [method Object._notification].
*/
func (o *Node) X_EnterTree() {
	log.Println("Calling Node.X_EnterTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_enter_tree", goArguments, "")

	log.Println("Got return value!")

}

/*
   Called when the node leaves the [SceneTree] (e.g. upon freeing, scene changing or after calling [method remove_child] in a script). If the node has children, its [method _exit_tree] callback will be called last, after all its children have left the tree. Corresponds to the NOTIFICATION_EXIT_TREE notification in [method Object._notification].
*/
func (o *Node) X_ExitTree() {
	log.Println("Calling Node.X_ExitTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_exit_tree", goArguments, "")

	log.Println("Got return value!")

}

/*
   Called when the node is "ready", i.e. when both the node and its children have entered the scene tree. If the node has children, their [method _ready] callback gets triggered first, and the node will receive the ready notification only afterwards. Corresponds to the NOTIFICATION_READY notification in [method Object._notification].
*/
func (o *Node) X_Ready() {
	log.Println("Calling Node.X_Ready()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_ready", goArguments, "")

	log.Println("Got return value!")

}

/*
   Called when there is a change to input devices. Propagated through the node tree until a Node consumes it.
*/
func (o *Node) X_Input(event *InputEvent) {
	log.Println("Calling Node.X_Input()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(event)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Propagated to all nodes when the previous InputEvent is not consumed by any nodes.
*/
func (o *Node) X_UnhandledInput(event *InputEvent) {
	log.Println("Calling Node.X_UnhandledInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(event)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_unhandled_input", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Node) X_UnhandledKeyInput(event *InputEventKey) {
	log.Println("Calling Node.X_UnhandledKeyInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(event)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_unhandled_key_input", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Node) AddChildBelowNode(node *Object, childNode *Object, legibleUniqueName bool) {
	log.Println("Calling Node.AddChildBelowNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(node)
	goArguments[1] = reflect.ValueOf(childNode)
	goArguments[2] = reflect.ValueOf(legibleUniqueName)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_child_below_node", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the name of the [Node]. Name must be unique within parent, and setting an already existing name will cause for the node to be automatically renamed.
*/
func (o *Node) SetName(name string) {
	log.Println("Calling Node.SetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_name", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the name of the node. This name is unique among the siblings (other child nodes from the same parent).
*/
func (o *Node) GetName() string {
	log.Println("Calling Node.GetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Add a child [Node]. Nodes can have as many children as they want, but every child must have a unique name. Children nodes are automatically deleted when the parent node is deleted, so deleting a whole scene is performed by deleting its topmost node. The optional boolean argument enforces creating child nodes with human-readable names, based on the name of the node being instanced instead of its type only.
*/
func (o *Node) AddChild(node *Object, legibleUniqueName bool) {
	log.Println("Calling Node.AddChild()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(node)
	goArguments[1] = reflect.ValueOf(legibleUniqueName)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_child", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove a child [Node]. Node is NOT deleted and will have to be deleted manually.
*/
func (o *Node) RemoveChild(node *Object) {
	log.Println("Calling Node.RemoveChild()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_child", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the amount of child nodes.
*/
func (o *Node) GetChildCount() int64 {
	log.Println("Calling Node.GetChildCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_child_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return an array of references ([Node]) to the child nodes.
*/
func (o *Node) GetChildren() *Array {
	log.Println("Calling Node.GetChildren()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_children", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Return a child node by its index (see [method get_child_count]). This method is often used for iterating all children of a node.
*/
func (o *Node) GetChild(idx int64) *Node {
	log.Println("Calling Node.GetChild()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_child", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*
   Return whether the node that a given [NodePath] points too exists.
*/
func (o *Node) HasNode(path *NodePath) bool {
	log.Println("Calling Node.HasNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_node", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Fetch a node. The [NodePath] must be valid (or else an error will be raised) and can be either the path to child node, a relative path (from the current node to another node), or an absolute path to a node. Note: fetching absolute paths only works when the node is inside the scene tree (see [method is_inside_tree]). [i]Example:[/i] Assume your current node is Character and the following tree: [codeblock] /root /root/Character /root/Character/Sword /root/Character/Backpack/Dagger /root/MyGame /root/Swamp/Alligator /root/Swamp/Mosquito /root/Swamp/Goblin [/codeblock] Possible paths are: [codeblock] get_node("Sword") get_node("Backpack/Dagger") get_node("../Swamp/Alligator") get_node("/root/MyGame") [/codeblock]
*/
func (o *Node) GetNode(path *NodePath) *Node {
	log.Println("Calling Node.GetNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*
   Return the parent node of the current node, or an empty [Node] if the node lacks a parent.
*/
func (o *Node) GetParent() *Node {
	log.Println("Calling Node.GetParent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_parent", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*
   Find a descendant of this node whose name matches [code]mask[/code] as in [method String.match] (i.e. case sensitive, but '*' matches zero or more characters and '?' matches any single character except '.'). Note that it does not match against the full path, just against individual node names.
*/
func (o *Node) FindNode(mask string, recursive bool, owned bool) *Node {
	log.Println("Calling Node.FindNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(mask)
	goArguments[1] = reflect.ValueOf(recursive)
	goArguments[2] = reflect.ValueOf(owned)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "find_node", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*

 */
func (o *Node) HasNodeAndResource(path *NodePath) bool {
	log.Println("Calling Node.HasNodeAndResource()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_node_and_resource", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Node) GetNodeAndResource(path *NodePath) *Array {
	log.Println("Calling Node.GetNodeAndResource()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_and_resource", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Return whether this Node is inside a [SceneTree].
*/
func (o *Node) IsInsideTree() bool {
	log.Println("Calling Node.IsInsideTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_inside_tree", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return [i]true[/i] if the "node" argument is a direct or indirect child of the current node, otherwise return [i]false[/i].
*/
func (o *Node) IsAParentOf(node *Object) bool {
	log.Println("Calling Node.IsAParentOf()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_a_parent_of", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return [i]true[/i] if "node" occurs later in the scene hierarchy than the current node, otherwise return [i]false[/i].
*/
func (o *Node) IsGreaterThan(node *Object) bool {
	log.Println("Calling Node.IsGreaterThan()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_greater_than", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return the absolute path of the current node. This only works if the current node is inside the scene tree (see [method is_inside_tree]).
*/
func (o *Node) GetPath() *NodePath {
	log.Println("Calling Node.GetPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_path", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*
   Return the relative path from the current node to the specified node in "node" argument. Both nodes must be in the same scene, or else the function will fail.
*/
func (o *Node) GetPathTo(node *Object) *NodePath {
	log.Println("Calling Node.GetPathTo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_path_to", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*
   Add a node to a group. Groups are helpers to name and organize a subset of nodes, like for example "enemies" or "collectables". A [Node] can be in any number of groups. Nodes can be assigned a group at any time, but will not be added to it until they are inside the scene tree (see [method is_inside_tree]).
*/
func (o *Node) AddToGroup(group string, persistent bool) {
	log.Println("Calling Node.AddToGroup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(group)
	goArguments[1] = reflect.ValueOf(persistent)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_to_group", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove a node from a group.
*/
func (o *Node) RemoveFromGroup(group string) {
	log.Println("Calling Node.RemoveFromGroup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(group)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_from_group", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether this Node is in the specified group.
*/
func (o *Node) IsInGroup(group string) bool {
	log.Println("Calling Node.IsInGroup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(group)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_in_group", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Move a child node to a different position (order) amongst the other children. Since calls, signals, etc are performed by tree order, changing the order of children nodes may be useful.
*/
func (o *Node) MoveChild(childNode *Object, toPosition int64) {
	log.Println("Calling Node.MoveChild()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(childNode)
	goArguments[1] = reflect.ValueOf(toPosition)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "move_child", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return an array listing the groups that the node is part of.
*/
func (o *Node) GetGroups() *Array {
	log.Println("Calling Node.GetGroups()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_groups", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Move this node to the top of the array of nodes of the parent node. This is often useful on GUIs ([Control]), because their order of drawing fully depends on their order in the tree.
*/
func (o *Node) Raise() {
	log.Println("Calling Node.Raise()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "raise", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the node owner. A node can have any other node as owner (as long as a valid parent, grandparent, etc ascending in the tree). When saving a node (using SceneSaver) all the nodes it owns will be saved with it. This allows to create complex SceneTrees, with instancing and subinstancing.
*/
func (o *Node) SetOwner(owner *Object) {
	log.Println("Calling Node.SetOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(owner)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_owner", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the node owner (see [method set_owner]).
*/
func (o *Node) GetOwner() *Node {
	log.Println("Calling Node.GetOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_owner", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*
   Remove a node and set all its children as children of the parent node (if exists). All even subscriptions that pass by the removed node will be unsubscribed.
*/
func (o *Node) RemoveAndSkip() {
	log.Println("Calling Node.RemoveAndSkip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_and_skip", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the node index, i.e. its position among the siblings of its parent.
*/
func (o *Node) GetIndex() int64 {
	log.Println("Calling Node.GetIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_index", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Print the scene to stdout. Used mainly for debugging purposes.
*/
func (o *Node) PrintTree() {
	log.Println("Calling Node.PrintTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "print_tree", goArguments, "")

	log.Println("Got return value!")

}

/*
   A node can contain a filename. This filename should not be changed by the user, unless writing editors and tools. When a scene is instanced from a file, it topmost node contains the filename from where it was loaded.
*/
func (o *Node) SetFilename(filename string) {
	log.Println("Calling Node.SetFilename()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(filename)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_filename", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return a filename that may be contained by the node. When a scene is instanced from a file, it topmost node contains the filename from where it was loaded (see [method set_filename]).
*/
func (o *Node) GetFilename() string {
	log.Println("Calling Node.GetFilename()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_filename", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Notify the current node and all its children recursively by calling notification() in all of them.
*/
func (o *Node) PropagateNotification(what int64) {
	log.Println("Calling Node.PropagateNotification()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(what)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "propagate_notification", goArguments, "")

	log.Println("Got return value!")

}

/*
   Calls the method (if present) with the arguments given in "args" on this Node and recursively on all children. If the parent_first argument is true then the method will be called on the current [Node] first, then on all children. If it is false then the children will get called first.
*/
func (o *Node) PropagateCall(method string, args *Array, parentFirst bool) {
	log.Println("Calling Node.PropagateCall()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(method)
	goArguments[1] = reflect.ValueOf(args)
	goArguments[2] = reflect.ValueOf(parentFirst)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "propagate_call", goArguments, "")

	log.Println("Got return value!")

}

/*
   Enables or disables node fixed framerate processing. When a node is being processed, it will receive a NOTIFICATION_PROCESS at a fixed (usually 60 fps, check [OS] to change that) interval (and the [method _fixed_process] callback will be called if exists). It is common to check how much time was elapsed since the previous frame by calling [method get_fixed_process_delta_time].
*/
func (o *Node) SetFixedProcess(enable bool) {
	log.Println("Calling Node.SetFixedProcess()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fixed_process", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the time elapsed since the last fixed frame (see [method _fixed_process]). This is always the same in fixed processing unless the frames per second is changed in [OS].
*/
func (o *Node) GetFixedProcessDeltaTime() float64 {
	log.Println("Calling Node.GetFixedProcessDeltaTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fixed_process_delta_time", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return true if fixed processing is enabled (see [method set_fixed_process]).
*/
func (o *Node) IsFixedProcessing() bool {
	log.Println("Calling Node.IsFixedProcessing()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_fixed_processing", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return the time elapsed (in seconds) since the last process callback. This is almost always different each time.
*/
func (o *Node) GetProcessDeltaTime() float64 {
	log.Println("Calling Node.GetProcessDeltaTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_process_delta_time", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Enables or disables node processing. When a node is being processed, it will receive a NOTIFICATION_PROCESS on every drawn frame (and the [method _process] callback will be called if exists). It is common to check how much time was elapsed since the previous frame by calling [method get_process_delta_time].
*/
func (o *Node) SetProcess(enable bool) {
	log.Println("Calling Node.SetProcess()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_process", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether processing is enabled in the current node (see [method set_process]).
*/
func (o *Node) IsProcessing() bool {
	log.Println("Calling Node.IsProcessing()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_processing", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Enable input processing for node. This is not required for GUI controls! It hooks up the node to receive all input (see [method _input]).
*/
func (o *Node) SetProcessInput(enable bool) {
	log.Println("Calling Node.SetProcessInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_process_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if the node is processing input (see [method set_process_input]).
*/
func (o *Node) IsProcessingInput() bool {
	log.Println("Calling Node.IsProcessingInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_processing_input", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Enable unhandled input processing for node. This is not required for GUI controls! It hooks up the node to receive all input that was not previously handled before (usually by a [Control]). (see [method _unhandled_input]).
*/
func (o *Node) SetProcessUnhandledInput(enable bool) {
	log.Println("Calling Node.SetProcessUnhandledInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_process_unhandled_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if the node is processing unhandled input (see [method set_process_unhandled_input]).
*/
func (o *Node) IsProcessingUnhandledInput() bool {
	log.Println("Calling Node.IsProcessingUnhandledInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_processing_unhandled_input", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Node) SetProcessUnhandledKeyInput(enable bool) {
	log.Println("Calling Node.SetProcessUnhandledKeyInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_process_unhandled_key_input", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Node) IsProcessingUnhandledKeyInput() bool {
	log.Println("Calling Node.IsProcessingUnhandledKeyInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_processing_unhandled_key_input", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set pause mode (PAUSE_MODE_*) of this Node.
*/
func (o *Node) SetPauseMode(mode int64) {
	log.Println("Calling Node.SetPauseMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pause_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the pause mode (PAUSE_MODE_*) of this Node.
*/
func (o *Node) GetPauseMode() int64 {
	log.Println("Calling Node.GetPauseMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pause_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return true if the node can process, i.e. whether its pause mode allows processing while the scene tree is paused (see [method set_pause_mode]). Always returns true if the scene tree is not paused, and false if the node is not in the tree. FIXME: Why FAIL_COND?
*/
func (o *Node) CanProcess() bool {
	log.Println("Calling Node.CanProcess()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "can_process", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Node) PrintStrayNodes() {
	log.Println("Calling Node.PrintStrayNodes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "print_stray_nodes", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the order in the node tree branch, i.e. if called by the first child Node, return 0.
*/
func (o *Node) GetPositionInParent() int64 {
	log.Println("Calling Node.GetPositionInParent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_position_in_parent", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Node) SetDisplayFolded(fold bool) {
	log.Println("Calling Node.SetDisplayFolded()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fold)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_display_folded", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Node) IsDisplayedFolded() bool {
	log.Println("Calling Node.IsDisplayedFolded()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_displayed_folded", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Node) SetProcessInternal(enable bool) {
	log.Println("Calling Node.SetProcessInternal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_process_internal", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Node) IsProcessingInternal() bool {
	log.Println("Calling Node.IsProcessingInternal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_processing_internal", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Node) SetFixedProcessInternal(enable bool) {
	log.Println("Calling Node.SetFixedProcessInternal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fixed_process_internal", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Node) IsFixedProcessingInternal() bool {
	log.Println("Calling Node.IsFixedProcessingInternal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_fixed_processing_internal", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return a [SceneTree] that this node is inside.
*/
func (o *Node) GetTree() *SceneTree {
	log.Println("Calling Node.GetTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tree", goArguments, "*SceneTree")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*SceneTree)

	return returnValue

}

/*
   Duplicate the node, returning a new [Node]. You can fine-tune the behavior using the [code]flags[/code], which are based on the DUPLICATE_* constants.
*/
func (o *Node) Duplicate(flags int64) *Node {
	log.Println("Calling Node.Duplicate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flags)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "duplicate", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*
   Replace a node in a scene by a given one. Subscriptions that pass through this node will be lost.
*/
func (o *Node) ReplaceBy(node *Object, keepData bool) {
	log.Println("Calling Node.ReplaceBy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(node)
	goArguments[1] = reflect.ValueOf(keepData)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "replace_by", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Node) SetSceneInstanceLoadPlaceholder(loadPlaceholder bool) {
	log.Println("Calling Node.SetSceneInstanceLoadPlaceholder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(loadPlaceholder)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scene_instance_load_placeholder", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Node) GetSceneInstanceLoadPlaceholder() bool {
	log.Println("Calling Node.GetSceneInstanceLoadPlaceholder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scene_instance_load_placeholder", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Node) GetViewport() *Viewport {
	log.Println("Calling Node.GetViewport()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_viewport", goArguments, "*Viewport")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Viewport)

	return returnValue

}

/*
   Queues a node for deletion at the end of the current frame. When deleted, all of its children nodes will be deleted as well. This method ensures it's safe to delete the node, contrary to [method Object.free]. Use [method Object.is_queued_for_deletion] to know whether a node will be deleted at the end of the frame.
*/
func (o *Node) QueueFree() {
	log.Println("Calling Node.QueueFree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "queue_free", goArguments, "")

	log.Println("Got return value!")

}

/*
   Request that [code]_ready[/code] be called again.
*/
func (o *Node) RequestReady() {
	log.Println("Calling Node.RequestReady()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "request_ready", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Node) SetNetworkMaster(id int64, recursive bool) {
	log.Println("Calling Node.SetNetworkMaster()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(recursive)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_network_master", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Node) GetNetworkMaster() int64 {
	log.Println("Calling Node.GetNetworkMaster()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_network_master", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Node) IsNetworkMaster() bool {
	log.Println("Calling Node.IsNetworkMaster()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_network_master", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Change the method's RPC mode (one of RPC_MODE_* constants).
*/
func (o *Node) RpcConfig(method string, mode int64) {
	log.Println("Calling Node.RpcConfig()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(method)
	goArguments[1] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rpc_config", goArguments, "")

	log.Println("Got return value!")

}

/*
   Change the property's RPC mode (one of RPC_MODE_* constants).
*/
func (o *Node) RsetConfig(property string, mode int64) {
	log.Println("Calling Node.RsetConfig()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(property)
	goArguments[1] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rset_config", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Node) X_SetImportPath(importPath *NodePath) {
	log.Println("Calling Node.X_SetImportPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(importPath)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_import_path", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Node) X_GetImportPath() *NodePath {
	log.Println("Calling Node.X_GetImportPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_import_path", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*
   Send a remote procedure call request to all peers on the network (and locally), optionally sending additional data as arguments. Call request will be received by nodes with the same [NodePath].
*/
func (o *Node) Rpc(method string) *Variant {
	log.Println("Calling Node.Rpc()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "rpc", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Send a [method rpc] using an unreliable protocol.
*/
func (o *Node) RpcUnreliable(method string) *Variant {
	log.Println("Calling Node.RpcUnreliable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "rpc_unreliable", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Send a [method rpc] to a specific peer identified by [i]peer_id[/i].
*/
func (o *Node) RpcId(peerId int64, method string) *Variant {
	log.Println("Calling Node.RpcId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(peerId)
	goArguments[1] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "rpc_id", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Send a [method rpc] to a specific peer identified by [i]peer_id[/i] using an unreliable protocol.
*/
func (o *Node) RpcUnreliableId(peerId int64, method string) *Variant {
	log.Println("Calling Node.RpcUnreliableId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(peerId)
	goArguments[1] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "rpc_unreliable_id", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Remotely change property's value on other peers (and locally).
*/
func (o *Node) Rset(property string, value *Variant) {
	log.Println("Calling Node.Rset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(property)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remotely change property's value on a specific peer identified by [i]peer_id[/i].
*/
func (o *Node) RsetId(peerId int64, property string, value *Variant) {
	log.Println("Calling Node.RsetId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(peerId)
	goArguments[1] = reflect.ValueOf(property)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rset_id", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remotely change property's value on other peers (and locally) using an unreliable protocol.
*/
func (o *Node) RsetUnreliable(property string, value *Variant) {
	log.Println("Calling Node.RsetUnreliable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(property)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rset_unreliable", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remotely change property's value on a specific peer identified by [i]peer_id[/i] using an unreliable protocol.
*/
func (o *Node) RsetUnreliableId(peerId int64, property string, value *Variant) {
	log.Println("Calling Node.RsetUnreliableId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(peerId)
	goArguments[1] = reflect.ValueOf(property)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rset_unreliable_id", goArguments, "")

	log.Println("Got return value!")

}

/*
   NodeImplementer is an interface for Node objects.
*/
type NodeImplementer interface {
	Class
}

/*
   Turning on the option [b]Load As Placeholder[/b] for an instanced scene in the editor causes it to be replaced by an InstacePlaceholder when running the game. This makes it possible to delay actually loading the scene until calling [method replace_by_instance]. This is useful to avoid loading large scenes all at once by loading parts of it selectively. The InstancePlaceholder does not have a transform. This causes any child nodes to be positioned relatively to the Viewport from point (0,0), rather than their parent as displayed in the editor. Replacing the placeholder with a scene with a transform will transform children relatively to their parent again.
*/
type InstancePlaceholder struct {
	Node
}

func (o *InstancePlaceholder) baseClass() string {
	return "InstancePlaceholder"
}

/*

 */
func (o *InstancePlaceholder) GetStoredValues(withOrder bool) *Dictionary {
	log.Println("Calling InstancePlaceholder.GetStoredValues()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(withOrder)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stored_values", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
   Replace this placeholder by the scene handed as an argument, or the original scene if no argument is given. As for all resources, the scene is loaded only if it's not loaded already. By manually loading the scene beforehand, delays caused by this function can be avoided.
*/
func (o *InstancePlaceholder) ReplaceByInstance(customScene *PackedScene) {
	log.Println("Calling InstancePlaceholder.ReplaceByInstance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(customScene)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "replace_by_instance", goArguments, "")

	log.Println("Got return value!")

}

/*
   Retrieve the path to the [PackedScene] resource file that is loaded by default when calling [method replace_by_instance].
*/
func (o *InstancePlaceholder) GetInstancePath() string {
	log.Println("Calling InstancePlaceholder.GetInstancePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_instance_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   InstancePlaceholderImplementer is an interface for InstancePlaceholder objects.
*/
type InstancePlaceholderImplementer interface {
	Class
}

/*
   A Viewport creates a different view into the screen, or a sub-view inside another viewport. Children 2D Nodes will display on it, and children Camera 3D nodes will render on it too. Optionally, a viewport can have its own 2D or 3D world, so they don't share what they draw with other viewports. If a viewport is a child of a [Control], it will automatically take up its same rect and position, otherwise they must be set manually. Viewports can also choose to be audio listeners, so they generate positional audio depending on a 2D or 3D camera child of it. Also, viewports can be assigned to different screens in case the devices have multiple screens. Finally, viewports can also behave as render targets, in which case they will not be visible unless the associated texture is used to draw.
*/
type Viewport struct {
	Node
}

func (o *Viewport) baseClass() string {
	return "Viewport"
}

/*
   If true this viewport will be bound to our ARVR Server. If this is our main Godot viewport our AR/VR output will be displayed on screen. If output is redirected to an HMD we'll see the output of just one of the eyes without any distortion applied else we'll see the stereo buffer with distortion applied if applicable If this is an extra viewport output will only work if redirection to an HMD is supported by the interface. The render target will allow you to use the undistorted output for the right eye in the display.
*/
func (o *Viewport) SetUseArvr(use bool) {
	log.Println("Calling Viewport.SetUseArvr()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(use)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_arvr", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether this viewport is using our ARVR Server
*/
func (o *Viewport) UseArvr() bool {
	log.Println("Calling Viewport.UseArvr()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "use_arvr", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the size of the viewport.
*/
func (o *Viewport) SetSize(size *Vector2) {
	log.Println("Calling Viewport.SetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_size", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the viewport rect. If the viewport is child of a control, it will use the same rect as the parent. Otherwise, if the rect is empty, the viewport will use all the allowed space.
*/
func (o *Viewport) GetSize() *Vector2 {
	log.Println("Calling Viewport.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Viewport) SetWorld2D(world2D *World2D) {
	log.Println("Calling Viewport.SetWorld2D()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(world2D)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_world_2d", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the 2D world of the viewport.
*/
func (o *Viewport) GetWorld2D() *World2D {
	log.Println("Calling Viewport.GetWorld2D()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_world_2d", goArguments, "*World2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*World2D)

	return returnValue

}

/*
   Return the 2D world of the viewport.
*/
func (o *Viewport) FindWorld2D() *World2D {
	log.Println("Calling Viewport.FindWorld2D()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "find_world_2d", goArguments, "*World2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*World2D)

	return returnValue

}

/*
   Change the 3D world of the viewport.
*/
func (o *Viewport) SetWorld(world *World) {
	log.Println("Calling Viewport.SetWorld()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(world)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_world", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the 3D world of the viewport.
*/
func (o *Viewport) GetWorld() *World {
	log.Println("Calling Viewport.GetWorld()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_world", goArguments, "*World")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*World)

	return returnValue

}

/*
   Return the 3D world of the viewport, or if no such present, the one of the parent viewport.
*/
func (o *Viewport) FindWorld() *World {
	log.Println("Calling Viewport.FindWorld()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "find_world", goArguments, "*World")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*World)

	return returnValue

}

/*
   Set the canvas transform of the viewport, useful for changing the on-screen positions of all child [CanvasItem]\ s. This is relative to the global canvas transform of the viewport.
*/
func (o *Viewport) SetCanvasTransform(xform *Transform2D) {
	log.Println("Calling Viewport.SetCanvasTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(xform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_canvas_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the canvas transform of the viewport.
*/
func (o *Viewport) GetCanvasTransform() *Transform2D {
	log.Println("Calling Viewport.GetCanvasTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_canvas_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Set the global canvas transform of the viewport. The canvas transform is relative to this.
*/
func (o *Viewport) SetGlobalCanvasTransform(xform *Transform2D) {
	log.Println("Calling Viewport.SetGlobalCanvasTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(xform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_global_canvas_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the global canvas transform of the viewport.
*/
func (o *Viewport) GetGlobalCanvasTransform() *Transform2D {
	log.Println("Calling Viewport.GetGlobalCanvasTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_global_canvas_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Get the total transform of the viewport.
*/
func (o *Viewport) GetFinalTransform() *Transform2D {
	log.Println("Calling Viewport.GetFinalTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_final_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Return the final, visible rect in global screen coordinates.
*/
func (o *Viewport) GetVisibleRect() *Rect2 {
	log.Println("Calling Viewport.GetVisibleRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_visible_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   If this viewport is a child of another viewport, keep the previously drawn background visible.
*/
func (o *Viewport) SetTransparentBackground(enable bool) {
	log.Println("Calling Viewport.SetTransparentBackground()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_transparent_background", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether the viewport lets whatever is behind it to show.
*/
func (o *Viewport) HasTransparentBackground() bool {
	log.Println("Calling Viewport.HasTransparentBackground()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_transparent_background", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *Viewport) X_ParentVisibilityChanged() {
	log.Println("Calling Viewport.X_ParentVisibilityChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_parent_visibility_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Viewport) X_ParentResized() {
	log.Println("Calling Viewport.X_ParentResized()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_parent_resized", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Viewport) X_VpInput(arg0 *InputEvent) {
	log.Println("Calling Viewport.X_VpInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_vp_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Viewport) X_VpInputText(text string) {
	log.Println("Calling Viewport.X_VpInputText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_vp_input_text", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Viewport) X_VpUnhandledInput(arg0 *InputEvent) {
	log.Println("Calling Viewport.X_VpUnhandledInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_vp_unhandled_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the size override of the viewport. If the enable parameter is true, it would use the override, otherwise it would use the default size. If the size parameter is equal to [code](-1, -1)[/code], it won't update the size.
*/
func (o *Viewport) SetSizeOverride(enable bool, size *Vector2, margin *Vector2) {
	log.Println("Calling Viewport.SetSizeOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(enable)
	goArguments[1] = reflect.ValueOf(size)
	goArguments[2] = reflect.ValueOf(margin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_size_override", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the size override set with [method set_size_override].
*/
func (o *Viewport) GetSizeOverride() *Vector2 {
	log.Println("Calling Viewport.GetSizeOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size_override", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Get the enabled status of the size override set with [method set_size_override].
*/
func (o *Viewport) IsSizeOverrideEnabled() bool {
	log.Println("Calling Viewport.IsSizeOverrideEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_size_override_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set whether the size override affects stretch as well.
*/
func (o *Viewport) SetSizeOverrideStretch(enabled bool) {
	log.Println("Calling Viewport.SetSizeOverrideStretch()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_size_override_stretch", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the enabled status of the size strech override set with [method set_size_override_stretch].
*/
func (o *Viewport) IsSizeOverrideStretchEnabled() bool {
	log.Println("Calling Viewport.IsSizeOverrideStretchEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_size_override_stretch_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set whether the viewport is flipped on the Y axis.
*/
func (o *Viewport) SetVflip(enable bool) {
	log.Println("Calling Viewport.SetVflip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vflip", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether the render target is flipped on the Y axis.
*/
func (o *Viewport) GetVflip() bool {
	log.Println("Calling Viewport.GetVflip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vflip", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Viewport) SetClearMode(mode int64) {
	log.Println("Calling Viewport.SetClearMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_clear_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Viewport) GetClearMode() int64 {
	log.Println("Calling Viewport.GetClearMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_clear_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set when the render target would be updated, using the [code]UPDATE_*[/code] constants
*/
func (o *Viewport) SetUpdateMode(mode int64) {
	log.Println("Calling Viewport.SetUpdateMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_update_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get when the viewport would be updated, will be one of the [code]UPDATE_*[/code] constants.
*/
func (o *Viewport) GetUpdateMode() int64 {
	log.Println("Calling Viewport.GetUpdateMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_update_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Viewport) SetMsaa(msaa int64) {
	log.Println("Calling Viewport.SetMsaa()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(msaa)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_msaa", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Viewport) GetMsaa() int64 {
	log.Println("Calling Viewport.GetMsaa()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_msaa", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Viewport) SetHdr(enable bool) {
	log.Println("Calling Viewport.SetHdr()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_hdr", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get whether the rendered texture has filters enabled.
*/
func (o *Viewport) GetHdr() bool {
	log.Println("Calling Viewport.GetHdr()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_hdr", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Viewport) SetUsage(usage int64) {
	log.Println("Calling Viewport.SetUsage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(usage)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_usage", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Viewport) GetUsage() int64 {
	log.Println("Calling Viewport.GetUsage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_usage", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Viewport) SetDebugDraw(debugDraw int64) {
	log.Println("Calling Viewport.SetDebugDraw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(debugDraw)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_debug_draw", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Viewport) GetDebugDraw() int64 {
	log.Println("Calling Viewport.GetDebugDraw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_debug_draw", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Viewport) GetRenderInfo(info int64) int64 {
	log.Println("Calling Viewport.GetRenderInfo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(info)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_render_info", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the viewport's texture, for use with various objects that you want to texture with the viewport.
*/
func (o *Viewport) GetTexture() *ViewportTexture {
	log.Println("Calling Viewport.GetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture", goArguments, "*ViewportTexture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*ViewportTexture)

	return returnValue

}

/*
   Enable/disable picking for all physics objects inside the viewport.
*/
func (o *Viewport) SetPhysicsObjectPicking(enable bool) {
	log.Println("Calling Viewport.SetPhysicsObjectPicking()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_physics_object_picking", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get whether picking for all physics objects inside the viewport is enabled.
*/
func (o *Viewport) GetPhysicsObjectPicking() bool {
	log.Println("Calling Viewport.GetPhysicsObjectPicking()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_physics_object_picking", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Get the viewport RID from the [VisualServer].
*/
func (o *Viewport) GetViewportRid() *RID {
	log.Println("Calling Viewport.GetViewportRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_viewport_rid", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *Viewport) Input(localEvent *InputEvent) {
	log.Println("Calling Viewport.Input()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(localEvent)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "input", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Viewport) UnhandledInput(localEvent *InputEvent) {
	log.Println("Calling Viewport.UnhandledInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(localEvent)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "unhandled_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Force update of the 2D and 3D worlds.
*/
func (o *Viewport) UpdateWorlds() {
	log.Println("Calling Viewport.UpdateWorlds()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "update_worlds", goArguments, "")

	log.Println("Got return value!")

}

/*
   Make the viewport use a world separate from the parent viewport's world.
*/
func (o *Viewport) SetUseOwnWorld(enable bool) {
	log.Println("Calling Viewport.SetUseOwnWorld()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_own_world", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether the viewport is using a world separate from the parent viewport's world.
*/
func (o *Viewport) IsUsingOwnWorld() bool {
	log.Println("Calling Viewport.IsUsingOwnWorld()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_using_own_world", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return the active 3D camera.
*/
func (o *Viewport) GetCamera() *Camera {
	log.Println("Calling Viewport.GetCamera()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_camera", goArguments, "*Camera")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Camera)

	return returnValue

}

/*
   Makes the viewport send sounds to the speakers.
*/
func (o *Viewport) SetAsAudioListener(enable bool) {
	log.Println("Calling Viewport.SetAsAudioListener()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_as_audio_listener", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether the viewport sends sounds to the speakers.
*/
func (o *Viewport) IsAudioListener() bool {
	log.Println("Calling Viewport.IsAudioListener()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_audio_listener", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Makes the viewport send sounds from 2D emitters to the speakers.
*/
func (o *Viewport) SetAsAudioListener2D(enable bool) {
	log.Println("Calling Viewport.SetAsAudioListener2D()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_as_audio_listener_2d", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether the viewport sends soundsfrom 2D emitters to the speakers.
*/
func (o *Viewport) IsAudioListener2D() bool {
	log.Println("Calling Viewport.IsAudioListener2D()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_audio_listener_2d", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Viewport) SetAttachToScreenRect(rect *Rect2) {
	log.Println("Calling Viewport.SetAttachToScreenRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rect)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_attach_to_screen_rect", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the mouse position, relative to the viewport.
*/
func (o *Viewport) GetMousePosition() *Vector2 {
	log.Println("Calling Viewport.GetMousePosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mouse_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Warp the mouse to a position, relative to the viewport.
*/
func (o *Viewport) WarpMouse(toPosition *Vector2) {
	log.Println("Calling Viewport.WarpMouse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toPosition)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "warp_mouse", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returs whether there are shown modals on-screen.
*/
func (o *Viewport) GuiHasModalStack() bool {
	log.Println("Calling Viewport.GuiHasModalStack()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "gui_has_modal_stack", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returs the drag data from the GUI, that was previously returned by [method Control.get_drag_data].
*/
func (o *Viewport) GuiGetDragData() *Variant {
	log.Println("Calling Viewport.GuiGetDragData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "gui_get_drag_data", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Set whether input to the viewport is disabled.
*/
func (o *Viewport) SetDisableInput(disable bool) {
	log.Println("Calling Viewport.SetDisableInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(disable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_disable_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether input to the viewport is disabled.
*/
func (o *Viewport) IsInputDisabled() bool {
	log.Println("Calling Viewport.IsInputDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_input_disabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Viewport) SetDisable3D(disable bool) {
	log.Println("Calling Viewport.SetDisable3D()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(disable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_disable_3d", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Viewport) Is3DDisabled() bool {
	log.Println("Calling Viewport.Is3DDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_3d_disabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *Viewport) X_GuiShowTooltip() {
	log.Println("Calling Viewport.X_GuiShowTooltip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_gui_show_tooltip", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Viewport) X_GuiRemoveFocus() {
	log.Println("Calling Viewport.X_GuiRemoveFocus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_gui_remove_focus", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Viewport) SetShadowAtlasSize(size int64) {
	log.Println("Calling Viewport.SetShadowAtlasSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_atlas_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Viewport) GetShadowAtlasSize() int64 {
	log.Println("Calling Viewport.GetShadowAtlasSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_atlas_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Viewport) SetSnapControlsToPixels(enabled bool) {
	log.Println("Calling Viewport.SetSnapControlsToPixels()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_snap_controls_to_pixels", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Viewport) IsSnapControlsToPixelsEnabled() bool {
	log.Println("Calling Viewport.IsSnapControlsToPixelsEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_snap_controls_to_pixels_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Viewport) SetShadowAtlasQuadrantSubdiv(quadrant int64, subdiv int64) {
	log.Println("Calling Viewport.SetShadowAtlasQuadrantSubdiv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(quadrant)
	goArguments[1] = reflect.ValueOf(subdiv)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_atlas_quadrant_subdiv", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Viewport) GetShadowAtlasQuadrantSubdiv(quadrant int64) int64 {
	log.Println("Calling Viewport.GetShadowAtlasQuadrantSubdiv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(quadrant)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_atlas_quadrant_subdiv", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   ViewportImplementer is an interface for Viewport objects.
*/
type ViewportImplementer interface {
	Class
}

/*
   Class that has everything pertaining to a world. A physics space, a visual scenario and a sound space. Spatial nodes register their resources into the current world.
*/
type World struct {
	Resource
}

func (o *World) baseClass() string {
	return "World"
}

/*

 */
func (o *World) GetSpace() *RID {
	log.Println("Calling World.GetSpace()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_space", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *World) GetScenario() *RID {
	log.Println("Calling World.GetScenario()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scenario", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *World) SetEnvironment(env *Environment) {
	log.Println("Calling World.SetEnvironment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(env)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_environment", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *World) GetEnvironment() *Environment {
	log.Println("Calling World.GetEnvironment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_environment", goArguments, "*Environment")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Environment)

	return returnValue

}

/*

 */
func (o *World) SetFallbackEnvironment(env *Environment) {
	log.Println("Calling World.SetFallbackEnvironment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(env)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fallback_environment", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *World) GetFallbackEnvironment() *Environment {
	log.Println("Calling World.GetFallbackEnvironment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fallback_environment", goArguments, "*Environment")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Environment)

	return returnValue

}

/*

 */
func (o *World) GetDirectSpaceState() *PhysicsDirectSpaceState {
	log.Println("Calling World.GetDirectSpaceState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_direct_space_state", goArguments, "*PhysicsDirectSpaceState")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PhysicsDirectSpaceState)

	return returnValue

}

/*
   WorldImplementer is an interface for World objects.
*/
type WorldImplementer interface {
	Class
}

/*

 */
type ViewportTexture struct {
	Texture
}

func (o *ViewportTexture) baseClass() string {
	return "ViewportTexture"
}

/*

 */
func (o *ViewportTexture) SetViewportPathInScene(path *NodePath) {
	log.Println("Calling ViewportTexture.SetViewportPathInScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_viewport_path_in_scene", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ViewportTexture) GetViewportPathInScene() *NodePath {
	log.Println("Calling ViewportTexture.GetViewportPathInScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_viewport_path_in_scene", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*
   ViewportTextureImplementer is an interface for ViewportTexture objects.
*/
type ViewportTextureImplementer interface {
	Class
}

/*
   A Node with the ability to send HTTP requests. Uses a [HTTPClient] internally, supports HTTPS. Can be used to make HTTP requests or download files via HTTP.
*/
type HTTPRequest struct {
	Node
}

func (o *HTTPRequest) baseClass() string {
	return "HTTPRequest"
}

/*

 */
func (o *HTTPRequest) Request(url string, customHeaders *PoolStringArray, sslValidateDomain bool, method int64, requestData string) int64 {
	log.Println("Calling HTTPRequest.Request()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(url)
	goArguments[1] = reflect.ValueOf(customHeaders)
	goArguments[2] = reflect.ValueOf(sslValidateDomain)
	goArguments[3] = reflect.ValueOf(method)
	goArguments[4] = reflect.ValueOf(requestData)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "request", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Cancel the current request.
*/
func (o *HTTPRequest) CancelRequest() {
	log.Println("Calling HTTPRequest.CancelRequest()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "cancel_request", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current status of the underlying [HTTPClient].
*/
func (o *HTTPRequest) GetHttpClientStatus() int64 {
	log.Println("Calling HTTPRequest.GetHttpClientStatus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_http_client_status", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Make this HTTPRequest use threads.
*/
func (o *HTTPRequest) SetUseThreads(enable bool) {
	log.Println("Calling HTTPRequest.SetUseThreads()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_threads", goArguments, "")

	log.Println("Got return value!")

}

/*
   Whether this request is using threads.
*/
func (o *HTTPRequest) IsUsingThreads() bool {
	log.Println("Calling HTTPRequest.IsUsingThreads()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_using_threads", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the response body size limit.
*/
func (o *HTTPRequest) SetBodySizeLimit(bytes int64) {
	log.Println("Calling HTTPRequest.SetBodySizeLimit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bytes)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_body_size_limit", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return current body size limit.
*/
func (o *HTTPRequest) GetBodySizeLimit() int64 {
	log.Println("Calling HTTPRequest.GetBodySizeLimit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_body_size_limit", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the maximum amount of redirects the request will follow.
*/
func (o *HTTPRequest) SetMaxRedirects(amount int64) {
	log.Println("Calling HTTPRequest.SetMaxRedirects()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_redirects", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the maximum amount of redirects that will be followed.
*/
func (o *HTTPRequest) GetMaxRedirects() int64 {
	log.Println("Calling HTTPRequest.GetMaxRedirects()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_max_redirects", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the file to download into. Outputs the response body into the file.
*/
func (o *HTTPRequest) SetDownloadFile(path string) {
	log.Println("Calling HTTPRequest.SetDownloadFile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_download_file", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the file this request will download into.
*/
func (o *HTTPRequest) GetDownloadFile() string {
	log.Println("Calling HTTPRequest.GetDownloadFile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_download_file", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the amount of bytes this HTTPRequest downloaded.
*/
func (o *HTTPRequest) GetDownloadedBytes() int64 {
	log.Println("Calling HTTPRequest.GetDownloadedBytes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_downloaded_bytes", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the response body length.
*/
func (o *HTTPRequest) GetBodySize() int64 {
	log.Println("Calling HTTPRequest.GetBodySize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_body_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *HTTPRequest) X_RedirectRequest(arg0 string) {
	log.Println("Calling HTTPRequest.X_RedirectRequest()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_redirect_request", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *HTTPRequest) X_RequestDone(arg0 int64, arg1 int64, arg2 *PoolStringArray, arg3 *PoolByteArray) {
	log.Println("Calling HTTPRequest.X_RequestDone()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(arg0)
	goArguments[1] = reflect.ValueOf(arg1)
	goArguments[2] = reflect.ValueOf(arg2)
	goArguments[3] = reflect.ValueOf(arg3)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_request_done", goArguments, "")

	log.Println("Got return value!")

}

/*
   HTTPRequestImplementer is an interface for HTTPRequest objects.
*/
type HTTPRequestImplementer interface {
	Class
}

/*
   Counts down a specified interval and emits a signal on reaching 0. Can be set to repeat or "one shot" mode.
*/
type Timer struct {
	Node
}

func (o *Timer) baseClass() string {
	return "Timer"
}

/*
   Set wait time in seconds. When the time is over, it will emit the timeout signal.
*/
func (o *Timer) SetWaitTime(timeSec float64) {
	log.Println("Calling Timer.SetWaitTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(timeSec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_wait_time", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the wait time in seconds.
*/
func (o *Timer) GetWaitTime() float64 {
	log.Println("Calling Timer.GetWaitTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_wait_time", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set as one-shot. If enabled, the timer will stop after timeout, otherwise it will automatically restart.
*/
func (o *Timer) SetOneShot(enable bool) {
	log.Println("Calling Timer.SetOneShot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_one_shot", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if configured as one-shot.
*/
func (o *Timer) IsOneShot() bool {
	log.Println("Calling Timer.IsOneShot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_one_shot", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set to automatically start when entering the scene.
*/
func (o *Timer) SetAutostart(enable bool) {
	log.Println("Calling Timer.SetAutostart()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_autostart", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if set to automatically start when entering the scene.
*/
func (o *Timer) HasAutostart() bool {
	log.Println("Calling Timer.HasAutostart()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_autostart", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Start the Timer.
*/
func (o *Timer) Start() {
	log.Println("Calling Timer.Start()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "start", goArguments, "")

	log.Println("Got return value!")

}

/*
   Stop (cancel) the Timer.
*/
func (o *Timer) Stop() {
	log.Println("Calling Timer.Stop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "stop", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether the timer is paused or not. A paused timer will be inactive until it is unpaused again.
*/
func (o *Timer) SetPaused(paused bool) {
	log.Println("Calling Timer.SetPaused()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(paused)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_paused", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return if the timer is paused or not.
*/
func (o *Timer) IsPaused() bool {
	log.Println("Calling Timer.IsPaused()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_paused", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Timer) IsStopped() bool {
	log.Println("Calling Timer.IsStopped()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_stopped", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return the time left for timeout in seconds if the timer is active, 0 otherwise.
*/
func (o *Timer) GetTimeLeft() float64 {
	log.Println("Calling Timer.GetTimeLeft()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_time_left", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the timer's processing mode (fixed or idle, use TIMER_PROCESS_* constants as argument).
*/
func (o *Timer) SetTimerProcessMode(mode int64) {
	log.Println("Calling Timer.SetTimerProcessMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_timer_process_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the timer's processing mode.
*/
func (o *Timer) GetTimerProcessMode() int64 {
	log.Println("Calling Timer.GetTimerProcessMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_timer_process_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   TimerImplementer is an interface for Timer objects.
*/
type TimerImplementer interface {
	Class
}

/*
   Canvas drawing layer. [CanvasItem] nodes that are direct or indirect children of a [CanvasLayer] will be drawn in that layer. The layer is a numeric index that defines the draw order. The default 2D scene renders with index 0, so a [CanvasLayer] with index -1 will be drawn below, and one with index 1 will be drawn above. This is very useful for HUDs (in layer 1+ or above), or backgrounds (in layer -1 or below).
*/
type CanvasLayer struct {
	Node
}

func (o *CanvasLayer) baseClass() string {
	return "CanvasLayer"
}

/*
   Set the layer index, determines the draw order, a lower value will be below a higher one.
*/
func (o *CanvasLayer) SetLayer(layer int64) {
	log.Println("Calling CanvasLayer.SetLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_layer", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the layer index, determines the draw order, a lower value will be below a higher one.
*/
func (o *CanvasLayer) GetLayer() int64 {
	log.Println("Calling CanvasLayer.GetLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_layer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the base transform for this layer.
*/
func (o *CanvasLayer) SetTransform(transform *Transform2D) {
	log.Println("Calling CanvasLayer.SetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the base transform for this layer.
*/
func (o *CanvasLayer) GetTransform() *Transform2D {
	log.Println("Calling CanvasLayer.GetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Set the base offset for this layer (helper).
*/
func (o *CanvasLayer) SetOffset(offset *Vector2) {
	log.Println("Calling CanvasLayer.SetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the base offset for this layer (helper).
*/
func (o *CanvasLayer) GetOffset() *Vector2 {
	log.Println("Calling CanvasLayer.GetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set the base rotation for this layer in radians (helper).
*/
func (o *CanvasLayer) SetRotation(radians float64) {
	log.Println("Calling CanvasLayer.SetRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radians)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rotation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the base rotation for this layer in radians (helper).
*/
func (o *CanvasLayer) GetRotation() float64 {
	log.Println("Calling CanvasLayer.GetRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rotation", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the base rotation for this layer in degrees (helper).
*/
func (o *CanvasLayer) SetRotationd(degrees float64) {
	log.Println("Calling CanvasLayer.SetRotationd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rotationd", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the base rotation for this layer in degrees.
*/
func (o *CanvasLayer) GetRotationd() float64 {
	log.Println("Calling CanvasLayer.GetRotationd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rotationd", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Undocumented
*/
func (o *CanvasLayer) X_SetRotationd(degrees float64) {
	log.Println("Calling CanvasLayer.X_SetRotationd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_rotationd", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *CanvasLayer) X_GetRotationd() float64 {
	log.Println("Calling CanvasLayer.X_GetRotationd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_rotationd", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the base scale for this layer (helper).
*/
func (o *CanvasLayer) SetScale(scale *Vector2) {
	log.Println("Calling CanvasLayer.SetScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the base scale for this layer (helper).
*/
func (o *CanvasLayer) GetScale() *Vector2 {
	log.Println("Calling CanvasLayer.GetScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scale", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *CanvasLayer) SetCustomViewport(viewport *Object) {
	log.Println("Calling CanvasLayer.SetCustomViewport()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(viewport)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_viewport", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CanvasLayer) GetCustomViewport() *Node {
	log.Println("Calling CanvasLayer.GetCustomViewport()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_custom_viewport", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*
   Return the [World2D] used by this layer.
*/
func (o *CanvasLayer) GetWorld2D() *World2D {
	log.Println("Calling CanvasLayer.GetWorld2D()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_world_2d", goArguments, "*World2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*World2D)

	return returnValue

}

/*
   CanvasLayerImplementer is an interface for CanvasLayer objects.
*/
type CanvasLayerImplementer interface {
	Class
}

/*
   Base class of anything 2D. Canvas items are laid out in a tree and children inherit and extend the transform of their parent. CanvasItem is extended by [Control], for anything GUI related, and by [Node2D] for anything 2D engine related. Any CanvasItem can draw. For this, the "update" function must be called, then NOTIFICATION_DRAW will be received on idle time to request redraw. Because of this, canvas items don't need to be redraw on every frame, improving the performance significantly. Several functions for drawing on the CanvasItem are provided (see draw_* functions). They can only be used inside the notification, signal or _draw() overrides function, though. Canvas items are draw in tree order. By default, children are on top of their parents so a root CanvasItem will be drawn behind everything (this can be changed per item though). Canvas items can also be hidden (hiding also their subtree). They provide many means for changing standard parameters such as opacity (for it and the subtree) and self opacity, blend mode. Ultimately, a transform notification can be requested, which will notify the node that its global position changed in case the parent tree changed.
*/
type CanvasItem struct {
	Node
}

func (o *CanvasItem) baseClass() string {
	return "CanvasItem"
}

/*
   Called (if exists) to draw the canvas item.
*/
func (o *CanvasItem) X_Draw() {
	log.Println("Calling CanvasItem.X_Draw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_draw", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *CanvasItem) X_ToplevelRaiseSelf() {
	log.Println("Calling CanvasItem.X_ToplevelRaiseSelf()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_toplevel_raise_self", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *CanvasItem) X_UpdateCallback() {
	log.Println("Calling CanvasItem.X_UpdateCallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_update_callback", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the transform state of this CanvasItem. For [Node2D], this is an [Array] with (in order) a [Vector2] for position, a float for rotation (radians) and another [Vector2] for scale. For [Control] this is a [Rect2] with the position and size.
*/
func (o *CanvasItem) EditSetState(state *Variant) {
	log.Println("Calling CanvasItem.EditSetState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(state)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "edit_set_state", goArguments, "")

	log.Println("Got return value!")

}

/*
   Used for editing, returns an opaque value representing the transform state.
*/
func (o *CanvasItem) EditGetState() *Variant {
	log.Println("Calling CanvasItem.EditGetState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "edit_get_state", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *CanvasItem) EditSetRect(rect *Rect2) {
	log.Println("Calling CanvasItem.EditSetRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rect)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "edit_set_rect", goArguments, "")

	log.Println("Got return value!")

}

/*
   Used for editing, handle rotation.
*/
func (o *CanvasItem) EditRotate(degrees float64) {
	log.Println("Calling CanvasItem.EditRotate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "edit_rotate", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return a rect containing the editable boundaries of the item.
*/
func (o *CanvasItem) GetItemRect() *Rect2 {
	log.Println("Calling CanvasItem.GetItemRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Get a [Rect2] with the boundaries of this item and its children.
*/
func (o *CanvasItem) GetItemAndChildrenRect() *Rect2 {
	log.Println("Calling CanvasItem.GetItemAndChildrenRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_and_children_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Return the canvas item RID used by [VisualServer] for this item.
*/
func (o *CanvasItem) GetCanvasItem() *RID {
	log.Println("Calling CanvasItem.GetCanvasItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_canvas_item", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Set whether this item should be visible or not. Note that a hidden CanvasItem will make all children hidden too, so no matter what is set here this item won't be shown if its parent or grandparents nodes are hidden.
*/
func (o *CanvasItem) SetVisible(visible bool) {
	log.Println("Calling CanvasItem.SetVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(visible)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_visible", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if this CanvasItem is visible. It may be invisible because itself or a parent canvas item is hidden.
*/
func (o *CanvasItem) IsVisible() bool {
	log.Println("Calling CanvasItem.IsVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_visible", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *CanvasItem) IsVisibleInTree() bool {
	log.Println("Calling CanvasItem.IsVisibleInTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_visible_in_tree", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Show the CanvasItem currently hidden.
*/
func (o *CanvasItem) Show() {
	log.Println("Calling CanvasItem.Show()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "show", goArguments, "")

	log.Println("Got return value!")

}

/*
   Hide the CanvasItem currently visible.
*/
func (o *CanvasItem) Hide() {
	log.Println("Calling CanvasItem.Hide()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "hide", goArguments, "")

	log.Println("Got return value!")

}

/*
   Queue the CanvasItem for update. [code]NOTIFICATION_DRAW[/code] will be called on idle time to request redraw.
*/
func (o *CanvasItem) Update() {
	log.Println("Calling CanvasItem.Update()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "update", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set as top level. This means that it will not inherit transform from parent canvas items.
*/
func (o *CanvasItem) SetAsToplevel(enable bool) {
	log.Println("Calling CanvasItem.SetAsToplevel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_as_toplevel", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return if set as toplevel. See [method set_as_toplevel].
*/
func (o *CanvasItem) IsSetAsToplevel() bool {
	log.Println("Calling CanvasItem.IsSetAsToplevel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_set_as_toplevel", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the ligtht mask number of this item.
*/
func (o *CanvasItem) SetLightMask(lightMask int64) {
	log.Println("Calling CanvasItem.SetLightMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(lightMask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_light_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get this item's light mask number.
*/
func (o *CanvasItem) GetLightMask() int64 {
	log.Println("Calling CanvasItem.GetLightMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_light_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the modulate of the CanvasItem. This [i]affects[/i] the modulation of children items.
*/
func (o *CanvasItem) SetModulate(modulate *Color) {
	log.Println("Calling CanvasItem.SetModulate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(modulate)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_modulate", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the modulate of the CanvasItem, which affects children items too.
*/
func (o *CanvasItem) GetModulate() *Color {
	log.Println("Calling CanvasItem.GetModulate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_modulate", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Set the self-modulate of the CanvasItem. This does not affect the modulation of children items.
*/
func (o *CanvasItem) SetSelfModulate(selfModulate *Color) {
	log.Println("Calling CanvasItem.SetSelfModulate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(selfModulate)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_self_modulate", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the self-modulate of the CanvasItem.
*/
func (o *CanvasItem) GetSelfModulate() *Color {
	log.Println("Calling CanvasItem.GetSelfModulate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_self_modulate", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Set whether the canvas item is drawn behind its parent.
*/
func (o *CanvasItem) SetDrawBehindParent(enable bool) {
	log.Println("Calling CanvasItem.SetDrawBehindParent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_draw_behind_parent", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether the item is drawn behind its parent.
*/
func (o *CanvasItem) IsDrawBehindParentEnabled() bool {
	log.Println("Calling CanvasItem.IsDrawBehindParentEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_draw_behind_parent_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *CanvasItem) X_SetOnTop(onTop bool) {
	log.Println("Calling CanvasItem.X_SetOnTop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(onTop)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_on_top", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *CanvasItem) X_IsOnTop() bool {
	log.Println("Calling CanvasItem.X_IsOnTop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_is_on_top", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Draw a line from a 2D point to another, with a given color and width. It can be optionally antialiased.
*/
func (o *CanvasItem) DrawLine(from *Vector2, to *Vector2, color *Color, width float64, antialiased bool) {
	log.Println("Calling CanvasItem.DrawLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(to)
	goArguments[2] = reflect.ValueOf(color)
	goArguments[3] = reflect.ValueOf(width)
	goArguments[4] = reflect.ValueOf(antialiased)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_line", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CanvasItem) DrawPolyline(points *PoolVector2Array, color *Color, width float64, antialiased bool) {
	log.Println("Calling CanvasItem.DrawPolyline()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(points)
	goArguments[1] = reflect.ValueOf(color)
	goArguments[2] = reflect.ValueOf(width)
	goArguments[3] = reflect.ValueOf(antialiased)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_polyline", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CanvasItem) DrawPolylineColors(points *PoolVector2Array, colors *PoolColorArray, width float64, antialiased bool) {
	log.Println("Calling CanvasItem.DrawPolylineColors()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(points)
	goArguments[1] = reflect.ValueOf(colors)
	goArguments[2] = reflect.ValueOf(width)
	goArguments[3] = reflect.ValueOf(antialiased)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_polyline_colors", goArguments, "")

	log.Println("Got return value!")

}

/*
   Draw a colored rectangle.
*/
func (o *CanvasItem) DrawRect(rect *Rect2, color *Color, filled bool) {
	log.Println("Calling CanvasItem.DrawRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(rect)
	goArguments[1] = reflect.ValueOf(color)
	goArguments[2] = reflect.ValueOf(filled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_rect", goArguments, "")

	log.Println("Got return value!")

}

/*
   Draw a colored circle.
*/
func (o *CanvasItem) DrawCircle(position *Vector2, radius float64, color *Color) {
	log.Println("Calling CanvasItem.DrawCircle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(position)
	goArguments[1] = reflect.ValueOf(radius)
	goArguments[2] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_circle", goArguments, "")

	log.Println("Got return value!")

}

/*
   Draw a texture at a given position.
*/
func (o *CanvasItem) DrawTexture(texture *Texture, position *Vector2, modulate *Color, normalMap *Texture) {
	log.Println("Calling CanvasItem.DrawTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(texture)
	goArguments[1] = reflect.ValueOf(position)
	goArguments[2] = reflect.ValueOf(modulate)
	goArguments[3] = reflect.ValueOf(normalMap)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_texture", goArguments, "")

	log.Println("Got return value!")

}

/*
   Draw a textured rectangle at a given position, optionally modulated by a color. Transpose swaps the x and y coordinates when reading the texture.
*/
func (o *CanvasItem) DrawTextureRect(texture *Texture, rect *Rect2, tile bool, modulate *Color, transpose bool, normalMap *Texture) {
	log.Println("Calling CanvasItem.DrawTextureRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 6, 6)
	goArguments[0] = reflect.ValueOf(texture)
	goArguments[1] = reflect.ValueOf(rect)
	goArguments[2] = reflect.ValueOf(tile)
	goArguments[3] = reflect.ValueOf(modulate)
	goArguments[4] = reflect.ValueOf(transpose)
	goArguments[5] = reflect.ValueOf(normalMap)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_texture_rect", goArguments, "")

	log.Println("Got return value!")

}

/*
   Draw a textured rectangle region at a given position, optionally modulated by a color. Transpose swaps the x and y coordinates when reading the texture.
*/
func (o *CanvasItem) DrawTextureRectRegion(texture *Texture, rect *Rect2, srcRect *Rect2, modulate *Color, transpose bool, normalMap *Texture, clipUv bool) {
	log.Println("Calling CanvasItem.DrawTextureRectRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 7, 7)
	goArguments[0] = reflect.ValueOf(texture)
	goArguments[1] = reflect.ValueOf(rect)
	goArguments[2] = reflect.ValueOf(srcRect)
	goArguments[3] = reflect.ValueOf(modulate)
	goArguments[4] = reflect.ValueOf(transpose)
	goArguments[5] = reflect.ValueOf(normalMap)
	goArguments[6] = reflect.ValueOf(clipUv)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_texture_rect_region", goArguments, "")

	log.Println("Got return value!")

}

/*
   Draw a styled rectangle.
*/
func (o *CanvasItem) DrawStyleBox(styleBox *StyleBox, rect *Rect2) {
	log.Println("Calling CanvasItem.DrawStyleBox()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(styleBox)
	goArguments[1] = reflect.ValueOf(rect)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_style_box", goArguments, "")

	log.Println("Got return value!")

}

/*
   Draw a custom primitive, 1 point for a point, 2 points for a line, 3 points for a triangle and 4 points for a quad.
*/
func (o *CanvasItem) DrawPrimitive(points *PoolVector2Array, colors *PoolColorArray, uvs *PoolVector2Array, texture *Texture, width float64, normalMap *Texture) {
	log.Println("Calling CanvasItem.DrawPrimitive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 6, 6)
	goArguments[0] = reflect.ValueOf(points)
	goArguments[1] = reflect.ValueOf(colors)
	goArguments[2] = reflect.ValueOf(uvs)
	goArguments[3] = reflect.ValueOf(texture)
	goArguments[4] = reflect.ValueOf(width)
	goArguments[5] = reflect.ValueOf(normalMap)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_primitive", goArguments, "")

	log.Println("Got return value!")

}

/*
   Draw a polygon of any amount of points, convex or concave.
*/
func (o *CanvasItem) DrawPolygon(points *PoolVector2Array, colors *PoolColorArray, uvs *PoolVector2Array, texture *Texture, normalMap *Texture, antialiased bool) {
	log.Println("Calling CanvasItem.DrawPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 6, 6)
	goArguments[0] = reflect.ValueOf(points)
	goArguments[1] = reflect.ValueOf(colors)
	goArguments[2] = reflect.ValueOf(uvs)
	goArguments[3] = reflect.ValueOf(texture)
	goArguments[4] = reflect.ValueOf(normalMap)
	goArguments[5] = reflect.ValueOf(antialiased)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_polygon", goArguments, "")

	log.Println("Got return value!")

}

/*
   Draw a colored polygon of any amount of points, convex or concave.
*/
func (o *CanvasItem) DrawColoredPolygon(points *PoolVector2Array, color *Color, uvs *PoolVector2Array, texture *Texture, normalMap *Texture, antialiased bool) {
	log.Println("Calling CanvasItem.DrawColoredPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 6, 6)
	goArguments[0] = reflect.ValueOf(points)
	goArguments[1] = reflect.ValueOf(color)
	goArguments[2] = reflect.ValueOf(uvs)
	goArguments[3] = reflect.ValueOf(texture)
	goArguments[4] = reflect.ValueOf(normalMap)
	goArguments[5] = reflect.ValueOf(antialiased)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_colored_polygon", goArguments, "")

	log.Println("Got return value!")

}

/*
   Draw a string using a custom font.
*/
func (o *CanvasItem) DrawString(font *Font, position *Vector2, text string, modulate *Color, clipW int64) {
	log.Println("Calling CanvasItem.DrawString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(font)
	goArguments[1] = reflect.ValueOf(position)
	goArguments[2] = reflect.ValueOf(text)
	goArguments[3] = reflect.ValueOf(modulate)
	goArguments[4] = reflect.ValueOf(clipW)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_string", goArguments, "")

	log.Println("Got return value!")

}

/*
   Draw a string character using a custom font. Returns the advance, depending on the char width and kerning with an optional next char.
*/
func (o *CanvasItem) DrawChar(font *Font, position *Vector2, char string, next string, modulate *Color) float64 {
	log.Println("Calling CanvasItem.DrawChar()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(font)
	goArguments[1] = reflect.ValueOf(position)
	goArguments[2] = reflect.ValueOf(char)
	goArguments[3] = reflect.ValueOf(next)
	goArguments[4] = reflect.ValueOf(modulate)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "draw_char", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set a custom transform for drawing. Anything drawn afterwards will be transformed by this.
*/
func (o *CanvasItem) DrawSetTransform(position *Vector2, rotation float64, scale *Vector2) {
	log.Println("Calling CanvasItem.DrawSetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(position)
	goArguments[1] = reflect.ValueOf(rotation)
	goArguments[2] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CanvasItem) DrawSetTransformMatrix(xform *Transform2D) {
	log.Println("Calling CanvasItem.DrawSetTransformMatrix()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(xform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_set_transform_matrix", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the transform matrix of this item.
*/
func (o *CanvasItem) GetTransform() *Transform2D {
	log.Println("Calling CanvasItem.GetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Get the global transform matrix of this item.
*/
func (o *CanvasItem) GetGlobalTransform() *Transform2D {
	log.Println("Calling CanvasItem.GetGlobalTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_global_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Get the global transform matrix of this item in relation to the canvas.
*/
func (o *CanvasItem) GetGlobalTransformWithCanvas() *Transform2D {
	log.Println("Calling CanvasItem.GetGlobalTransformWithCanvas()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_global_transform_with_canvas", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Get this item's transform in relation to the viewport.
*/
func (o *CanvasItem) GetViewportTransform() *Transform2D {
	log.Println("Calling CanvasItem.GetViewportTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_viewport_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Get the viewport's boundaries as a [Rect2].
*/
func (o *CanvasItem) GetViewportRect() *Rect2 {
	log.Println("Calling CanvasItem.GetViewportRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_viewport_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Get the transform matrix of this item's canvas.
*/
func (o *CanvasItem) GetCanvasTransform() *Transform2D {
	log.Println("Calling CanvasItem.GetCanvasTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_canvas_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Get the mouse position relative to this item's position.
*/
func (o *CanvasItem) GetLocalMousePosition() *Vector2 {
	log.Println("Calling CanvasItem.GetLocalMousePosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_local_mouse_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Get the global position of the mouse.
*/
func (o *CanvasItem) GetGlobalMousePosition() *Vector2 {
	log.Println("Calling CanvasItem.GetGlobalMousePosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_global_mouse_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the [RID] of the [World2D] canvas where this item is in.
*/
func (o *CanvasItem) GetCanvas() *RID {
	log.Println("Calling CanvasItem.GetCanvas()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_canvas", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Get the [World2D] where this item is in.
*/
func (o *CanvasItem) GetWorld2D() *World2D {
	log.Println("Calling CanvasItem.GetWorld2D()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_world_2d", goArguments, "*World2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*World2D)

	return returnValue

}

/*
   Set the material of this item.
*/
func (o *CanvasItem) SetMaterial(material *Material) {
	log.Println("Calling CanvasItem.SetMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(material)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_material", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the material of this item.
*/
func (o *CanvasItem) GetMaterial() *Material {
	log.Println("Calling CanvasItem.GetMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_material", goArguments, "*Material")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Material)

	return returnValue

}

/*
   Set whether or not this item should use its parent's material.
*/
func (o *CanvasItem) SetUseParentMaterial(enable bool) {
	log.Println("Calling CanvasItem.SetUseParentMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_parent_material", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get whether this item uses its parent's material.
*/
func (o *CanvasItem) GetUseParentMaterial() bool {
	log.Println("Calling CanvasItem.GetUseParentMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_use_parent_material", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *CanvasItem) SetNotifyLocalTransform(enable bool) {
	log.Println("Calling CanvasItem.SetNotifyLocalTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_notify_local_transform", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CanvasItem) IsLocalTransformNotificationEnabled() bool {
	log.Println("Calling CanvasItem.IsLocalTransformNotificationEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_local_transform_notification_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *CanvasItem) SetNotifyTransform(enable bool) {
	log.Println("Calling CanvasItem.SetNotifyTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_notify_transform", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CanvasItem) IsTransformNotificationEnabled() bool {
	log.Println("Calling CanvasItem.IsTransformNotificationEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_transform_notification_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *CanvasItem) MakeCanvasPositionLocal(screenPoint *Vector2) *Vector2 {
	log.Println("Calling CanvasItem.MakeCanvasPositionLocal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(screenPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "make_canvas_position_local", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *CanvasItem) MakeInputLocal(event *InputEvent) *InputEvent {
	log.Println("Calling CanvasItem.MakeInputLocal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(event)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "make_input_local", goArguments, "*InputEvent")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*InputEvent)

	return returnValue

}

/*
   CanvasItemImplementer is an interface for CanvasItem objects.
*/
type CanvasItemImplementer interface {
	Class
}

/*
   A 2D game object, with a position, rotation and scale. All 2D physics nodes and sprites inherit from Node2D. Use Node2D as a parent node to move, scale and rotate children in a 2D project. Also gives control on the node's render order.
*/
type Node2D struct {
	CanvasItem
}

func (o *Node2D) baseClass() string {
	return "Node2D"
}

/*
   Undocumented
*/
func (o *Node2D) X_GetRotd() float64 {
	log.Println("Calling Node2D.X_GetRotd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_rotd", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Undocumented
*/
func (o *Node2D) X_SetRotd(degrees float64) {
	log.Println("Calling Node2D.X_SetRotd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_rotd", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the node's position.
*/
func (o *Node2D) SetPosition(position *Vector2) {
	log.Println("Calling Node2D.SetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_position", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the node's rotation in radians.
*/
func (o *Node2D) SetRotation(radians float64) {
	log.Println("Calling Node2D.SetRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radians)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rotation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the node's rotation in degrees.
*/
func (o *Node2D) SetRotationInDegrees(degrees float64) {
	log.Println("Calling Node2D.SetRotationInDegrees()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rotation_in_degrees", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the node's scale.
*/
func (o *Node2D) SetScale(scale *Vector2) {
	log.Println("Calling Node2D.SetScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the node's position.
*/
func (o *Node2D) GetPosition() *Vector2 {
	log.Println("Calling Node2D.GetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Returns the node's rotation in radians.
*/
func (o *Node2D) GetRotation() float64 {
	log.Println("Calling Node2D.GetRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rotation", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns the node's rotation in degrees.
*/
func (o *Node2D) GetRotationInDegrees() float64 {
	log.Println("Calling Node2D.GetRotationInDegrees()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rotation_in_degrees", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns the node's scale.
*/
func (o *Node2D) GetScale() *Vector2 {
	log.Println("Calling Node2D.GetScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scale", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Apply a rotation to the node, in radians, starting from its current rotation.
*/
func (o *Node2D) Rotate(radians float64) {
	log.Println("Calling Node2D.Rotate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radians)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rotate", goArguments, "")

	log.Println("Got return value!")

}

/*
   Apply a local translation on the node's X axis based on the process's 'delta'. If 'scaled' is false, normalizes the movement.
*/
func (o *Node2D) MoveLocalX(delta float64, scaled bool) {
	log.Println("Calling Node2D.MoveLocalX()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(delta)
	goArguments[1] = reflect.ValueOf(scaled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "move_local_x", goArguments, "")

	log.Println("Got return value!")

}

/*
   Apply a local translation on the node's Y axis based on the process's 'delta'. If 'scaled' is false, normalizes the movement.
*/
func (o *Node2D) MoveLocalY(delta float64, scaled bool) {
	log.Println("Calling Node2D.MoveLocalY()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(delta)
	goArguments[1] = reflect.ValueOf(scaled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "move_local_y", goArguments, "")

	log.Println("Got return value!")

}

/*
   Translate the node locally by the 'offset' vector, starting from its current local position.
*/
func (o *Node2D) Translate(offset *Vector2) {
	log.Println("Calling Node2D.Translate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "translate", goArguments, "")

	log.Println("Got return value!")

}

/*
   Adds the 'offset' vector to the node's global position.
*/
func (o *Node2D) GlobalTranslate(offset *Vector2) {
	log.Println("Calling Node2D.GlobalTranslate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "global_translate", goArguments, "")

	log.Println("Got return value!")

}

/*
   Multiplies the current scale by the 'ratio' vector.
*/
func (o *Node2D) ApplyScale(ratio *Vector2) {
	log.Println("Calling Node2D.ApplyScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ratio)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "apply_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the node's global position.
*/
func (o *Node2D) SetGlobalPosition(position *Vector2) {
	log.Println("Calling Node2D.SetGlobalPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_global_position", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the node's global position.
*/
func (o *Node2D) GetGlobalPosition() *Vector2 {
	log.Println("Calling Node2D.GetGlobalPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_global_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set the node's global rotation in radians.
*/
func (o *Node2D) SetGlobalRotation(radians float64) {
	log.Println("Calling Node2D.SetGlobalRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radians)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_global_rotation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the node's global rotation in radians.
*/
func (o *Node2D) GetGlobalRotation() float64 {
	log.Println("Calling Node2D.GetGlobalRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_global_rotation", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the node's global rotation in degrees.
*/
func (o *Node2D) SetGlobalRotationInDegrees(degrees float64) {
	log.Println("Calling Node2D.SetGlobalRotationInDegrees()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_global_rotation_in_degrees", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the node's global rotation in degrees.
*/
func (o *Node2D) GetGlobalRotationInDegrees() float64 {
	log.Println("Calling Node2D.GetGlobalRotationInDegrees()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_global_rotation_in_degrees", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the node's global scale.
*/
func (o *Node2D) SetGlobalScale(scale *Vector2) {
	log.Println("Calling Node2D.SetGlobalScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_global_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the node's global scale.
*/
func (o *Node2D) GetGlobalScale() *Vector2 {
	log.Println("Calling Node2D.GetGlobalScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_global_scale", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set the node's local [Transform2D].
*/
func (o *Node2D) SetTransform(xform *Transform2D) {
	log.Println("Calling Node2D.SetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(xform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the node's global [Transform2D].
*/
func (o *Node2D) SetGlobalTransform(xform *Transform2D) {
	log.Println("Calling Node2D.SetGlobalTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(xform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_global_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Rotates the node so it points towards the 'point'.
*/
func (o *Node2D) LookAt(point *Vector2) {
	log.Println("Calling Node2D.LookAt()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(point)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "look_at", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the angle between the node and the 'point' in radians.
*/
func (o *Node2D) GetAngleTo(point *Vector2) float64 {
	log.Println("Calling Node2D.GetAngleTo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(point)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_angle_to", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Node2D) ToLocal(globalPoint *Vector2) *Vector2 {
	log.Println("Calling Node2D.ToLocal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(globalPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "to_local", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Node2D) ToGlobal(localPoint *Vector2) *Vector2 {
	log.Println("Calling Node2D.ToGlobal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(localPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "to_global", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set the node's Z-index.
*/
func (o *Node2D) SetZ(z int64) {
	log.Println("Calling Node2D.SetZ()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(z)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_z", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the node's Z-index.
*/
func (o *Node2D) GetZ() int64 {
	log.Println("Calling Node2D.GetZ()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_z", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Make the node's Z-index relative to its parent's Z-index. If this node's Z-index is 2 and its parent's effective Z-index is 3, then this node's effective Z-index will be 2 + 3 = 5.
*/
func (o *Node2D) SetZAsRelative(enable bool) {
	log.Println("Calling Node2D.SetZAsRelative()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_z_as_relative", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns true if this node's Z-index is relative to its parent's. Else, returns false.
*/
func (o *Node2D) IsZRelative() bool {
	log.Println("Calling Node2D.IsZRelative()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_z_relative", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the pivot position of the 2D node to 'pivot' value. Only some Node2Ds implement this method.
*/
func (o *Node2D) EditSetPivot(pivot *Vector2) {
	log.Println("Calling Node2D.EditSetPivot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pivot)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "edit_set_pivot", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the [Transform2D] relative to this node's parent.
*/
func (o *Node2D) GetRelativeTransformToParent(parent *Object) *Transform2D {
	log.Println("Calling Node2D.GetRelativeTransformToParent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(parent)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_relative_transform_to_parent", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Node2DImplementer is an interface for Node2D objects.
*/
type Node2DImplementer interface {
	Class
}

/*
   CanvasModulate tints the canvas elements using its assigned color
*/
type CanvasModulate struct {
	Node2D
}

func (o *CanvasModulate) baseClass() string {
	return "CanvasModulate"
}

/*
   Sets the canvas tint color
*/
func (o *CanvasModulate) SetColor(color *Color) {
	log.Println("Calling CanvasModulate.SetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_color", goArguments, "")

	log.Println("Got return value!")

}

/*
   Gets the canvas tint color
*/
func (o *CanvasModulate) GetColor() *Color {
	log.Println("Calling CanvasModulate.GetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   CanvasModulateImplementer is an interface for CanvasModulate objects.
*/
type CanvasModulateImplementer interface {
	Class
}

/*
   Resource Preloader Node. This node is used to preload sub-resources inside a scene, so when the scene is loaded all the resources are ready to use and be retrieved from here.
*/
type ResourcePreloader struct {
	Node
}

func (o *ResourcePreloader) baseClass() string {
	return "ResourcePreloader"
}

/*
   Undocumented
*/
func (o *ResourcePreloader) X_SetResources(arg0 *Array) {
	log.Println("Calling ResourcePreloader.X_SetResources()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_resources", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ResourcePreloader) X_GetResources() *Array {
	log.Println("Calling ResourcePreloader.X_GetResources()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_resources", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *ResourcePreloader) AddResource(name string, resource *Resource) {
	log.Println("Calling ResourcePreloader.AddResource()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(resource)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_resource", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove a resource from the preloader by text id.
*/
func (o *ResourcePreloader) RemoveResource(name string) {
	log.Println("Calling ResourcePreloader.RemoveResource()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_resource", goArguments, "")

	log.Println("Got return value!")

}

/*
   Rename a resource inside the preloader, from a text-id to a new text-id.
*/
func (o *ResourcePreloader) RenameResource(name string, newname string) {
	log.Println("Calling ResourcePreloader.RenameResource()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(newname)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rename_resource", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if the preloader has a given resource.
*/
func (o *ResourcePreloader) HasResource(name string) bool {
	log.Println("Calling ResourcePreloader.HasResource()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_resource", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return the resource given a text-id.
*/
func (o *ResourcePreloader) GetResource(name string) *Resource {
	log.Println("Calling ResourcePreloader.GetResource()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_resource", goArguments, "*Resource")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Resource)

	return returnValue

}

/*
   Return the list of resources inside the preloader.
*/
func (o *ResourcePreloader) GetResourceList() *PoolStringArray {
	log.Println("Calling ResourcePreloader.GetResourceList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_resource_list", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   ResourcePreloaderImplementer is an interface for ResourcePreloader objects.
*/
type ResourcePreloaderImplementer interface {
	Class
}

/*
   The base class Node for all User Interface components. Every UI node inherits from it. Any scene or portion of a scene tree composed of Control nodes is a User Interface. Controls use anchors and margins to place themselves relative to their parent. They adapt automatically when their parent or the screen size changes. To build flexible UIs, use built-in [Container] nodes or create your own. Anchors work by defining which margin do they follow, and a value relative to it. Allowed anchoring modes are ANCHOR_BEGIN, where the margin is relative to the top or left margins of the parent (in pixels), ANCHOR_END for the right and bottom margins of the parent and ANCHOR_RATIO, which is a ratio from 0 to 1 in the parent range. Godot sends Input events to the root node first, via [method Node._input]. The method distributes it through the node tree and delivers the input events to the node under the mouse cursor or on focus with the keyboard. To do so, it calls [method MainLoop._input_event]. No need to enable [method Node.set_process_input] on Controls to receive input events. Call [method accept_event] to ensure no other node receives the event, not even [method Node._unhandled_input]. Only the one Control node in focus receives keyboard events. To do so, the Control must get the focus mode with [method set_focus_mode]. It loses focus when another Control gets it, or if the current Control in focus is hidden. You'll sometimes want Controls to ignore mouse or touch events. For example, if you place an icon on top of a button. Call [method set_ignore_mouse] for that. [Theme] resources change the Control's appearance. If you change the [Theme] on a parent Control node, it will propagate to all of its children. You can override parts of the theme on each Control with the add_*_override methods, like [method add_font_override]. You can also override the theme from the editor.
*/
type Control struct {
	CanvasItem
}

func (o *Control) baseClass() string {
	return "Control"
}

/*

 */
func (o *Control) X_GuiInput(event *InputEvent) {
	log.Println("Calling Control.X_GuiInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(event)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_gui_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the minimum size this Control can shrink to. A control will never be displayed or resized smaller than its minimum size.
*/
func (o *Control) X_GetMinimumSize() *Vector2 {
	log.Println("Calling Control.X_GetMinimumSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_minimum_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Control) GetDragData(position *Vector2) *Object {
	log.Println("Calling Control.GetDragData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_drag_data", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*

 */
func (o *Control) CanDropData(position *Vector2, data *Variant) bool {
	log.Println("Calling Control.CanDropData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(position)
	goArguments[1] = reflect.ValueOf(data)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "can_drop_data", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Control) DropData(position *Vector2, data *Variant) {
	log.Println("Calling Control.DropData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(position)
	goArguments[1] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "drop_data", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) HasPoint(point *Vector2) bool {
	log.Println("Calling Control.HasPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(point)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_point", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *Control) X_SizeChanged() {
	log.Println("Calling Control.X_SizeChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_size_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Control) X_UpdateMinimumSize() {
	log.Println("Calling Control.X_UpdateMinimumSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_update_minimum_size", goArguments, "")

	log.Println("Got return value!")

}

/*
   Marks the input event as handled. No other Control will receive it, and the input event will not propagate. Not even to nodes listening to [method Node._unhandled_input] or [method Node._unhandled_key_input].
*/
func (o *Control) AcceptEvent() {
	log.Println("Calling Control.AcceptEvent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "accept_event", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the minimum size this Control can shrink to. A control will never be displayed or resized smaller than its minimum size.
*/
func (o *Control) GetMinimumSize() *Vector2 {
	log.Println("Calling Control.GetMinimumSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_minimum_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Control) GetCombinedMinimumSize() *Vector2 {
	log.Println("Calling Control.GetCombinedMinimumSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_combined_minimum_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Control) SetAnchorsPreset(preset int64, keepMargin bool) {
	log.Println("Calling Control.SetAnchorsPreset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(preset)
	goArguments[1] = reflect.ValueOf(keepMargin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_anchors_preset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Control) SetMarginsPreset(preset int64, resizeMode int64, margin int64) {
	log.Println("Calling Control.SetMarginsPreset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(preset)
	goArguments[1] = reflect.ValueOf(resizeMode)
	goArguments[2] = reflect.ValueOf(margin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_margins_preset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Control) SetAnchorsAndMarginsPreset(preset int64, resizeMode int64, margin int64) {
	log.Println("Calling Control.SetAnchorsAndMarginsPreset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(preset)
	goArguments[1] = reflect.ValueOf(resizeMode)
	goArguments[2] = reflect.ValueOf(margin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_anchors_and_margins_preset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) SetAnchor(margin int64, anchor float64, keepMargin bool, pushOppositeAnchor bool) {
	log.Println("Calling Control.SetAnchor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(anchor)
	goArguments[2] = reflect.ValueOf(keepMargin)
	goArguments[3] = reflect.ValueOf(pushOppositeAnchor)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_anchor", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Control) X_SetAnchor(margin int64, anchor float64) {
	log.Println("Calling Control.X_SetAnchor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(anchor)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_anchor", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the anchor type (ANCHOR_BEGIN, ANCHOR_END, ANCHOR_RATIO) for a given margin (MARGIN_LEFT, MARGIN_TOP, MARGIN_RIGHT, MARGIN_BOTTOM).
*/
func (o *Control) GetAnchor(margin int64) float64 {
	log.Println("Calling Control.GetAnchor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_anchor", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set a margin offset. Margin can be one of (MARGIN_LEFT, MARGIN_TOP, MARGIN_RIGHT, MARGIN_BOTTOM). Offset value being set depends on the anchor mode.
*/
func (o *Control) SetMargin(margin int64, offset float64) {
	log.Println("Calling Control.SetMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_margin", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) SetAnchorAndMargin(margin int64, anchor float64, offset float64, pushOppositeAnchor bool) {
	log.Println("Calling Control.SetAnchorAndMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(anchor)
	goArguments[2] = reflect.ValueOf(offset)
	goArguments[3] = reflect.ValueOf(pushOppositeAnchor)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_anchor_and_margin", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets MARGIN_LEFT and MARGIN_TOP at the same time. This is a helper (see [method set_margin]).
*/
func (o *Control) SetBegin(position *Vector2) {
	log.Println("Calling Control.SetBegin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_begin", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets MARGIN_RIGHT and MARGIN_BOTTOM at the same time. This is a helper (see [method set_margin]).
*/
func (o *Control) SetEnd(position *Vector2) {
	log.Println("Calling Control.SetEnd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_end", goArguments, "")

	log.Println("Got return value!")

}

/*
   Move the Control to a new position, relative to the top-left corner of the parent Control, changing all margins if needed and without changing current anchor mode. This is a helper (see [method set_margin]).
*/
func (o *Control) SetPosition(position *Vector2) {
	log.Println("Calling Control.SetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_position", goArguments, "")

	log.Println("Got return value!")

}

/*
   Changes MARGIN_RIGHT and MARGIN_BOTTOM to fit a given size. This is a helper (see [method set_margin]).
*/
func (o *Control) SetSize(size *Vector2) {
	log.Println("Calling Control.SetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) SetCustomMinimumSize(size *Vector2) {
	log.Println("Calling Control.SetCustomMinimumSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_minimum_size", goArguments, "")

	log.Println("Got return value!")

}

/*
   Move the Control to a new position, relative to the top-left corner of the [i]window[/i] Control, and without changing current anchor mode. (see [method set_margin]).
*/
func (o *Control) SetGlobalPosition(position *Vector2) {
	log.Println("Calling Control.SetGlobalPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_global_position", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the rotation (in radians).
*/
func (o *Control) SetRotation(radians float64) {
	log.Println("Calling Control.SetRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radians)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rotation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the rotation (in degrees).
*/
func (o *Control) SetRotationDeg(degrees float64) {
	log.Println("Calling Control.SetRotationDeg()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rotation_deg", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Control) X_SetRotationDeg(degrees float64) {
	log.Println("Calling Control.X_SetRotationDeg()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_rotation_deg", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) SetScale(scale *Vector2) {
	log.Println("Calling Control.SetScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) SetPivotOffset(pivotOffset *Vector2) {
	log.Println("Calling Control.SetPivotOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pivotOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pivot_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return a margin offset. Margin can be one of (MARGIN_LEFT, MARGIN_TOP, MARGIN_RIGHT, MARGIN_BOTTOM). Offset value being returned depends on the anchor mode.
*/
func (o *Control) GetMargin(margin int64) float64 {
	log.Println("Calling Control.GetMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_margin", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Control) GetBegin() *Vector2 {
	log.Println("Calling Control.GetBegin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_begin", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Returns MARGIN_LEFT and MARGIN_TOP at the same time. This is a helper (see [method set_margin]).
*/
func (o *Control) GetEnd() *Vector2 {
	log.Println("Calling Control.GetEnd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_end", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Returns the Control position, relative to the top-left corner of the parent Control and independent of the anchor mode.
*/
func (o *Control) GetPosition() *Vector2 {
	log.Println("Calling Control.GetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Returns the size of the Control, computed from all margins, however the size returned will [b]never be smaller than the minimum size reported by[/b] [method get_minimum_size]. This means that even if end position of the Control rectangle is smaller than the begin position, the Control will still display and interact correctly. (see description, [method get_minimum_size], [method set_margin], [method set_anchor]).
*/
func (o *Control) GetSize() *Vector2 {
	log.Println("Calling Control.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the rotation (in radians)
*/
func (o *Control) GetRotation() float64 {
	log.Println("Calling Control.GetRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rotation", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the rotation (in degrees)
*/
func (o *Control) GetRotationDeg() float64 {
	log.Println("Calling Control.GetRotationDeg()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rotation_deg", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Undocumented
*/
func (o *Control) X_GetRotationDeg() float64 {
	log.Println("Calling Control.X_GetRotationDeg()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_rotation_deg", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Control) GetScale() *Vector2 {
	log.Println("Calling Control.GetScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scale", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Control) GetPivotOffset() *Vector2 {
	log.Println("Calling Control.GetPivotOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pivot_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Control) GetCustomMinimumSize() *Vector2 {
	log.Println("Calling Control.GetCustomMinimumSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_custom_minimum_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Control) GetParentAreaSize() *Vector2 {
	log.Println("Calling Control.GetParentAreaSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_parent_area_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Returns the Control position, relative to the top-left corner of the parent Control and independent of the anchor mode.
*/
func (o *Control) GetGlobalPosition() *Vector2 {
	log.Println("Calling Control.GetGlobalPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_global_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return position and size of the Control, relative to the top-left corner of the parent Control. This is a helper (see [method get_position], [method get_size]).
*/
func (o *Control) GetRect() *Rect2 {
	log.Println("Calling Control.GetRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Return position and size of the Control, relative to the top-left corner of the [i]window[/i] Control. This is a helper (see [method get_global_position], [method get_size]).
*/
func (o *Control) GetGlobalRect() *Rect2 {
	log.Println("Calling Control.GetGlobalRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_global_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Display a Control as modal. Control must be a subwindow. Modal controls capture the input signals until closed or the area outside them is accessed. When a modal control loses focus, or the ESC key is pressed, they automatically hide. Modal controls are used extensively for popup dialogs and menus.
*/
func (o *Control) ShowModal(exclusive bool) {
	log.Println("Calling Control.ShowModal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(exclusive)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "show_modal", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the focus access mode for the control (FOCUS_NONE, FOCUS_CLICK, FOCUS_ALL). Only one Control can be focused at the same time, and it will receive keyboard signals.
*/
func (o *Control) SetFocusMode(mode int64) {
	log.Println("Calling Control.SetFocusMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_focus_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the focus access mode for the control (FOCUS_NONE, FOCUS_CLICK, FOCUS_ALL) (see [method set_focus_mode]).
*/
func (o *Control) GetFocusMode() int64 {
	log.Println("Calling Control.GetFocusMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_focus_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return whether the Control is the current focused control (see [method set_focus_mode]).
*/
func (o *Control) HasFocus() bool {
	log.Println("Calling Control.HasFocus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_focus", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Steal the focus from another control and become the focused control (see [method set_focus_mode]).
*/
func (o *Control) GrabFocus() {
	log.Println("Calling Control.GrabFocus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "grab_focus", goArguments, "")

	log.Println("Got return value!")

}

/*
   Give up the focus, no other control will be able to receive keyboard input.
*/
func (o *Control) ReleaseFocus() {
	log.Println("Calling Control.ReleaseFocus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "release_focus", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return which control is owning the keyboard focus, or null if no one.
*/
func (o *Control) GetFocusOwner() *Control {
	log.Println("Calling Control.GetFocusOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_focus_owner", goArguments, "*Control")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Control)

	return returnValue

}

/*
   Hint for containers, set horizontal positioning flags.
*/
func (o *Control) SetHSizeFlags(flags int64) {
	log.Println("Calling Control.SetHSizeFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flags)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_h_size_flags", goArguments, "")

	log.Println("Got return value!")

}

/*
   Hint for containers, return horizontal positioning flags.
*/
func (o *Control) GetHSizeFlags() int64 {
	log.Println("Calling Control.GetHSizeFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_h_size_flags", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Hint for containers, set the stretch ratio. This value is relative to other stretch ratio, so if this control has 2 and another has 1, this one will be twice as big.
*/
func (o *Control) SetStretchRatio(ratio float64) {
	log.Println("Calling Control.SetStretchRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ratio)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_stretch_ratio", goArguments, "")

	log.Println("Got return value!")

}

/*
   Hint for containers, return the stretch ratio. This value is relative to other stretch ratio, so if this control has 2 and another has 1, this one will be twice as big.
*/
func (o *Control) GetStretchRatio() float64 {
	log.Println("Calling Control.GetStretchRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stretch_ratio", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Hint for containers, set vertical positioning flags.
*/
func (o *Control) SetVSizeFlags(flags int64) {
	log.Println("Calling Control.SetVSizeFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flags)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_v_size_flags", goArguments, "")

	log.Println("Got return value!")

}

/*
   Hint for containers, return vertical positioning flags.
*/
func (o *Control) GetVSizeFlags() int64 {
	log.Println("Calling Control.GetVSizeFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_v_size_flags", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Override whole the [Theme] for this Control and all its children controls.
*/
func (o *Control) SetTheme(theme *Theme) {
	log.Println("Calling Control.SetTheme()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(theme)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_theme", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return a [Theme] override, if one exists (see [method set_theme]).
*/
func (o *Control) GetTheme() *Theme {
	log.Println("Calling Control.GetTheme()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_theme", goArguments, "*Theme")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Theme)

	return returnValue

}

/*
   Override a single icon ([Texture]) in the theme of this Control. If texture is empty, override is cleared.
*/
func (o *Control) AddIconOverride(name string, texture *Texture) {
	log.Println("Calling Control.AddIconOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_icon_override", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) AddShaderOverride(name string, shader *Shader) {
	log.Println("Calling Control.AddShaderOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(shader)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_shader_override", goArguments, "")

	log.Println("Got return value!")

}

/*
   Override a single stylebox ([Stylebox]) in the theme of this Control. If stylebox is empty, override is cleared.
*/
func (o *Control) AddStyleOverride(name string, stylebox *StyleBox) {
	log.Println("Calling Control.AddStyleOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(stylebox)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_style_override", goArguments, "")

	log.Println("Got return value!")

}

/*
   Override a single font (font) in the theme of this Control. If font is empty, override is cleared.
*/
func (o *Control) AddFontOverride(name string, font *Font) {
	log.Println("Calling Control.AddFontOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(font)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_font_override", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) AddColorOverride(name string, color *Color) {
	log.Println("Calling Control.AddColorOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_color_override", goArguments, "")

	log.Println("Got return value!")

}

/*
   Override a single constant (integer) in the theme of this Control. If constant equals Theme.INVALID_CONSTANT, override is cleared.
*/
func (o *Control) AddConstantOverride(name string, constant int64) {
	log.Println("Calling Control.AddConstantOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(constant)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_constant_override", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) GetIcon(name string, aType string) *Texture {
	log.Println("Calling Control.GetIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_icon", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *Control) GetStylebox(name string, aType string) *StyleBox {
	log.Println("Calling Control.GetStylebox()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stylebox", goArguments, "*StyleBox")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*StyleBox)

	return returnValue

}

/*

 */
func (o *Control) GetFont(name string, aType string) *Font {
	log.Println("Calling Control.GetFont()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_font", goArguments, "*Font")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Font)

	return returnValue

}

/*

 */
func (o *Control) GetColor(name string, aType string) *Color {
	log.Println("Calling Control.GetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *Control) GetConstant(name string, aType string) int64 {
	log.Println("Calling Control.GetConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_constant", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Control) HasIconOverride(name string) bool {
	log.Println("Calling Control.HasIconOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_icon_override", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Control) HasStyleboxOverride(name string) bool {
	log.Println("Calling Control.HasStyleboxOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_stylebox_override", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Control) HasFontOverride(name string) bool {
	log.Println("Calling Control.HasFontOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_font_override", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Control) HasColorOverride(name string) bool {
	log.Println("Calling Control.HasColorOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_color_override", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Control) HasConstantOverride(name string) bool {
	log.Println("Calling Control.HasConstantOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_constant_override", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Control) HasIcon(name string, aType string) bool {
	log.Println("Calling Control.HasIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_icon", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Control) HasStylebox(name string, aType string) bool {
	log.Println("Calling Control.HasStylebox()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_stylebox", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Control) HasFont(name string, aType string) bool {
	log.Println("Calling Control.HasFont()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_font", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Control) HasColor(name string, aType string) bool {
	log.Println("Calling Control.HasColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_color", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Control) HasConstant(name string, aType string) bool {
	log.Println("Calling Control.HasConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_constant", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Control) GetParentControl() *Control {
	log.Println("Calling Control.GetParentControl()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_parent_control", goArguments, "*Control")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Control)

	return returnValue

}

/*

 */
func (o *Control) SetHGrowDirection(direction int64) {
	log.Println("Calling Control.SetHGrowDirection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(direction)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_h_grow_direction", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) GetHGrowDirection() int64 {
	log.Println("Calling Control.GetHGrowDirection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_h_grow_direction", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Control) SetVGrowDirection(direction int64) {
	log.Println("Calling Control.SetVGrowDirection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(direction)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_v_grow_direction", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) GetVGrowDirection() int64 {
	log.Println("Calling Control.GetVGrowDirection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_v_grow_direction", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set a tooltip, which will appear when the cursor is resting over this control.
*/
func (o *Control) SetTooltip(tooltip string) {
	log.Println("Calling Control.SetTooltip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tooltip)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tooltip", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the tooltip, which will appear when the cursor is resting over this control.
*/
func (o *Control) GetTooltip(atPosition *Vector2) string {
	log.Println("Calling Control.GetTooltip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(atPosition)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tooltip", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *Control) X_GetTooltip() string {
	log.Println("Calling Control.X_GetTooltip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_tooltip", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Set the default cursor shape for this control. See enum CURSOR_* for the list of shapes.
*/
func (o *Control) SetDefaultCursorShape(shape int64) {
	log.Println("Calling Control.SetDefaultCursorShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_default_cursor_shape", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the default cursor shape for this control. See enum CURSOR_* for the list of shapes.
*/
func (o *Control) GetDefaultCursorShape() int64 {
	log.Println("Calling Control.GetDefaultCursorShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_default_cursor_shape", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the cursor shape at a certain position in the control.
*/
func (o *Control) GetCursorShape(position *Vector2) int64 {
	log.Println("Calling Control.GetCursorShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cursor_shape", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Force a neighbour for moving the input focus to. When pressing TAB or directional/joypad directions focus is moved to the next control in that direction. However, the neighbour to move to can be forced with this function.
*/
func (o *Control) SetFocusNeighbour(margin int64, neighbour *NodePath) {
	log.Println("Calling Control.SetFocusNeighbour()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(neighbour)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_focus_neighbour", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the forced neighbour for moving the input focus to. When pressing TAB or directional/joypad directions focus is moved to the next control in that direction. However, the neighbour to move to can be forced with this function.
*/
func (o *Control) GetFocusNeighbour(margin int64) *NodePath {
	log.Println("Calling Control.GetFocusNeighbour()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_focus_neighbour", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *Control) ForceDrag(data *Variant, preview *Object) {
	log.Println("Calling Control.ForceDrag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(data)
	goArguments[1] = reflect.ValueOf(preview)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "force_drag", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set when the control is ignoring mouse events (even touchpad events send mouse events). (see the MOUSE_FILTER_* constants)
*/
func (o *Control) SetMouseFilter(filter int64) {
	log.Println("Calling Control.SetMouseFilter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(filter)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mouse_filter", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return when the control is ignoring mouse events (even touchpad events send mouse events).
*/
func (o *Control) GetMouseFilter() int64 {
	log.Println("Calling Control.GetMouseFilter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mouse_filter", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Control) SetClipContents(enable bool) {
	log.Println("Calling Control.SetClipContents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_clip_contents", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) IsClippingContents() bool {
	log.Println("Calling Control.IsClippingContents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_clipping_contents", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Control) GrabClickFocus() {
	log.Println("Calling Control.GrabClickFocus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "grab_click_focus", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) SetDragForwarding(target *Object) {
	log.Println("Calling Control.SetDragForwarding()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(target)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_drag_forwarding", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) SetDragPreview(control *Object) {
	log.Println("Calling Control.SetDragPreview()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(control)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_drag_preview", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) WarpMouse(toPosition *Vector2) {
	log.Println("Calling Control.WarpMouse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toPosition)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "warp_mouse", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) MinimumSizeChanged() {
	log.Println("Calling Control.MinimumSizeChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "minimum_size_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Control) X_ThemeChanged() {
	log.Println("Calling Control.X_ThemeChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_theme_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Control) X_FontChanged() {
	log.Println("Calling Control.X_FontChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_font_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   ControlImplementer is an interface for Control objects.
*/
type ControlImplementer interface {
	Class
}

/*
   BaseButton is the abstract base class for buttons, so it shouldn't be used directly (It doesn't display anything). Other types of buttons inherit from it.
*/
type BaseButton struct {
	Control
}

func (o *BaseButton) baseClass() string {
	return "BaseButton"
}

/*
   Called when button is pressed.
*/
func (o *BaseButton) X_Pressed() {
	log.Println("Calling BaseButton.X_Pressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_pressed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Called when button is toggled (only if toggle_mode is active).
*/
func (o *BaseButton) X_Toggled(pressed bool) {
	log.Println("Calling BaseButton.X_Toggled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pressed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_toggled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *BaseButton) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling BaseButton.X_GuiInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_gui_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *BaseButton) X_UnhandledInput(arg0 *InputEvent) {
	log.Println("Calling BaseButton.X_UnhandledInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_unhandled_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the button to pressed state (only if toggle_mode is active).
*/
func (o *BaseButton) SetPressed(pressed bool) {
	log.Println("Calling BaseButton.SetPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pressed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pressed", goArguments, "")

	log.Println("Got return value!")

}

/*
   If toggle_mode is active, return whether the button is toggled. If toggle_mode is not active, return whether the button is pressed down.
*/
func (o *BaseButton) IsPressed() bool {
	log.Println("Calling BaseButton.IsPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_pressed", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return true if mouse entered the button before it exit.
*/
func (o *BaseButton) IsHovered() bool {
	log.Println("Calling BaseButton.IsHovered()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_hovered", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the button toggle_mode property. Toggle mode makes the button flip state between pressed and unpressed each time its area is clicked.
*/
func (o *BaseButton) SetToggleMode(enabled bool) {
	log.Println("Calling BaseButton.SetToggleMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_toggle_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the toggle_mode property (see [method set_toggle_mode]).
*/
func (o *BaseButton) IsToggleMode() bool {
	log.Println("Calling BaseButton.IsToggleMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_toggle_mode", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the button into disabled state. When a button is disabled, it can't be clicked or toggled.
*/
func (o *BaseButton) SetDisabled(disabled bool) {
	log.Println("Calling BaseButton.SetDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(disabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether the button is in disabled state (see [method set_disabled]).
*/
func (o *BaseButton) IsDisabled() bool {
	log.Println("Calling BaseButton.IsDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_disabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the current mode of action, determining when the button is considered clicked (see the ACTION_MODE_* constants).
*/
func (o *BaseButton) SetActionMode(mode int64) {
	log.Println("Calling BaseButton.SetActionMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_action_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current mode of action (see [method set_action_mode]) (one of the ACTION_MODE_* constants).
*/
func (o *BaseButton) GetActionMode() int64 {
	log.Println("Calling BaseButton.GetActionMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_action_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the visual state used to draw the button. This is useful mainly when implementing your own draw code by either overriding _draw() or connecting to "draw" signal. The visual state of the button is defined by the DRAW_* enum.
*/
func (o *BaseButton) GetDrawMode() int64 {
	log.Println("Calling BaseButton.GetDrawMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_draw_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Sets the focus access mode to use when switching between enabled/disabled (see [method Control.set_focus_mode] and [method set_disabled]).
*/
func (o *BaseButton) SetEnabledFocusMode(mode int64) {
	log.Println("Calling BaseButton.SetEnabledFocusMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enabled_focus_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns focus access mode used when switching between enabled/disabled (see [method Control.set_focus_mode] and [method set_disabled]).
*/
func (o *BaseButton) GetEnabledFocusMode() int64 {
	log.Println("Calling BaseButton.GetEnabledFocusMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_enabled_focus_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *BaseButton) SetShortcut(shortcut *ShortCut) {
	log.Println("Calling BaseButton.SetShortcut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shortcut)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shortcut", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *BaseButton) GetShortcut() *ShortCut {
	log.Println("Calling BaseButton.GetShortcut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shortcut", goArguments, "*ShortCut")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*ShortCut)

	return returnValue

}

/*

 */
func (o *BaseButton) SetButtonGroup(buttonGroup *ButtonGroup) {
	log.Println("Calling BaseButton.SetButtonGroup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(buttonGroup)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_button_group", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *BaseButton) GetButtonGroup() *ButtonGroup {
	log.Println("Calling BaseButton.GetButtonGroup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_button_group", goArguments, "*ButtonGroup")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*ButtonGroup)

	return returnValue

}

/*
   BaseButtonImplementer is an interface for BaseButton objects.
*/
type BaseButtonImplementer interface {
	Class
}

/*

 */
type ShortCut struct {
	Resource
}

func (o *ShortCut) baseClass() string {
	return "ShortCut"
}

/*

 */
func (o *ShortCut) SetShortcut(event *InputEvent) {
	log.Println("Calling ShortCut.SetShortcut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(event)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shortcut", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ShortCut) GetShortcut() *InputEvent {
	log.Println("Calling ShortCut.GetShortcut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shortcut", goArguments, "*InputEvent")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*InputEvent)

	return returnValue

}

/*

 */
func (o *ShortCut) IsValid() bool {
	log.Println("Calling ShortCut.IsValid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_valid", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *ShortCut) IsShortcut(event *InputEvent) bool {
	log.Println("Calling ShortCut.IsShortcut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(event)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_shortcut", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *ShortCut) GetAsText() string {
	log.Println("Calling ShortCut.GetAsText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_as_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   ShortCutImplementer is an interface for ShortCut objects.
*/
type ShortCutImplementer interface {
	Class
}

/*
   Range is a base class for [Control] nodes that change a floating point [i]value[/i] between a [i]minimum[/i] and a [i]maximum[/i], using [i]step[/i] and [i]page[/i], for example a [ScrollBar].
*/
type Range struct {
	Control
}

func (o *Range) baseClass() string {
	return "Range"
}

/*

 */
func (o *Range) GetValue() float64 {
	log.Println("Calling Range.GetValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_value", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the minimum value.
*/
func (o *Range) GetMin() float64 {
	log.Println("Calling Range.GetMin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_min", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the maximum value.
*/
func (o *Range) GetMax() float64 {
	log.Println("Calling Range.GetMax()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_max", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the stepping, if step is 0, stepping is disabled.
*/
func (o *Range) GetStep() float64 {
	log.Println("Calling Range.GetStep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_step", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the page size, if page is 0, paging is disabled.
*/
func (o *Range) GetPage() float64 {
	log.Println("Calling Range.GetPage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_page", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return value mapped to 0 to 1 range.
*/
func (o *Range) GetAsRatio() float64 {
	log.Println("Calling Range.GetAsRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_as_ratio", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Range) SetValue(value float64) {
	log.Println("Calling Range.SetValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_value", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set minimum value, clamped range value to it if it's less.
*/
func (o *Range) SetMin(minimum float64) {
	log.Println("Calling Range.SetMin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(minimum)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_min", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Range) SetMax(maximum float64) {
	log.Println("Calling Range.SetMax()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(maximum)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set step value. If step is 0, stepping will be disabled.
*/
func (o *Range) SetStep(step float64) {
	log.Println("Calling Range.SetStep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(step)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_step", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set page size. Page is mainly used for scrollbars or anything that controls text scrolling.
*/
func (o *Range) SetPage(pagesize float64) {
	log.Println("Calling Range.SetPage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pagesize)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_page", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set value mapped to 0 to 1 (unit) range, it will then be converted to the actual value within min and max.
*/
func (o *Range) SetAsRatio(value float64) {
	log.Println("Calling Range.SetAsRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_as_ratio", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Range) SetUseRoundedValues(enabled bool) {
	log.Println("Calling Range.SetUseRoundedValues()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_rounded_values", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Range) IsUsingRoundedValues() bool {
	log.Println("Calling Range.IsUsingRoundedValues()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_using_rounded_values", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Range) SetExpRatio(enabled bool) {
	log.Println("Calling Range.SetExpRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_exp_ratio", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Range) IsRatioExp() bool {
	log.Println("Calling Range.IsRatioExp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_ratio_exp", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Binds two Ranges together along with any Ranges previously grouped with either of them. When any of Range's member variables change, it will share the new value with all other Ranges in its group.
*/
func (o *Range) Share(with *Object) {
	log.Println("Calling Range.Share()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(with)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "share", goArguments, "")

	log.Println("Got return value!")

}

/*
   Stop Range from sharing its member variables with any other Range.
*/
func (o *Range) Unshare() {
	log.Println("Calling Range.Unshare()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "unshare", goArguments, "")

	log.Println("Got return value!")

}

/*
   RangeImplementer is an interface for Range objects.
*/
type RangeImplementer interface {
	Class
}

/*
   Scrollbars are a [Range] based [Control], that display a draggable area (the size of the page). Horizontal ([HScrollBar]) and Vertical ([VScrollBar]) versions are available.
*/
type ScrollBar struct {
	Range
}

func (o *ScrollBar) baseClass() string {
	return "ScrollBar"
}

/*
   Undocumented
*/
func (o *ScrollBar) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling ScrollBar.X_GuiInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_gui_input", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ScrollBar) SetCustomStep(step float64) {
	log.Println("Calling ScrollBar.SetCustomStep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(step)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_step", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ScrollBar) GetCustomStep() float64 {
	log.Println("Calling ScrollBar.GetCustomStep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_custom_step", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Undocumented
*/
func (o *ScrollBar) X_DragSlaveInput(arg0 *InputEvent) {
	log.Println("Calling ScrollBar.X_DragSlaveInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_drag_slave_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScrollBar) X_DragSlaveExit() {
	log.Println("Calling ScrollBar.X_DragSlaveExit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_drag_slave_exit", goArguments, "")

	log.Println("Got return value!")

}

/*
   ScrollBarImplementer is an interface for ScrollBar objects.
*/
type ScrollBarImplementer interface {
	Class
}

/*
   Base class for GUI Sliders.
*/
type Slider struct {
	Range
}

func (o *Slider) baseClass() string {
	return "Slider"
}

/*
   Undocumented
*/
func (o *Slider) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling Slider.X_GuiInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_gui_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set amount of ticks to display in slider.
*/
func (o *Slider) SetTicks(count int64) {
	log.Println("Calling Slider.SetTicks()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(count)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ticks", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return amounts of ticks to display on slider.
*/
func (o *Slider) GetTicks() int64 {
	log.Println("Calling Slider.GetTicks()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ticks", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return true if ticks are visible on borders.
*/
func (o *Slider) GetTicksOnBorders() bool {
	log.Println("Calling Slider.GetTicksOnBorders()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ticks_on_borders", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set true if ticks are visible on borders.
*/
func (o *Slider) SetTicksOnBorders(ticksOnBorder bool) {
	log.Println("Calling Slider.SetTicksOnBorders()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ticksOnBorder)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ticks_on_borders", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Slider) SetEditable(editable bool) {
	log.Println("Calling Slider.SetEditable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(editable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_editable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Slider) IsEditable() bool {
	log.Println("Calling Slider.IsEditable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_editable", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   SliderImplementer is an interface for Slider objects.
*/
type SliderImplementer interface {
	Class
}

/*
   Popup is a base [Control] used to show dialogs and popups. It's a subwindow and modal by default (see [Control]) and has helpers for custom popup behavior.
*/
type Popup struct {
	Control
}

func (o *Popup) baseClass() string {
	return "Popup"
}

/*
   Popup (show the control in modal form) in the center of the screen, at the current size, or at a size determined by "size".
*/
func (o *Popup) PopupCentered(size *Vector2) {
	log.Println("Calling Popup.PopupCentered()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "popup_centered", goArguments, "")

	log.Println("Got return value!")

}

/*
   Popup (show the control in modal form) in the center of the screen, scaled at a ratio of size of the screen.
*/
func (o *Popup) PopupCenteredRatio(ratio float64) {
	log.Println("Calling Popup.PopupCenteredRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ratio)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "popup_centered_ratio", goArguments, "")

	log.Println("Got return value!")

}

/*
   Popup (show the control in modal form) in the center of the screen, ensuring the size is never smaller than [code]minsize[/code].
*/
func (o *Popup) PopupCenteredMinsize(minsize *Vector2) {
	log.Println("Calling Popup.PopupCenteredMinsize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(minsize)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "popup_centered_minsize", goArguments, "")

	log.Println("Got return value!")

}

/*
   Popup (show the control in modal form).
*/
func (o *Popup) Popup(bounds *Rect2) {
	log.Println("Calling Popup.Popup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bounds)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "popup", goArguments, "")

	log.Println("Got return value!")

}

/*
   Make the popup hide other popups when shown on the screen.
*/
func (o *Popup) SetExclusive(enable bool) {
	log.Println("Calling Popup.SetExclusive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_exclusive", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether the popup will hide other popups when shown on the screen.
*/
func (o *Popup) IsExclusive() bool {
	log.Println("Calling Popup.IsExclusive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_exclusive", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   PopupImplementer is an interface for Popup objects.
*/
type PopupImplementer interface {
	Class
}

/*
   Use TextureRect to draw icons and sprites in your User Interfaces. To create panels and menu boxes, take a look at [NinePatchFrame]. Its Stretch Mode property controls the texture's scale and placement. It can scale, tile and stay centered inside its bounding rectangle. TextureRect is one of the 5 most common nodes to create game UI.
*/
type TextureRect struct {
	Control
}

func (o *TextureRect) baseClass() string {
	return "TextureRect"
}

/*

 */
func (o *TextureRect) SetTexture(texture *Texture) {
	log.Println("Calling TextureRect.SetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureRect) GetTexture() *Texture {
	log.Println("Calling TextureRect.GetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TextureRect) SetExpand(enable bool) {
	log.Println("Calling TextureRect.SetExpand()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_expand", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureRect) HasExpand() bool {
	log.Println("Calling TextureRect.HasExpand()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_expand", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *TextureRect) SetStretchMode(stretchMode int64) {
	log.Println("Calling TextureRect.SetStretchMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(stretchMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_stretch_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureRect) GetStretchMode() int64 {
	log.Println("Calling TextureRect.GetStretchMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stretch_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   TextureRectImplementer is an interface for TextureRect objects.
*/
type TextureRectImplementer interface {
	Class
}

/*
   An object that is represented on the canvas as a rect with color. [Color] is used to set or get color info for the rect.
*/
type ColorRect struct {
	Control
}

func (o *ColorRect) baseClass() string {
	return "ColorRect"
}

/*
   Set new color to ColorRect. [codeblock] var cr = get_node("colorrect_node") cr.set_frame_color(Color(1, 0, 0, 1)) # Set color rect node to red [/codeblock]
*/
func (o *ColorRect) SetFrameColor(color *Color) {
	log.Println("Calling ColorRect.SetFrameColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_frame_color", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the color in RGBA format. [codeblock] var cr = get_node("colorrect_node") var c = cr.get_frame_color() # Default color is white [/codeblock]
*/
func (o *ColorRect) GetFrameColor() *Color {
	log.Println("Calling ColorRect.GetFrameColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_frame_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   ColorRectImplementer is an interface for ColorRect objects.
*/
type ColorRectImplementer interface {
	Class
}

/*
   Better known as 9-slice panels, NinePatchRect produces clean panels of any size, based on a small texture. To do so, it splits the texture in a 3 by 3 grid. When you scale the node, it tiles the texture's sides horizontally or vertically, the center on both axes but it doesn't scale or tile the corners.
*/
type NinePatchRect struct {
	Control
}

func (o *NinePatchRect) baseClass() string {
	return "NinePatchRect"
}

/*

 */
func (o *NinePatchRect) SetTexture(texture *Texture) {
	log.Println("Calling NinePatchRect.SetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NinePatchRect) GetTexture() *Texture {
	log.Println("Calling NinePatchRect.GetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *NinePatchRect) SetPatchMargin(margin int64, value int64) {
	log.Println("Calling NinePatchRect.SetPatchMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_patch_margin", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NinePatchRect) GetPatchMargin(margin int64) int64 {
	log.Println("Calling NinePatchRect.GetPatchMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_patch_margin", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *NinePatchRect) SetRegionRect(rect *Rect2) {
	log.Println("Calling NinePatchRect.SetRegionRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rect)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_region_rect", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NinePatchRect) GetRegionRect() *Rect2 {
	log.Println("Calling NinePatchRect.GetRegionRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_region_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*

 */
func (o *NinePatchRect) SetDrawCenter(drawCenter bool) {
	log.Println("Calling NinePatchRect.SetDrawCenter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(drawCenter)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_draw_center", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NinePatchRect) IsDrawCenterEnabled() bool {
	log.Println("Calling NinePatchRect.IsDrawCenterEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_draw_center_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *NinePatchRect) SetHAxisStretchMode(mode int64) {
	log.Println("Calling NinePatchRect.SetHAxisStretchMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_h_axis_stretch_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NinePatchRect) GetHAxisStretchMode() int64 {
	log.Println("Calling NinePatchRect.GetHAxisStretchMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_h_axis_stretch_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *NinePatchRect) SetVAxisStretchMode(mode int64) {
	log.Println("Calling NinePatchRect.SetVAxisStretchMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_v_axis_stretch_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NinePatchRect) GetVAxisStretchMode() int64 {
	log.Println("Calling NinePatchRect.GetVAxisStretchMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_v_axis_stretch_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   NinePatchRectImplementer is an interface for NinePatchRect objects.
*/
type NinePatchRectImplementer interface {
	Class
}

/*
   Button that can be themed with textures. This is like a regular [Button] but can be themed by assigning textures to it. This button is intended to be easy to theme, however a regular button can expand (that uses styleboxes) and still be better if the interface is expect to have internationalization of texts. Only the normal texture is required, the others are optional.
*/
type TextureButton struct {
	BaseButton
}

func (o *TextureButton) baseClass() string {
	return "TextureButton"
}

/*

 */
func (o *TextureButton) SetNormalTexture(texture *Texture) {
	log.Println("Calling TextureButton.SetNormalTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_normal_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureButton) SetPressedTexture(texture *Texture) {
	log.Println("Calling TextureButton.SetPressedTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pressed_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureButton) SetHoverTexture(texture *Texture) {
	log.Println("Calling TextureButton.SetHoverTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_hover_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureButton) SetDisabledTexture(texture *Texture) {
	log.Println("Calling TextureButton.SetDisabledTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_disabled_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureButton) SetFocusedTexture(texture *Texture) {
	log.Println("Calling TextureButton.SetFocusedTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_focused_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureButton) SetClickMask(mask *BitMap) {
	log.Println("Calling TextureButton.SetClickMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_click_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureButton) SetExpand(pExpand bool) {
	log.Println("Calling TextureButton.SetExpand()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pExpand)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_expand", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureButton) SetStretchMode(pMode int64) {
	log.Println("Calling TextureButton.SetStretchMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_stretch_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureButton) GetNormalTexture() *Texture {
	log.Println("Calling TextureButton.GetNormalTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_normal_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TextureButton) GetPressedTexture() *Texture {
	log.Println("Calling TextureButton.GetPressedTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pressed_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TextureButton) GetHoverTexture() *Texture {
	log.Println("Calling TextureButton.GetHoverTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_hover_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TextureButton) GetDisabledTexture() *Texture {
	log.Println("Calling TextureButton.GetDisabledTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_disabled_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TextureButton) GetFocusedTexture() *Texture {
	log.Println("Calling TextureButton.GetFocusedTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_focused_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TextureButton) GetClickMask() *BitMap {
	log.Println("Calling TextureButton.GetClickMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_click_mask", goArguments, "*BitMap")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*BitMap)

	return returnValue

}

/*

 */
func (o *TextureButton) GetExpand() bool {
	log.Println("Calling TextureButton.GetExpand()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_expand", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *TextureButton) GetStretchMode() int64 {
	log.Println("Calling TextureButton.GetStretchMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stretch_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   TextureButtonImplementer is an interface for TextureButton objects.
*/
type TextureButtonImplementer interface {
	Class
}

/*
   Separator is a [Control] used for separating other controls. It's purely a visual decoration. Horizontal ([HSeparator]) and Vertical ([VSeparator]) versions are available.
*/
type Separator struct {
	Control
}

func (o *Separator) baseClass() string {
	return "Separator"
}

/*
   SeparatorImplementer is an interface for Separator objects.
*/
type SeparatorImplementer interface {
	Class
}

/*
   A two-dimensional array of boolean values, can be used to efficiently store a binary matrix (every matrix element takes only one bit) and query the values using natural cartesian coordinates.
*/
type BitMap struct {
	Resource
}

func (o *BitMap) baseClass() string {
	return "BitMap"
}

/*
   Creates a bitmap with the specified size, filled with false.
*/
func (o *BitMap) Create(size *Vector2) {
	log.Println("Calling BitMap.Create()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create", goArguments, "")

	log.Println("Got return value!")

}

/*
   Creates a bitmap that matches the given image dimensions, every element of the bitmap is set to false if the alpha value of the image at that position is 0, and true in other case.
*/
func (o *BitMap) CreateFromImageAlpha(image *Image) {
	log.Println("Calling BitMap.CreateFromImageAlpha()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(image)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create_from_image_alpha", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the bitmap's element at the specified position, to the specified value.
*/
func (o *BitMap) SetBit(position *Vector2, bit bool) {
	log.Println("Calling BitMap.SetBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(position)
	goArguments[1] = reflect.ValueOf(bit)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bit", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns bitmap's value at the specified position.
*/
func (o *BitMap) GetBit(position *Vector2) bool {
	log.Println("Calling BitMap.GetBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bit", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Sets a rectangular portion of the bitmap to the specified value.
*/
func (o *BitMap) SetBitRect(pRect *Rect2, bit bool) {
	log.Println("Calling BitMap.SetBitRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(pRect)
	goArguments[1] = reflect.ValueOf(bit)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bit_rect", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the amount of bitmap elements that are set to true.
*/
func (o *BitMap) GetTrueBitCount() int64 {
	log.Println("Calling BitMap.GetTrueBitCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_true_bit_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns bitmap's dimensions.
*/
func (o *BitMap) GetSize() *Vector2 {
	log.Println("Calling BitMap.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Undocumented
*/
func (o *BitMap) X_SetData(arg0 *Dictionary) {
	log.Println("Calling BitMap.X_SetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_data", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *BitMap) X_GetData() *Dictionary {
	log.Println("Calling BitMap.X_GetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_data", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
   BitMapImplementer is an interface for BitMap objects.
*/
type BitMapImplementer interface {
	Class
}

/*
   Base node for containers. A [Container] contains other controls and automatically arranges them in a certain way. A Control can inherit this to create custom container classes.
*/
type Container struct {
	Control
}

func (o *Container) baseClass() string {
	return "Container"
}

/*
   Undocumented
*/
func (o *Container) X_SortChildren() {
	log.Println("Calling Container.X_SortChildren()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_sort_children", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Container) X_ChildMinsizeChanged() {
	log.Println("Calling Container.X_ChildMinsizeChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_child_minsize_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Queue resort of the contained children. This is called automatically anyway, but can be called upon request.
*/
func (o *Container) QueueSort() {
	log.Println("Calling Container.QueueSort()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "queue_sort", goArguments, "")

	log.Println("Got return value!")

}

/*
   Fit a child control in a given rect. This is mainly a helper for creating custom container classes.
*/
func (o *Container) FitChildInRect(child *Object, rect *Rect2) {
	log.Println("Calling Container.FitChildInRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(child)
	goArguments[1] = reflect.ValueOf(rect)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "fit_child_in_rect", goArguments, "")

	log.Println("Got return value!")

}

/*
   ContainerImplementer is an interface for Container objects.
*/
type ContainerImplementer interface {
	Class
}

/*
   Arranges child controls vertically or horizontally, and rearranges the controls automatically when their minimum size changes.
*/
type BoxContainer struct {
	Container
}

func (o *BoxContainer) baseClass() string {
	return "BoxContainer"
}

/*
   Adds a control to the box as a spacer. If [code]true[/code], [i]begin[/i] will insert the spacer control in front of other children.
*/
func (o *BoxContainer) AddSpacer(begin bool) {
	log.Println("Calling BoxContainer.AddSpacer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(begin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_spacer", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the alignment of children in the container.
*/
func (o *BoxContainer) GetAlignment() int64 {
	log.Println("Calling BoxContainer.GetAlignment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_alignment", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the alignment of children in the container(Must be one of ALIGN_BEGIN, ALIGN_CENTER or ALIGN_END).
*/
func (o *BoxContainer) SetAlignment(alignment int64) {
	log.Println("Calling BoxContainer.SetAlignment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(alignment)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_alignment", goArguments, "")

	log.Println("Got return value!")

}

/*
   BoxContainerImplementer is an interface for BoxContainer objects.
*/
type BoxContainerImplementer interface {
	Class
}

/*
   CenterContainer Keeps children controls centered. This container keeps all children to their minimum size, in the center.
*/
type CenterContainer struct {
	Container
}

func (o *CenterContainer) baseClass() string {
	return "CenterContainer"
}

/*
   This function will anchor the container children to the top left corner of the the container boundaries, moving all its children to that position, (the children new center will be the top left corner of the container).
*/
func (o *CenterContainer) SetUseTopLeft(enable bool) {
	log.Println("Calling CenterContainer.SetUseTopLeft()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_top_left", goArguments, "")

	log.Println("Got return value!")

}

/*
   Should put children to the top left corner instead of center of the container.
*/
func (o *CenterContainer) IsUsingTopLeft() bool {
	log.Println("Calling CenterContainer.IsUsingTopLeft()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_using_top_left", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   CenterContainerImplementer is an interface for CenterContainer objects.
*/
type CenterContainerImplementer interface {
	Class
}

/*
   A ScrollContainer node with a [Control] child and scrollbar child ([HScrollbar], [VScrollBar], or both) will only draw the Control within the ScrollContainer area. Scrollbars will automatically be drawn at the right (for vertical) or bottom (for horizontal) and will enable dragging to move the viewable Control (and its children) within the ScrollContainer. Scrollbars will also automatically resize the grabber based on the minimum_size of the Control relative to the ScrollContainer. Works great with a [Panel] control. You can set EXPAND on children size flags, so they will upscale to ScrollContainer size if ScrollContainer size is bigger (scroll is invisible for chosen dimension).
*/
type ScrollContainer struct {
	Container
}

func (o *ScrollContainer) baseClass() string {
	return "ScrollContainer"
}

/*
   Undocumented
*/
func (o *ScrollContainer) X_ScrollMoved(arg0 float64) {
	log.Println("Calling ScrollContainer.X_ScrollMoved()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_scroll_moved", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScrollContainer) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling ScrollContainer.X_GuiInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_gui_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set allows horizontal scroll.
*/
func (o *ScrollContainer) SetEnableHScroll(enable bool) {
	log.Println("Calling ScrollContainer.SetEnableHScroll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enable_h_scroll", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if horizontal scroll is allowed.
*/
func (o *ScrollContainer) IsHScrollEnabled() bool {
	log.Println("Calling ScrollContainer.IsHScrollEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_h_scroll_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set allows vertical scroll.
*/
func (o *ScrollContainer) SetEnableVScroll(enable bool) {
	log.Println("Calling ScrollContainer.SetEnableVScroll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enable_v_scroll", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if vertical scroll is allowed.
*/
func (o *ScrollContainer) IsVScrollEnabled() bool {
	log.Println("Calling ScrollContainer.IsVScrollEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_v_scroll_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *ScrollContainer) X_UpdateScrollbarPosition() {
	log.Println("Calling ScrollContainer.X_UpdateScrollbarPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_update_scrollbar_position", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set horizontal scroll value.
*/
func (o *ScrollContainer) SetHScroll(val int64) {
	log.Println("Calling ScrollContainer.SetHScroll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_h_scroll", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return current horizontal scroll value.
*/
func (o *ScrollContainer) GetHScroll() int64 {
	log.Println("Calling ScrollContainer.GetHScroll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_h_scroll", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set vertical scroll value.
*/
func (o *ScrollContainer) SetVScroll(val int64) {
	log.Println("Calling ScrollContainer.SetVScroll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_v_scroll", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return current vertical scroll value.
*/
func (o *ScrollContainer) GetVScroll() int64 {
	log.Println("Calling ScrollContainer.GetVScroll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_v_scroll", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   ScrollContainerImplementer is an interface for ScrollContainer objects.
*/
type ScrollContainerImplementer interface {
	Class
}

/*
   Container for splitting two controls vertically or horizontally, with a grabber that allows adjusting the split offset or ratio.
*/
type SplitContainer struct {
	Container
}

func (o *SplitContainer) baseClass() string {
	return "SplitContainer"
}

/*
   Undocumented
*/
func (o *SplitContainer) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling SplitContainer.X_GuiInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_gui_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the split offset.
*/
func (o *SplitContainer) SetSplitOffset(offset int64) {
	log.Println("Calling SplitContainer.SetSplitOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_split_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the split offset.
*/
func (o *SplitContainer) GetSplitOffset() int64 {
	log.Println("Calling SplitContainer.GetSplitOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_split_offset", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set if the split must be collapsed.
*/
func (o *SplitContainer) SetCollapsed(collapsed bool) {
	log.Println("Calling SplitContainer.SetCollapsed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collapsed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collapsed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if the split is collapsed.
*/
func (o *SplitContainer) IsCollapsed() bool {
	log.Println("Calling SplitContainer.IsCollapsed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_collapsed", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set visibility of the split dragger ([i]mode[/i] must be one of [DRAGGER_VISIBLE], [DRAGGER_HIDDEN] or [DRAGGER_HIDDEN_COLLAPSED]).
*/
func (o *SplitContainer) SetDraggerVisibility(mode int64) {
	log.Println("Calling SplitContainer.SetDraggerVisibility()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dragger_visibility", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return visibility of the split dragger (one of [DRAGGER_VISIBLE], [DRAGGER_HIDDEN] or [DRAGGER_HIDDEN_COLLAPSED]).
*/
func (o *SplitContainer) GetDraggerVisibility() int64 {
	log.Println("Calling SplitContainer.GetDraggerVisibility()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dragger_visibility", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   SplitContainerImplementer is an interface for SplitContainer objects.
*/
type SplitContainerImplementer interface {
	Class
}

/*
   A [ProgressBar] that uses textures to display fill percentage. Can be set to linear or radial mode.
*/
type TextureProgress struct {
	Range
}

func (o *TextureProgress) baseClass() string {
	return "TextureProgress"
}

/*

 */
func (o *TextureProgress) SetUnderTexture(tex *Texture) {
	log.Println("Calling TextureProgress.SetUnderTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tex)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_under_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureProgress) GetUnderTexture() *Texture {
	log.Println("Calling TextureProgress.GetUnderTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_under_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TextureProgress) SetProgressTexture(tex *Texture) {
	log.Println("Calling TextureProgress.SetProgressTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tex)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_progress_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureProgress) GetProgressTexture() *Texture {
	log.Println("Calling TextureProgress.GetProgressTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_progress_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TextureProgress) SetOverTexture(tex *Texture) {
	log.Println("Calling TextureProgress.SetOverTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tex)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_over_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureProgress) GetOverTexture() *Texture {
	log.Println("Calling TextureProgress.GetOverTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_over_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TextureProgress) SetFillMode(mode int64) {
	log.Println("Calling TextureProgress.SetFillMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fill_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureProgress) GetFillMode() int64 {
	log.Println("Calling TextureProgress.GetFillMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fill_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *TextureProgress) SetRadialInitialAngle(mode float64) {
	log.Println("Calling TextureProgress.SetRadialInitialAngle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_radial_initial_angle", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureProgress) GetRadialInitialAngle() float64 {
	log.Println("Calling TextureProgress.GetRadialInitialAngle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_radial_initial_angle", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *TextureProgress) SetRadialCenterOffset(mode *Vector2) {
	log.Println("Calling TextureProgress.SetRadialCenterOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_radial_center_offset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureProgress) GetRadialCenterOffset() *Vector2 {
	log.Println("Calling TextureProgress.GetRadialCenterOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_radial_center_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *TextureProgress) SetFillDegrees(mode float64) {
	log.Println("Calling TextureProgress.SetFillDegrees()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fill_degrees", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureProgress) GetFillDegrees() float64 {
	log.Println("Calling TextureProgress.GetFillDegrees()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fill_degrees", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set nine-patch texture offset for a given margin (MARGIN_LEFT, MARGIN_TOP, MARGIN_RIGHT, MARGIN_BOTTOM).
*/
func (o *TextureProgress) SetStretchMargin(margin int64, value int64) {
	log.Println("Calling TextureProgress.SetStretchMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_stretch_margin", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return nine-patch texture offset for a given margin (MARGIN_LEFT, MARGIN_TOP, MARGIN_RIGHT, MARGIN_BOTTOM).
*/
func (o *TextureProgress) GetStretchMargin(margin int64) int64 {
	log.Println("Calling TextureProgress.GetStretchMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stretch_margin", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set if textures should be stretched as nine-patches.
*/
func (o *TextureProgress) SetNinePatchStretch(stretch bool) {
	log.Println("Calling TextureProgress.SetNinePatchStretch()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(stretch)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_nine_patch_stretch", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns true if textures are stretched as nine-patches or false otherwise.
*/
func (o *TextureProgress) GetNinePatchStretch() bool {
	log.Println("Calling TextureProgress.GetNinePatchStretch()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_nine_patch_stretch", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   TextureProgressImplementer is an interface for TextureProgress objects.
*/
type TextureProgressImplementer interface {
	Class
}

/*
   This dialog is useful for small notifications to the user about an event. It can only be accepted or closed, with the same result.
*/
type AcceptDialog struct {
	WindowDialog
}

func (o *AcceptDialog) baseClass() string {
	return "AcceptDialog"
}

/*
   Undocumented
*/
func (o *AcceptDialog) X_Ok() {
	log.Println("Calling AcceptDialog.X_Ok()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_ok", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the OK Button.
*/
func (o *AcceptDialog) GetOk() *Button {
	log.Println("Calling AcceptDialog.GetOk()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ok", goArguments, "*Button")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Button)

	return returnValue

}

/*
   Return the label used for built-in text.
*/
func (o *AcceptDialog) GetLabel() *Label {
	log.Println("Calling AcceptDialog.GetLabel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_label", goArguments, "*Label")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Label)

	return returnValue

}

/*
   Set whether the dialog is hidden when accepted (default true).
*/
func (o *AcceptDialog) SetHideOnOk(enabled bool) {
	log.Println("Calling AcceptDialog.SetHideOnOk()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_hide_on_ok", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if the dialog will be hidden when accepted (default true).
*/
func (o *AcceptDialog) GetHideOnOk() bool {
	log.Println("Calling AcceptDialog.GetHideOnOk()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_hide_on_ok", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Adds a button with label [i]text[/i] and a custom [i]action[/i] to the dialog and returns the created button. [i]action[/i] will be passed to the [custom_action] signal when pressed. If [code]true[/code], [i]right[/i] will place the button to the right of any sibling buttons. Default value: [code]false[/code].
*/
func (o *AcceptDialog) AddButton(text string, right bool, action string) *Button {
	log.Println("Calling AcceptDialog.AddButton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(text)
	goArguments[1] = reflect.ValueOf(right)
	goArguments[2] = reflect.ValueOf(action)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "add_button", goArguments, "*Button")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Button)

	return returnValue

}

/*
   Adds a button with label [i]name[/i] and a cancel action to the dialog and returns the created button.
*/
func (o *AcceptDialog) AddCancel(name string) *Button {
	log.Println("Calling AcceptDialog.AddCancel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "add_cancel", goArguments, "*Button")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Button)

	return returnValue

}

/*
   Undocumented
*/
func (o *AcceptDialog) X_BuiltinTextEntered(arg0 string) {
	log.Println("Calling AcceptDialog.X_BuiltinTextEntered()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_builtin_text_entered", goArguments, "")

	log.Println("Got return value!")

}

/*
   Registers a [LineEdit] in the dialog. When the enter key is pressed, the dialog will be accepted.
*/
func (o *AcceptDialog) RegisterTextEnter(lineEdit *Object) {
	log.Println("Calling AcceptDialog.RegisterTextEnter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(lineEdit)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "register_text_enter", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *AcceptDialog) X_CustomAction(arg0 string) {
	log.Println("Calling AcceptDialog.X_CustomAction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_custom_action", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the built-in label text.
*/
func (o *AcceptDialog) SetText(text string) {
	log.Println("Calling AcceptDialog.SetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_text", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the built-in label text.
*/
func (o *AcceptDialog) GetText() string {
	log.Println("Calling AcceptDialog.GetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   AcceptDialogImplementer is an interface for AcceptDialog objects.
*/
type AcceptDialogImplementer interface {
	Class
}

/*
   Dialog for confirmation of actions. This dialog inherits from [AcceptDialog], but has by default an OK and Cancel button (in host OS order).
*/
type ConfirmationDialog struct {
	AcceptDialog
}

func (o *ConfirmationDialog) baseClass() string {
	return "ConfirmationDialog"
}

/*
   Return the cancel button.
*/
func (o *ConfirmationDialog) GetCancel() *Button {
	log.Println("Calling ConfirmationDialog.GetCancel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cancel", goArguments, "*Button")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Button)

	return returnValue

}

/*
   ConfirmationDialogImplementer is an interface for ConfirmationDialog objects.
*/
type ConfirmationDialogImplementer interface {
	Class
}

/*

 */
type TreeItem struct {
	Object
}

func (o *TreeItem) baseClass() string {
	return "TreeItem"
}

/*

 */
func (o *TreeItem) SetCellMode(column int64, mode int64) {
	log.Println("Calling TreeItem.SetCellMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cell_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) GetCellMode(column int64) int64 {
	log.Println("Calling TreeItem.GetCellMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cell_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *TreeItem) SetChecked(column int64, checked bool) {
	log.Println("Calling TreeItem.SetChecked()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(checked)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_checked", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) IsChecked(column int64) bool {
	log.Println("Calling TreeItem.IsChecked()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_checked", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *TreeItem) SetText(column int64, text string) {
	log.Println("Calling TreeItem.SetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_text", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) GetText(column int64) string {
	log.Println("Calling TreeItem.GetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *TreeItem) SetIcon(column int64, texture *Texture) {
	log.Println("Calling TreeItem.SetIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_icon", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) GetIcon(column int64) *Texture {
	log.Println("Calling TreeItem.GetIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_icon", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TreeItem) SetIconRegion(column int64, region *Rect2) {
	log.Println("Calling TreeItem.SetIconRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(region)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_icon_region", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) GetIconRegion(column int64) *Rect2 {
	log.Println("Calling TreeItem.GetIconRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_icon_region", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*

 */
func (o *TreeItem) SetIconMaxWidth(column int64, width int64) {
	log.Println("Calling TreeItem.SetIconMaxWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(width)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_icon_max_width", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) GetIconMaxWidth(column int64) int64 {
	log.Println("Calling TreeItem.GetIconMaxWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_icon_max_width", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *TreeItem) SetRange(column int64, value float64) {
	log.Println("Calling TreeItem.SetRange()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_range", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) GetRange(column int64) float64 {
	log.Println("Calling TreeItem.GetRange()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_range", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *TreeItem) SetRangeConfig(column int64, min float64, max float64, step float64, expr bool) {
	log.Println("Calling TreeItem.SetRangeConfig()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(min)
	goArguments[2] = reflect.ValueOf(max)
	goArguments[3] = reflect.ValueOf(step)
	goArguments[4] = reflect.ValueOf(expr)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_range_config", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) GetRangeConfig(column int64) *Dictionary {
	log.Println("Calling TreeItem.GetRangeConfig()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_range_config", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*

 */
func (o *TreeItem) SetMetadata(column int64, meta *Variant) {
	log.Println("Calling TreeItem.SetMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(meta)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_metadata", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) GetMetadata(column int64) *Variant {
	log.Println("Calling TreeItem.GetMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_metadata", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *TreeItem) SetCustomDraw(column int64, object *Object, callback string) {
	log.Println("Calling TreeItem.SetCustomDraw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(object)
	goArguments[2] = reflect.ValueOf(callback)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_draw", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) SetCollapsed(enable bool) {
	log.Println("Calling TreeItem.SetCollapsed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collapsed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) IsCollapsed() bool {
	log.Println("Calling TreeItem.IsCollapsed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_collapsed", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *TreeItem) SetCustomMinimumHeight(height int64) {
	log.Println("Calling TreeItem.SetCustomMinimumHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(height)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_minimum_height", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) GetCustomMinimumHeight() int64 {
	log.Println("Calling TreeItem.GetCustomMinimumHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_custom_minimum_height", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *TreeItem) GetNext() *TreeItem {
	log.Println("Calling TreeItem.GetNext()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_next", goArguments, "*TreeItem")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TreeItem)

	return returnValue

}

/*

 */
func (o *TreeItem) GetPrev() *TreeItem {
	log.Println("Calling TreeItem.GetPrev()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_prev", goArguments, "*TreeItem")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TreeItem)

	return returnValue

}

/*

 */
func (o *TreeItem) GetParent() *TreeItem {
	log.Println("Calling TreeItem.GetParent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_parent", goArguments, "*TreeItem")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TreeItem)

	return returnValue

}

/*

 */
func (o *TreeItem) GetChildren() *TreeItem {
	log.Println("Calling TreeItem.GetChildren()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_children", goArguments, "*TreeItem")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TreeItem)

	return returnValue

}

/*

 */
func (o *TreeItem) GetNextVisible() *TreeItem {
	log.Println("Calling TreeItem.GetNextVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_next_visible", goArguments, "*TreeItem")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TreeItem)

	return returnValue

}

/*

 */
func (o *TreeItem) GetPrevVisible() *TreeItem {
	log.Println("Calling TreeItem.GetPrevVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_prev_visible", goArguments, "*TreeItem")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TreeItem)

	return returnValue

}

/*

 */
func (o *TreeItem) RemoveChild(child *Object) {
	log.Println("Calling TreeItem.RemoveChild()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(child)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_child", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) SetSelectable(column int64, selectable bool) {
	log.Println("Calling TreeItem.SetSelectable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(selectable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_selectable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) IsSelectable(column int64) bool {
	log.Println("Calling TreeItem.IsSelectable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_selectable", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *TreeItem) IsSelected(column int64) bool {
	log.Println("Calling TreeItem.IsSelected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_selected", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *TreeItem) Select(column int64) {
	log.Println("Calling TreeItem.Select()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "select", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) Deselect(column int64) {
	log.Println("Calling TreeItem.Deselect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "deselect", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) SetEditable(column int64, enabled bool) {
	log.Println("Calling TreeItem.SetEditable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_editable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) IsEditable(column int64) bool {
	log.Println("Calling TreeItem.IsEditable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_editable", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *TreeItem) SetCustomColor(column int64, color *Color) {
	log.Println("Calling TreeItem.SetCustomColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) ClearCustomColor(column int64) {
	log.Println("Calling TreeItem.ClearCustomColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_custom_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) SetCustomBgColor(column int64, color *Color, justOutline bool) {
	log.Println("Calling TreeItem.SetCustomBgColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(color)
	goArguments[2] = reflect.ValueOf(justOutline)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_bg_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) ClearCustomBgColor(column int64) {
	log.Println("Calling TreeItem.ClearCustomBgColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_custom_bg_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) GetCustomBgColor(column int64) *Color {
	log.Println("Calling TreeItem.GetCustomBgColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_custom_bg_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *TreeItem) SetCustomAsButton(column int64, enable bool) {
	log.Println("Calling TreeItem.SetCustomAsButton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_as_button", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) IsCustomSetAsButton(column int64) bool {
	log.Println("Calling TreeItem.IsCustomSetAsButton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_custom_set_as_button", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *TreeItem) AddButton(column int64, button *Texture, buttonIdx int64, disabled bool, tooltip string) {
	log.Println("Calling TreeItem.AddButton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(button)
	goArguments[2] = reflect.ValueOf(buttonIdx)
	goArguments[3] = reflect.ValueOf(disabled)
	goArguments[4] = reflect.ValueOf(tooltip)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_button", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) GetButtonCount(column int64) int64 {
	log.Println("Calling TreeItem.GetButtonCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_button_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *TreeItem) GetButton(column int64, buttonIdx int64) *Texture {
	log.Println("Calling TreeItem.GetButton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(buttonIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_button", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TreeItem) SetButton(column int64, buttonIdx int64, button *Texture) {
	log.Println("Calling TreeItem.SetButton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(buttonIdx)
	goArguments[2] = reflect.ValueOf(button)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_button", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) EraseButton(column int64, buttonIdx int64) {
	log.Println("Calling TreeItem.EraseButton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(buttonIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "erase_button", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) IsButtonDisabled(column int64, buttonIdx int64) bool {
	log.Println("Calling TreeItem.IsButtonDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(buttonIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_button_disabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *TreeItem) SetExpandRight(column int64, enable bool) {
	log.Println("Calling TreeItem.SetExpandRight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_expand_right", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) GetExpandRight(column int64) bool {
	log.Println("Calling TreeItem.GetExpandRight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_expand_right", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *TreeItem) SetTooltip(column int64, tooltip string) {
	log.Println("Calling TreeItem.SetTooltip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(tooltip)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tooltip", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) GetTooltip(column int64) string {
	log.Println("Calling TreeItem.GetTooltip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tooltip", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *TreeItem) SetTextAlign(column int64, textAlign int64) {
	log.Println("Calling TreeItem.SetTextAlign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(textAlign)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_text_align", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) GetTextAlign(column int64) int64 {
	log.Println("Calling TreeItem.GetTextAlign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_text_align", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *TreeItem) MoveToTop() {
	log.Println("Calling TreeItem.MoveToTop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "move_to_top", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) MoveToBottom() {
	log.Println("Calling TreeItem.MoveToBottom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "move_to_bottom", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) SetDisableFolding(disable bool) {
	log.Println("Calling TreeItem.SetDisableFolding()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(disable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_disable_folding", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) IsFoldingDisabled() bool {
	log.Println("Calling TreeItem.IsFoldingDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_folding_disabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   TreeItemImplementer is an interface for TreeItem objects.
*/
type TreeItemImplementer interface {
	Class
}

/*
   This control has the ability to play video streams. The only format accepted is the OGV Theora, so any other format must be converted before using in a project.
*/
type VideoPlayer struct {
	Control
}

func (o *VideoPlayer) baseClass() string {
	return "VideoPlayer"
}

/*
   Set the video stream for this player.
*/
func (o *VideoPlayer) SetStream(stream *VideoStream) {
	log.Println("Calling VideoPlayer.SetStream()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(stream)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_stream", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the video stream.
*/
func (o *VideoPlayer) GetStream() *VideoStream {
	log.Println("Calling VideoPlayer.GetStream()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stream", goArguments, "*VideoStream")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*VideoStream)

	return returnValue

}

/*
   Start the video playback.
*/
func (o *VideoPlayer) Play() {
	log.Println("Calling VideoPlayer.Play()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "play", goArguments, "")

	log.Println("Got return value!")

}

/*
   Stop the video playback.
*/
func (o *VideoPlayer) Stop() {
	log.Println("Calling VideoPlayer.Stop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "stop", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get whether or not the video is playing.
*/
func (o *VideoPlayer) IsPlaying() bool {
	log.Println("Calling VideoPlayer.IsPlaying()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_playing", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set whether the video should pause the playback.
*/
func (o *VideoPlayer) SetPaused(paused bool) {
	log.Println("Calling VideoPlayer.SetPaused()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(paused)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_paused", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get whether or not the video is paused.
*/
func (o *VideoPlayer) IsPaused() bool {
	log.Println("Calling VideoPlayer.IsPaused()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_paused", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the audio volume as a linear value.
*/
func (o *VideoPlayer) SetVolume(volume float64) {
	log.Println("Calling VideoPlayer.SetVolume()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(volume)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_volume", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the volume of the audio track as a linear value.
*/
func (o *VideoPlayer) GetVolume() float64 {
	log.Println("Calling VideoPlayer.GetVolume()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_volume", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the audio volume in decibels.
*/
func (o *VideoPlayer) SetVolumeDb(db float64) {
	log.Println("Calling VideoPlayer.SetVolumeDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(db)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_volume_db", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the volume of the audio track in decibels.
*/
func (o *VideoPlayer) GetVolumeDb() float64 {
	log.Println("Calling VideoPlayer.GetVolumeDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_volume_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the audio track (for multitrack videos).
*/
func (o *VideoPlayer) SetAudioTrack(track int64) {
	log.Println("Calling VideoPlayer.SetAudioTrack()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(track)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_audio_track", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the selected audio track (for multitrack videos).
*/
func (o *VideoPlayer) GetAudioTrack() int64 {
	log.Println("Calling VideoPlayer.GetAudioTrack()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_audio_track", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the name of the video stream.
*/
func (o *VideoPlayer) GetStreamName() string {
	log.Println("Calling VideoPlayer.GetStreamName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stream_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the current position of the stream, in seconds.
*/
func (o *VideoPlayer) GetStreamPosition() float64 {
	log.Println("Calling VideoPlayer.GetStreamPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stream_position", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set whether this node should start playing automatically.
*/
func (o *VideoPlayer) SetAutoplay(enabled bool) {
	log.Println("Calling VideoPlayer.SetAutoplay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_autoplay", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get whether or not the video is set as autoplay.
*/
func (o *VideoPlayer) HasAutoplay() bool {
	log.Println("Calling VideoPlayer.HasAutoplay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_autoplay", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the expand property. If enabled, the video will grow or shrink to fit the player size, otherwise it will play at the stream resolution.
*/
func (o *VideoPlayer) SetExpand(enable bool) {
	log.Println("Calling VideoPlayer.SetExpand()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_expand", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get whether or not the expand property is set.
*/
func (o *VideoPlayer) HasExpand() bool {
	log.Println("Calling VideoPlayer.HasExpand()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_expand", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the amount of miliseconds to buffer during playback.
*/
func (o *VideoPlayer) SetBufferingMsec(msec int64) {
	log.Println("Calling VideoPlayer.SetBufferingMsec()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(msec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_buffering_msec", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the amount of miliseconds to store in buffer while playing.
*/
func (o *VideoPlayer) GetBufferingMsec() int64 {
	log.Println("Calling VideoPlayer.GetBufferingMsec()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_buffering_msec", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the current frame of the video as a [Texture].
*/
func (o *VideoPlayer) GetVideoTexture() *Texture {
	log.Println("Calling VideoPlayer.GetVideoTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_video_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   VideoPlayerImplementer is an interface for VideoPlayer objects.
*/
type VideoPlayerImplementer interface {
	Class
}

/*
   PopupDialog is a base class for popup dialogs, along with [WindowDialog].
*/
type PopupDialog struct {
	Popup
}

func (o *PopupDialog) baseClass() string {
	return "PopupDialog"
}

/*
   PopupDialogImplementer is an interface for PopupDialog objects.
*/
type PopupDialogImplementer interface {
	Class
}

/*

 */
type VideoStream struct {
	Resource
}

func (o *VideoStream) baseClass() string {
	return "VideoStream"
}

/*
   VideoStreamImplementer is an interface for VideoStream objects.
*/
type VideoStreamImplementer interface {
	Class
}

/*

 */
type ViewportContainer struct {
	Container
}

func (o *ViewportContainer) baseClass() string {
	return "ViewportContainer"
}

/*

 */
func (o *ViewportContainer) SetStretch(enable bool) {
	log.Println("Calling ViewportContainer.SetStretch()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_stretch", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ViewportContainer) IsStretchEnabled() bool {
	log.Println("Calling ViewportContainer.IsStretchEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_stretch_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   ViewportContainerImplementer is an interface for ViewportContainer objects.
*/
type ViewportContainerImplementer interface {
	Class
}

/*
   Most basic 3D game object, with a 3D [Transform] and visibility settings. All other 3D game objects inherit from Spatial. Use Spatial as a parent node to move, scale, rotate and show/hide children in a 3D project.
*/
type Spatial struct {
	Node
}

func (o *Spatial) baseClass() string {
	return "Spatial"
}

/*
   Set the transform locally, relative to the parent spatial node.
*/
func (o *Spatial) SetTransform(local *Transform) {
	log.Println("Calling Spatial.SetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(local)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the local transform, relative to the bone parent.
*/
func (o *Spatial) GetTransform() *Transform {
	log.Println("Calling Spatial.GetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_transform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*

 */
func (o *Spatial) SetTranslation(translation *Vector3) {
	log.Println("Calling Spatial.SetTranslation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(translation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_translation", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Spatial) GetTranslation() *Vector3 {
	log.Println("Calling Spatial.GetTranslation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_translation", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Set the rotation (in radians).
*/
func (o *Spatial) SetRotation(rotationRad *Vector3) {
	log.Println("Calling Spatial.SetRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rotationRad)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rotation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the rotation (in radians).
*/
func (o *Spatial) GetRotation() *Vector3 {
	log.Println("Calling Spatial.GetRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rotation", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Set the rotation (in degrees).
*/
func (o *Spatial) SetRotationDeg(rotationDeg *Vector3) {
	log.Println("Calling Spatial.SetRotationDeg()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rotationDeg)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rotation_deg", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the rotation (in degrees).
*/
func (o *Spatial) GetRotationDeg() *Vector3 {
	log.Println("Calling Spatial.GetRotationDeg()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rotation_deg", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Set the scale.
*/
func (o *Spatial) SetScale(scale *Vector3) {
	log.Println("Calling Spatial.SetScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Spatial) GetScale() *Vector3 {
	log.Println("Calling Spatial.GetScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scale", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Set the transform globally, relative to world space.
*/
func (o *Spatial) SetGlobalTransform(global *Transform) {
	log.Println("Calling Spatial.SetGlobalTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(global)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_global_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the global transform, relative to worldspace.
*/
func (o *Spatial) GetGlobalTransform() *Transform {
	log.Println("Calling Spatial.GetGlobalTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_global_transform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*
   Returns the parent [Spatial], or an empty [Object] if no parent exists or parent is not of type [Spatial].
*/
func (o *Spatial) GetParentSpatial() *Spatial {
	log.Println("Calling Spatial.GetParentSpatial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_parent_spatial", goArguments, "*Spatial")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Spatial)

	return returnValue

}

/*
   Set whether the node ignores notification that its transformation (global or local) changed.
*/
func (o *Spatial) SetIgnoreTransformNotification(enabled bool) {
	log.Println("Calling Spatial.SetIgnoreTransformNotification()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ignore_transform_notification", goArguments, "")

	log.Println("Got return value!")

}

/*
   Makes the node ignore its parents tranformations. Node tranformations are only in global space.
*/
func (o *Spatial) SetAsToplevel(enable bool) {
	log.Println("Calling Spatial.SetAsToplevel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_as_toplevel", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether this node is set as Toplevel, that is whether it ignores its parent nodes transformations.
*/
func (o *Spatial) IsSetAsToplevel() bool {
	log.Println("Calling Spatial.IsSetAsToplevel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_set_as_toplevel", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns the current [World] resource this Spatial node is registered to.
*/
func (o *Spatial) GetWorld() *World {
	log.Println("Calling Spatial.GetWorld()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_world", goArguments, "*World")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*World)

	return returnValue

}

/*
   Undocumented
*/
func (o *Spatial) X_SetRotationDeg(rotationDeg *Vector3) {
	log.Println("Calling Spatial.X_SetRotationDeg()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rotationDeg)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_rotation_deg", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Spatial) X_GetRotationDeg() *Vector3 {
	log.Println("Calling Spatial.X_GetRotationDeg()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_rotation_deg", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Undocumented
*/
func (o *Spatial) X_UpdateGizmo() {
	log.Println("Calling Spatial.X_UpdateGizmo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_update_gizmo", goArguments, "")

	log.Println("Got return value!")

}

/*
   Updates the [SpatialGizmo] of this node.
*/
func (o *Spatial) UpdateGizmo() {
	log.Println("Calling Spatial.UpdateGizmo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "update_gizmo", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set [SpatialGizmo] for this node. Used for example in [EditorSpatialGizmo] as custom visualization and editing handles in Editor.
*/
func (o *Spatial) SetGizmo(gizmo *SpatialGizmo) {
	log.Println("Calling Spatial.SetGizmo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(gizmo)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gizmo", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the SpatialGizmo for this node. Used for example in [EditorSpatialGizmo] as custom visualization and editing handles in Editor.
*/
func (o *Spatial) GetGizmo() *SpatialGizmo {
	log.Println("Calling Spatial.GetGizmo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gizmo", goArguments, "*SpatialGizmo")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*SpatialGizmo)

	return returnValue

}

/*

 */
func (o *Spatial) SetVisible(visible bool) {
	log.Println("Calling Spatial.SetVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(visible)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_visible", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether the node is set to be visible.
*/
func (o *Spatial) IsVisible() bool {
	log.Println("Calling Spatial.IsVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_visible", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns whether the node is visible, taking into consideration that its parents visibility.
*/
func (o *Spatial) IsVisibleInTree() bool {
	log.Println("Calling Spatial.IsVisibleInTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_visible_in_tree", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Enables rendering of this node. Change Spatial Visible property to "True".
*/
func (o *Spatial) Show() {
	log.Println("Calling Spatial.Show()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "show", goArguments, "")

	log.Println("Got return value!")

}

/*
   Disables rendering of this node. Change Spatial Visible property to false.
*/
func (o *Spatial) Hide() {
	log.Println("Calling Spatial.Hide()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "hide", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether the node notifies about its local transformation changes. Spatial will not propagate this by default.
*/
func (o *Spatial) SetNotifyLocalTransform(enable bool) {
	log.Println("Calling Spatial.SetNotifyLocalTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_notify_local_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether node notifies about its local transformation changes. Spatial will not propagate this by default.
*/
func (o *Spatial) IsLocalTransformNotificationEnabled() bool {
	log.Println("Calling Spatial.IsLocalTransformNotificationEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_local_transform_notification_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set whether the node notifies about its global and local transformation changes. Spatial will not propagate this by default.
*/
func (o *Spatial) SetNotifyTransform(enable bool) {
	log.Println("Calling Spatial.SetNotifyTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_notify_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether the node notifies about its global and local transformation changes. Spatial will not propagate this by default.
*/
func (o *Spatial) IsTransformNotificationEnabled() bool {
	log.Println("Calling Spatial.IsTransformNotificationEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_transform_notification_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Rotates the node in local space on given normal [Vector3] by angle in radians.
*/
func (o *Spatial) Rotate(normal *Vector3, radians float64) {
	log.Println("Calling Spatial.Rotate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(normal)
	goArguments[1] = reflect.ValueOf(radians)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rotate", goArguments, "")

	log.Println("Got return value!")

}

/*
   Rotates the current node along normal [Vector3] by angle in radians in Global space.
*/
func (o *Spatial) GlobalRotate(normal *Vector3, radians float64) {
	log.Println("Calling Spatial.GlobalRotate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(normal)
	goArguments[1] = reflect.ValueOf(radians)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "global_rotate", goArguments, "")

	log.Println("Got return value!")

}

/*
   Rotates the node in local space on X axis by angle in radians.
*/
func (o *Spatial) RotateX(radians float64) {
	log.Println("Calling Spatial.RotateX()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radians)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rotate_x", goArguments, "")

	log.Println("Got return value!")

}

/*
   Rotates the node in local space on Y axis by angle in radians.
*/
func (o *Spatial) RotateY(radians float64) {
	log.Println("Calling Spatial.RotateY()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radians)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rotate_y", goArguments, "")

	log.Println("Got return value!")

}

/*
   Rotates the node in local space on Z axis by angle in radians.
*/
func (o *Spatial) RotateZ(radians float64) {
	log.Println("Calling Spatial.RotateZ()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radians)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rotate_z", goArguments, "")

	log.Println("Got return value!")

}

/*
   Changes the node's position by given offset [Vector3].
*/
func (o *Spatial) Translate(offset *Vector3) {
	log.Println("Calling Spatial.Translate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "translate", goArguments, "")

	log.Println("Got return value!")

}

/*
   Moves the node by [Vector3] offset in Global space.
*/
func (o *Spatial) GlobalTranslate(offset *Vector3) {
	log.Println("Calling Spatial.GlobalTranslate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "global_translate", goArguments, "")

	log.Println("Got return value!")

}

/*
   Resets this node's transformations (like scale, skew and taper) preserving its rotation and translation. Performs orthonormalization on this node [Transform3D].
*/
func (o *Spatial) Orthonormalize() {
	log.Println("Calling Spatial.Orthonormalize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "orthonormalize", goArguments, "")

	log.Println("Got return value!")

}

/*
   Reset all tranformations for this node. Set its [Transform3D] to identity matrix.
*/
func (o *Spatial) SetIdentity() {
	log.Println("Calling Spatial.SetIdentity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_identity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Rotates itself to point into direction of target position. Operations take place in global space.
*/
func (o *Spatial) LookAt(target *Vector3, up *Vector3) {
	log.Println("Calling Spatial.LookAt()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(target)
	goArguments[1] = reflect.ValueOf(up)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "look_at", goArguments, "")

	log.Println("Got return value!")

}

/*
   Moves the node to specified position and then rotates itself to point into direction of target position. Operations take place in global space.
*/
func (o *Spatial) LookAtFromPosition(position *Vector3, target *Vector3, up *Vector3) {
	log.Println("Calling Spatial.LookAtFromPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(position)
	goArguments[1] = reflect.ValueOf(target)
	goArguments[2] = reflect.ValueOf(up)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "look_at_from_position", goArguments, "")

	log.Println("Got return value!")

}

/*
   Tranforms [Vector3] "global_point" from world space to this node's local space.
*/
func (o *Spatial) ToLocal(globalPoint *Vector3) *Vector3 {
	log.Println("Calling Spatial.ToLocal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(globalPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "to_local", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Tranforms [Vector3] "local_point" from this node's local space to world space.
*/
func (o *Spatial) ToGlobal(localPoint *Vector3) *Vector3 {
	log.Println("Calling Spatial.ToGlobal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(localPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "to_global", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   SpatialImplementer is an interface for Spatial objects.
*/
type SpatialImplementer interface {
	Class
}

/*

 */
type SpatialGizmo struct {
	Reference
}

func (o *SpatialGizmo) baseClass() string {
	return "SpatialGizmo"
}

/*
   SpatialGizmoImplementer is an interface for SpatialGizmo objects.
*/
type SpatialGizmoImplementer interface {
	Class
}

/*
   Skeleton provides a hierarchical interface for managing bones, including pose, rest and animation (see [Animation]). Skeleton will support rag doll dynamics in the future.
*/
type Skeleton struct {
	Spatial
}

func (o *Skeleton) baseClass() string {
	return "Skeleton"
}

/*
   Add a bone, with name "name". [method get_bone_count] will become the bone index.
*/
func (o *Skeleton) AddBone(name string) {
	log.Println("Calling Skeleton.AddBone()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_bone", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the bone index that matches "name" as its name.
*/
func (o *Skeleton) FindBone(name string) int64 {
	log.Println("Calling Skeleton.FindBone()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "find_bone", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the name of the bone at index "index"
*/
func (o *Skeleton) GetBoneName(boneIdx int64) string {
	log.Println("Calling Skeleton.GetBoneName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(boneIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bone_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the bone index which is the parent of the bone at "bone_idx". If -1, then bone has no parent. Note that the parent bone returned will always be less than "bone_idx".
*/
func (o *Skeleton) GetBoneParent(boneIdx int64) int64 {
	log.Println("Calling Skeleton.GetBoneParent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(boneIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bone_parent", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the bone index "parent_idx" as the parent of the bone at "bone_idx". If -1, then bone has no parent. Note: "parent_idx" must be less than "bone_idx".
*/
func (o *Skeleton) SetBoneParent(boneIdx int64, parentIdx int64) {
	log.Println("Calling Skeleton.SetBoneParent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(boneIdx)
	goArguments[1] = reflect.ValueOf(parentIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bone_parent", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the amount of bones in the skeleton.
*/
func (o *Skeleton) GetBoneCount() int64 {
	log.Println("Calling Skeleton.GetBoneCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bone_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Skeleton) UnparentBoneAndRest(boneIdx int64) {
	log.Println("Calling Skeleton.UnparentBoneAndRest()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(boneIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "unparent_bone_and_rest", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the rest transform for a bone "bone_idx".
*/
func (o *Skeleton) GetBoneRest(boneIdx int64) *Transform {
	log.Println("Calling Skeleton.GetBoneRest()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(boneIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bone_rest", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*
   Set the rest transform for bone "bone_idx"
*/
func (o *Skeleton) SetBoneRest(boneIdx int64, rest *Transform) {
	log.Println("Calling Skeleton.SetBoneRest()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(boneIdx)
	goArguments[1] = reflect.ValueOf(rest)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bone_rest", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Skeleton) SetBoneDisableRest(boneIdx int64, disable bool) {
	log.Println("Calling Skeleton.SetBoneDisableRest()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(boneIdx)
	goArguments[1] = reflect.ValueOf(disable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bone_disable_rest", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Skeleton) IsBoneRestDisabled(boneIdx int64) bool {
	log.Println("Calling Skeleton.IsBoneRestDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(boneIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_bone_rest_disabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Deprecated soon.
*/
func (o *Skeleton) BindChildNodeToBone(boneIdx int64, node *Object) {
	log.Println("Calling Skeleton.BindChildNodeToBone()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(boneIdx)
	goArguments[1] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "bind_child_node_to_bone", goArguments, "")

	log.Println("Got return value!")

}

/*
   Deprecated soon.
*/
func (o *Skeleton) UnbindChildNodeFromBone(boneIdx int64, node *Object) {
	log.Println("Calling Skeleton.UnbindChildNodeFromBone()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(boneIdx)
	goArguments[1] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "unbind_child_node_from_bone", goArguments, "")

	log.Println("Got return value!")

}

/*
   Deprecated soon.
*/
func (o *Skeleton) GetBoundChildNodesToBone(boneIdx int64) *Array {
	log.Println("Calling Skeleton.GetBoundChildNodesToBone()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(boneIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bound_child_nodes_to_bone", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Clear all the bones in this skeleton.
*/
func (o *Skeleton) ClearBones() {
	log.Println("Calling Skeleton.ClearBones()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_bones", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the pose transform for bone "bone_idx".
*/
func (o *Skeleton) GetBonePose(boneIdx int64) *Transform {
	log.Println("Calling Skeleton.GetBonePose()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(boneIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bone_pose", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*
   Return the pose transform for bone "bone_idx".
*/
func (o *Skeleton) SetBonePose(boneIdx int64, pose *Transform) {
	log.Println("Calling Skeleton.SetBonePose()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(boneIdx)
	goArguments[1] = reflect.ValueOf(pose)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bone_pose", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Skeleton) SetBoneGlobalPose(boneIdx int64, pose *Transform) {
	log.Println("Calling Skeleton.SetBoneGlobalPose()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(boneIdx)
	goArguments[1] = reflect.ValueOf(pose)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bone_global_pose", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Skeleton) GetBoneGlobalPose(boneIdx int64) *Transform {
	log.Println("Calling Skeleton.GetBoneGlobalPose()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(boneIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bone_global_pose", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*

 */
func (o *Skeleton) GetBoneCustomPose(boneIdx int64) *Transform {
	log.Println("Calling Skeleton.GetBoneCustomPose()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(boneIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bone_custom_pose", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*

 */
func (o *Skeleton) SetBoneCustomPose(boneIdx int64, customPose *Transform) {
	log.Println("Calling Skeleton.SetBoneCustomPose()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(boneIdx)
	goArguments[1] = reflect.ValueOf(customPose)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bone_custom_pose", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Skeleton) GetBoneTransform(boneIdx int64) *Transform {
	log.Println("Calling Skeleton.GetBoneTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(boneIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bone_transform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*
   SkeletonImplementer is an interface for Skeleton objects.
*/
type SkeletonImplementer interface {
	Class
}

/*
   An animation player is used for general purpose playback of [Animation] resources. It contains a dictionary of animations (referenced by name) and custom blend times between their transitions. Additionally, animations can be played and blended in different channels.
*/
type AnimationPlayer struct {
	Node
}

func (o *AnimationPlayer) baseClass() string {
	return "AnimationPlayer"
}

/*
   Undocumented
*/
func (o *AnimationPlayer) X_NodeRemoved(arg0 *Object) {
	log.Println("Calling AnimationPlayer.X_NodeRemoved()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_node_removed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *AnimationPlayer) X_AnimationChanged() {
	log.Println("Calling AnimationPlayer.X_AnimationChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_animation_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add an animation resource to the player, which will be later referenced by the "name" argument.
*/
func (o *AnimationPlayer) AddAnimation(name string, animation *Animation) int64 {
	log.Println("Calling AnimationPlayer.AddAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(animation)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "add_animation", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Remove an animation from the player (by supplying the same name used to add it).
*/
func (o *AnimationPlayer) RemoveAnimation(name string) {
	log.Println("Calling AnimationPlayer.RemoveAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_animation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Rename an existing animation.
*/
func (o *AnimationPlayer) RenameAnimation(name string, newname string) {
	log.Println("Calling AnimationPlayer.RenameAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(newname)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rename_animation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Request whether an [Animation] name exist within the player.
*/
func (o *AnimationPlayer) HasAnimation(name string) bool {
	log.Println("Calling AnimationPlayer.HasAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_animation", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Get an [Animation] resource by requesting a name.
*/
func (o *AnimationPlayer) GetAnimation(name string) *Animation {
	log.Println("Calling AnimationPlayer.GetAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_animation", goArguments, "*Animation")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Animation)

	return returnValue

}

/*
   Get the list of names of the animations stored in the player.
*/
func (o *AnimationPlayer) GetAnimationList() *PoolStringArray {
	log.Println("Calling AnimationPlayer.GetAnimationList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_animation_list", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Set the name of an animation that will be played after.
*/
func (o *AnimationPlayer) AnimationSetNext(animFrom string, animTo string) {
	log.Println("Calling AnimationPlayer.AnimationSetNext()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(animFrom)
	goArguments[1] = reflect.ValueOf(animTo)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "animation_set_next", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the name of the next animation in the queue.
*/
func (o *AnimationPlayer) AnimationGetNext(animFrom string) string {
	log.Println("Calling AnimationPlayer.AnimationGetNext()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(animFrom)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "animation_get_next", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Specify a blend time (in seconds) between two animations, referenced by their names.
*/
func (o *AnimationPlayer) SetBlendTime(animFrom string, animTo string, sec float64) {
	log.Println("Calling AnimationPlayer.SetBlendTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(animFrom)
	goArguments[1] = reflect.ValueOf(animTo)
	goArguments[2] = reflect.ValueOf(sec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_blend_time", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the blend time between two animations, referenced by their names.
*/
func (o *AnimationPlayer) GetBlendTime(animFrom string, animTo string) float64 {
	log.Println("Calling AnimationPlayer.GetBlendTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(animFrom)
	goArguments[1] = reflect.ValueOf(animTo)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_blend_time", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the default blend time between animations.
*/
func (o *AnimationPlayer) SetDefaultBlendTime(sec float64) {
	log.Println("Calling AnimationPlayer.SetDefaultBlendTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_default_blend_time", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the default blend time between animations.
*/
func (o *AnimationPlayer) GetDefaultBlendTime() float64 {
	log.Println("Calling AnimationPlayer.GetDefaultBlendTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_default_blend_time", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Play a given animation by the animation name. Custom speed and blend times can be set. If custom speed is negative (-1), 'from_end' being true can play the animation backwards.
*/
func (o *AnimationPlayer) Play(name string, customBlend float64, customSpeed float64, fromEnd bool) {
	log.Println("Calling AnimationPlayer.Play()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(customBlend)
	goArguments[2] = reflect.ValueOf(customSpeed)
	goArguments[3] = reflect.ValueOf(fromEnd)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "play", goArguments, "")

	log.Println("Got return value!")

}

/*
   Play a given animation by the animation name in reverse.
*/
func (o *AnimationPlayer) PlayBackwards(name string, customBlend float64) {
	log.Println("Calling AnimationPlayer.PlayBackwards()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(customBlend)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "play_backwards", goArguments, "")

	log.Println("Got return value!")

}

/*
   Stop the currently playing animation.
*/
func (o *AnimationPlayer) Stop(reset bool) {
	log.Println("Calling AnimationPlayer.Stop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(reset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "stop", goArguments, "")

	log.Println("Got return value!")

}

/*
   Stop playback of animations (deprecated).
*/
func (o *AnimationPlayer) StopAll() {
	log.Println("Calling AnimationPlayer.StopAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "stop_all", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether an animation is playing.
*/
func (o *AnimationPlayer) IsPlaying() bool {
	log.Println("Calling AnimationPlayer.IsPlaying()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_playing", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the current animation (even if no playback occurs). Using set_current_animation() and set_active() are similar to calling play().
*/
func (o *AnimationPlayer) SetCurrentAnimation(anim string) {
	log.Println("Calling AnimationPlayer.SetCurrentAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anim)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_current_animation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the name of the animation being played.
*/
func (o *AnimationPlayer) GetCurrentAnimation() string {
	log.Println("Calling AnimationPlayer.GetCurrentAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_animation", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Queue an animation for playback once the current one is done.
*/
func (o *AnimationPlayer) Queue(name string) {
	log.Println("Calling AnimationPlayer.Queue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "queue", goArguments, "")

	log.Println("Got return value!")

}

/*
   If animations are queued to play, clear them.
*/
func (o *AnimationPlayer) ClearQueue() {
	log.Println("Calling AnimationPlayer.ClearQueue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_queue", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the player as active (playing). If false, it will do nothing.
*/
func (o *AnimationPlayer) SetActive(active bool) {
	log.Println("Calling AnimationPlayer.SetActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(active)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_active", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if the player is active.
*/
func (o *AnimationPlayer) IsActive() bool {
	log.Println("Calling AnimationPlayer.IsActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_active", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set a speed scaling ratio in a given animation channel (or channel 0 if none is provided). Default ratio is [i]1[/i] (no scaling).
*/
func (o *AnimationPlayer) SetSpeedScale(speed float64) {
	log.Println("Calling AnimationPlayer.SetSpeedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(speed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_speed_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the speed scaling ratio in a given animation channel (or channel 0 if none is provided). Default ratio is [i]1[/i] (no scaling).
*/
func (o *AnimationPlayer) GetSpeedScale() float64 {
	log.Println("Calling AnimationPlayer.GetSpeedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_speed_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the name of the animation that will be automatically played when the scene is loaded.
*/
func (o *AnimationPlayer) SetAutoplay(name string) {
	log.Println("Calling AnimationPlayer.SetAutoplay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_autoplay", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the name of the animation that will be automatically played when the scene is loaded.
*/
func (o *AnimationPlayer) GetAutoplay() string {
	log.Println("Calling AnimationPlayer.GetAutoplay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_autoplay", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   AnimationPlayer resolves animation track paths from this node (which is relative to itself), by default root is "..", but it can be changed.
*/
func (o *AnimationPlayer) SetRoot(path *NodePath) {
	log.Println("Calling AnimationPlayer.SetRoot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_root", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return path to root node (see [method set_root]).
*/
func (o *AnimationPlayer) GetRoot() *NodePath {
	log.Println("Calling AnimationPlayer.GetRoot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_root", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*
   Seek the animation to a given position in time (in seconds). If 'update' is true, the animation will be updated too, otherwise it will be updated at process time.
*/
func (o *AnimationPlayer) Seek(seconds float64, update bool) {
	log.Println("Calling AnimationPlayer.Seek()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(seconds)
	goArguments[1] = reflect.ValueOf(update)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "seek", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the playback position (in seconds) in an animation channel (or channel 0 if none is provided).
*/
func (o *AnimationPlayer) GetPosition() float64 {
	log.Println("Calling AnimationPlayer.GetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_position", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Find an animation name by resource.
*/
func (o *AnimationPlayer) FindAnimation(animation *Animation) string {
	log.Println("Calling AnimationPlayer.FindAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(animation)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "find_animation", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   The animation player creates caches for faster access to the nodes it will animate. However, if a specific node is removed, it may not notice it, so clear_caches will force the player to search for the nodes again.
*/
func (o *AnimationPlayer) ClearCaches() {
	log.Println("Calling AnimationPlayer.ClearCaches()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_caches", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the mode in which the animation player processes. By default, it processes on idle time (framerate dependent), but using fixed time works well for animating static collision bodies in 2D and 3D. See enum ANIMATION_PROCESS_*.
*/
func (o *AnimationPlayer) SetAnimationProcessMode(mode int64) {
	log.Println("Calling AnimationPlayer.SetAnimationProcessMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_animation_process_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the mode in which the animation player processes. See [method set_animation_process_mode].
*/
func (o *AnimationPlayer) GetAnimationProcessMode() int64 {
	log.Println("Calling AnimationPlayer.GetAnimationProcessMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_animation_process_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the position (in seconds) of the currently being played animation.
*/
func (o *AnimationPlayer) GetCurrentAnimationPosition() float64 {
	log.Println("Calling AnimationPlayer.GetCurrentAnimationPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_animation_position", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Get the length (in seconds) of the currently being played animation.
*/
func (o *AnimationPlayer) GetCurrentAnimationLength() float64 {
	log.Println("Calling AnimationPlayer.GetCurrentAnimationLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_animation_length", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Used to skip ahead or skip back in an animation. Delta is the time in seconds to skip.
*/
func (o *AnimationPlayer) Advance(delta float64) {
	log.Println("Calling AnimationPlayer.Advance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(delta)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "advance", goArguments, "")

	log.Println("Got return value!")

}

/*
   AnimationPlayerImplementer is an interface for AnimationPlayer objects.
*/
type AnimationPlayerImplementer interface {
	Class
}

/*
   Node useful for animations with unknown start and end points, procedural animations, making one node follow another, and other simple behavior. Because it is easy to get it wrong, here is a quick usage example: [codeblock] var tween = get_node("Tween") tween.interpolate_property(get_node("Node2D_to_move"), "transform/origin", Vector2(0,0), Vector2(100,100), 1, Tween.TRANS_LINEAR, Tween.EASE_IN_OUT) tween.start() [/codeblock] Some of the methods of this class require a property name. You can get the property name by hovering over the property in the inspector of the editor. Many of the methods accept [code]trans_type[/code] and [code]ease_type[/code]. The first accepts an TRANS_* constant, and refers to the way the timing of the animation is handled (you might want to see [code]http://easings.net/[/code] for some examples). The second accepts an EASE_* constant, and controls the where [code]trans_type[/code] is applied to the interpolation (in the beginning, the end, or both). If you don't know which transision and easing to pick, you can try different TRANS_* constants with EASE_IN_OUT, and use the one that looks best.
*/
type Tween struct {
	Node
}

func (o *Tween) baseClass() string {
	return "Tween"
}

/*
   Returns true if any tweens are currently running, and false otherwise. Note that this method doesn't consider tweens that have ended.
*/
func (o *Tween) IsActive() bool {
	log.Println("Calling Tween.IsActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_active", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Activate/deactivate the tween. You can use this for pausing animations, though [method stop_all] and [method resume_all] might be more fit for this.
*/
func (o *Tween) SetActive(active bool) {
	log.Println("Calling Tween.SetActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(active)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_active", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns true if repeat has been set from editor GUI or [method set_repeat].
*/
func (o *Tween) IsRepeat() bool {
	log.Println("Calling Tween.IsRepeat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_repeat", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Make the tween repeat after all tweens have finished.
*/
func (o *Tween) SetRepeat(repeat bool) {
	log.Println("Calling Tween.SetRepeat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(repeat)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_repeat", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the speed multiplier of the tween. Set it to 1 for normal speed, 2 for two times nromal speed, and 0.5 for half of the normal speed. Setting it to 0 would pause the animation, but you might consider using [method set_active] or [method stop_all] and [method resume_all] for this.
*/
func (o *Tween) SetSpeedScale(speed float64) {
	log.Println("Calling Tween.SetSpeedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(speed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_speed_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the speed that has been set from editor GUI or [method set_repeat].
*/
func (o *Tween) GetSpeedScale() float64 {
	log.Println("Calling Tween.GetSpeedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_speed_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set whether the Tween uses [code]_process[/code] or [code]_fixed_process[/code] (accepts TWEEN_PROCESS_IDLE and TWEEN_PROCESS_FIXED constants, respectively).
*/
func (o *Tween) SetTweenProcessMode(mode int64) {
	log.Println("Calling Tween.SetTweenProcessMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tween_process_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the process mode that has been set from editor GUI or [method set_tween_process_mode]
*/
func (o *Tween) GetTweenProcessMode() int64 {
	log.Println("Calling Tween.GetTweenProcessMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tween_process_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Start the tween node. You can define tweens both before and after this.
*/
func (o *Tween) Start() bool {
	log.Println("Calling Tween.Start()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "start", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Resets a tween to the initial value (the one given, not the one before the tween), given its object and property/method pair. Passing empty String as key will reset all tweens for given object.
*/
func (o *Tween) Reset(object *Object, key string) bool {
	log.Println("Calling Tween.Reset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(key)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "reset", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Resets all tweens to their initial values (the ones given, not those before the tween).
*/
func (o *Tween) ResetAll() bool {
	log.Println("Calling Tween.ResetAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "reset_all", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Stop animating a tween, given its object and property/method pair. Passing empty String as key will stop all tweens for given object.
*/
func (o *Tween) Stop(object *Object, key string) bool {
	log.Println("Calling Tween.Stop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(key)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "stop", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Stop animating all tweens.
*/
func (o *Tween) StopAll() bool {
	log.Println("Calling Tween.StopAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "stop_all", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Continue animating a stopped tween, given its object and property/method pair. Passing empty String as key will resume all tweens for given object.
*/
func (o *Tween) Resume(object *Object, key string) bool {
	log.Println("Calling Tween.Resume()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(key)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "resume", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Continue animating all stopped tweens.
*/
func (o *Tween) ResumeAll() bool {
	log.Println("Calling Tween.ResumeAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "resume_all", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Stop animating and completely remove a tween, given its object and property/method pair. Passing empty String as key will remove all tweens for given object.
*/
func (o *Tween) Remove(object *Object, key string) bool {
	log.Println("Calling Tween.Remove()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(key)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "remove", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *Tween) X_Remove(object *Object, key string, firstOnly bool) {
	log.Println("Calling Tween.X_Remove()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(key)
	goArguments[2] = reflect.ValueOf(firstOnly)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_remove", goArguments, "")

	log.Println("Got return value!")

}

/*
   Stop animating and completely remove all tweens.
*/
func (o *Tween) RemoveAll() bool {
	log.Println("Calling Tween.RemoveAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "remove_all", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Seek the animation to the given [code]time[/code] in seconds.
*/
func (o *Tween) Seek(time float64) bool {
	log.Println("Calling Tween.Seek()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(time)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "seek", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns the current time of the tween.
*/
func (o *Tween) Tell() float64 {
	log.Println("Calling Tween.Tell()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tell", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns the time needed for all tweens to end in seconds, measured from the start. Thus, if you have two tweens, one ending 10 seconds after the start and the other - 20 seconds, it would return 20 seconds, as by that time all tweens would have finished.
*/
func (o *Tween) GetRuntime() float64 {
	log.Println("Calling Tween.GetRuntime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_runtime", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Animate [code]property[/code] of [code]object[/code] from [code]initial_val[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) InterpolateProperty(object *Object, property string, initialVal *Variant, finalVal *Variant, duration float64, transType int64, easeType int64, delay float64) bool {
	log.Println("Calling Tween.InterpolateProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 8, 8)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(property)
	goArguments[2] = reflect.ValueOf(initialVal)
	goArguments[3] = reflect.ValueOf(finalVal)
	goArguments[4] = reflect.ValueOf(duration)
	goArguments[5] = reflect.ValueOf(transType)
	goArguments[6] = reflect.ValueOf(easeType)
	goArguments[7] = reflect.ValueOf(delay)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "interpolate_property", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Animate [code]method[/code] of [code]object[/code] from [code]initial_val[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. Methods are animated by calling them with consecuitive values. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) InterpolateMethod(object *Object, method string, initialVal *Variant, finalVal *Variant, duration float64, transType int64, easeType int64, delay float64) bool {
	log.Println("Calling Tween.InterpolateMethod()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 8, 8)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(method)
	goArguments[2] = reflect.ValueOf(initialVal)
	goArguments[3] = reflect.ValueOf(finalVal)
	goArguments[4] = reflect.ValueOf(duration)
	goArguments[5] = reflect.ValueOf(transType)
	goArguments[6] = reflect.ValueOf(easeType)
	goArguments[7] = reflect.ValueOf(delay)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "interpolate_method", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Call [code]callback[/code] of [code]object[/code] after [code]duration[/code]. [code]arg1[/code]-[code]arg5[/code] are arguments to be passed to the callback.
*/
func (o *Tween) InterpolateCallback(object *Object, duration float64, callback string, arg1 *Variant, arg2 *Variant, arg3 *Variant, arg4 *Variant, arg5 *Variant) bool {
	log.Println("Calling Tween.InterpolateCallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 8, 8)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(duration)
	goArguments[2] = reflect.ValueOf(callback)
	goArguments[3] = reflect.ValueOf(arg1)
	goArguments[4] = reflect.ValueOf(arg2)
	goArguments[5] = reflect.ValueOf(arg3)
	goArguments[6] = reflect.ValueOf(arg4)
	goArguments[7] = reflect.ValueOf(arg5)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "interpolate_callback", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Call [code]callback[/code] of [code]object[/code] after [code]duration[/code] on the main thread (similar to [methog Object.call_deferred). [code]arg1[/code]-[code]arg5[/code] are arguments to be passed to the callback.
*/
func (o *Tween) InterpolateDeferredCallback(object *Object, duration float64, callback string, arg1 *Variant, arg2 *Variant, arg3 *Variant, arg4 *Variant, arg5 *Variant) bool {
	log.Println("Calling Tween.InterpolateDeferredCallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 8, 8)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(duration)
	goArguments[2] = reflect.ValueOf(callback)
	goArguments[3] = reflect.ValueOf(arg1)
	goArguments[4] = reflect.ValueOf(arg2)
	goArguments[5] = reflect.ValueOf(arg3)
	goArguments[6] = reflect.ValueOf(arg4)
	goArguments[7] = reflect.ValueOf(arg5)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "interpolate_deferred_callback", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Follow [code]property[/code] of [code]object[/code] and apply it on [code]target_property[/code] of [code]target[/code], beginning from [code]initial_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. Note that [code]target:target_property[/code] would equal [code]object:property[/code] at the end of the tween. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) FollowProperty(object *Object, property string, initialVal *Variant, target *Object, targetProperty string, duration float64, transType int64, easeType int64, delay float64) bool {
	log.Println("Calling Tween.FollowProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 9, 9)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(property)
	goArguments[2] = reflect.ValueOf(initialVal)
	goArguments[3] = reflect.ValueOf(target)
	goArguments[4] = reflect.ValueOf(targetProperty)
	goArguments[5] = reflect.ValueOf(duration)
	goArguments[6] = reflect.ValueOf(transType)
	goArguments[7] = reflect.ValueOf(easeType)
	goArguments[8] = reflect.ValueOf(delay)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "follow_property", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Follow [code]method[/code] of [code]object[/code] and apply the returned value on [code]target_method[/code] of [code]target[/code], beginning from [code]initial_val[/code] for [code]duration[/code] seconds, [code]delay[/code] later. Methods are animated by calling them with consequitive values. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) FollowMethod(object *Object, method string, initialVal *Variant, target *Object, targetMethod string, duration float64, transType int64, easeType int64, delay float64) bool {
	log.Println("Calling Tween.FollowMethod()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 9, 9)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(method)
	goArguments[2] = reflect.ValueOf(initialVal)
	goArguments[3] = reflect.ValueOf(target)
	goArguments[4] = reflect.ValueOf(targetMethod)
	goArguments[5] = reflect.ValueOf(duration)
	goArguments[6] = reflect.ValueOf(transType)
	goArguments[7] = reflect.ValueOf(easeType)
	goArguments[8] = reflect.ValueOf(delay)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "follow_method", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Animate [code]property[/code] of [code]object[/code] from the current value of the [code]initial_val[/code] property of [code]initial[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) TargetingProperty(object *Object, property string, initial *Object, initialVal string, finalVal *Variant, duration float64, transType int64, easeType int64, delay float64) bool {
	log.Println("Calling Tween.TargetingProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 9, 9)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(property)
	goArguments[2] = reflect.ValueOf(initial)
	goArguments[3] = reflect.ValueOf(initialVal)
	goArguments[4] = reflect.ValueOf(finalVal)
	goArguments[5] = reflect.ValueOf(duration)
	goArguments[6] = reflect.ValueOf(transType)
	goArguments[7] = reflect.ValueOf(easeType)
	goArguments[8] = reflect.ValueOf(delay)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "targeting_property", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Animate [code]method[/code] of [code]object[/code] from the value returned by [code]initial.initial_method[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. Methods are animated by calling them with consecuitive values. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) TargetingMethod(object *Object, method string, initial *Object, initialMethod string, finalVal *Variant, duration float64, transType int64, easeType int64, delay float64) bool {
	log.Println("Calling Tween.TargetingMethod()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 9, 9)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(method)
	goArguments[2] = reflect.ValueOf(initial)
	goArguments[3] = reflect.ValueOf(initialMethod)
	goArguments[4] = reflect.ValueOf(finalVal)
	goArguments[5] = reflect.ValueOf(duration)
	goArguments[6] = reflect.ValueOf(transType)
	goArguments[7] = reflect.ValueOf(easeType)
	goArguments[8] = reflect.ValueOf(delay)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "targeting_method", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   TweenImplementer is an interface for Tween objects.
*/
type TweenImplementer interface {
	Class
}

/*
   This node must be the child of a [Skeleton] node. You can then select a bone for this node to attach to. The BoneAttachment node will copy the transform of the selected bone.
*/
type BoneAttachment struct {
	Spatial
}

func (o *BoneAttachment) baseClass() string {
	return "BoneAttachment"
}

/*
   Changes the name of the bone node
*/
func (o *BoneAttachment) SetBoneName(boneName string) {
	log.Println("Calling BoneAttachment.SetBoneName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(boneName)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bone_name", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the name of the bone node attached to.
*/
func (o *BoneAttachment) GetBoneName() string {
	log.Println("Calling BoneAttachment.GetBoneName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bone_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   BoneAttachmentImplementer is an interface for BoneAttachment objects.
*/
type BoneAttachmentImplementer interface {
	Class
}

/*

 */
type VisualInstance struct {
	Spatial
}

func (o *VisualInstance) baseClass() string {
	return "VisualInstance"
}

/*
   Undocumented
*/
func (o *VisualInstance) X_GetVisualInstanceRid() *RID {
	log.Println("Calling VisualInstance.X_GetVisualInstanceRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_visual_instance_rid", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *VisualInstance) SetBase(base *RID) {
	log.Println("Calling VisualInstance.SetBase()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(base)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualInstance) SetLayerMask(mask int64) {
	log.Println("Calling VisualInstance.SetLayerMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_layer_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualInstance) GetLayerMask() int64 {
	log.Println("Calling VisualInstance.GetLayerMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_layer_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualInstance) GetTransformedAabb() *Rect3 {
	log.Println("Calling VisualInstance.GetTransformedAabb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_transformed_aabb", goArguments, "*Rect3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect3)

	return returnValue

}

/*

 */
func (o *VisualInstance) GetAabb() *Rect3 {
	log.Println("Calling VisualInstance.GetAabb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_aabb", goArguments, "*Rect3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect3)

	return returnValue

}

/*
   VisualInstanceImplementer is an interface for VisualInstance objects.
*/
type VisualInstanceImplementer interface {
	Class
}

/*
   Camera is a special node that displays what is visible from its current location. Cameras register themselves in the nearest [Viewport] node (when ascending the tree). Only one camera can be active per viewport. If no viewport is available ascending the tree, the Camera will register in the global viewport. In other words, a Camera just provides [i]3D[/i] display capabilities to a [Viewport], and, without one, a scene registered in that [Viewport] (or higher viewports) can't be displayed.
*/
type Camera struct {
	Spatial
}

func (o *Camera) baseClass() string {
	return "Camera"
}

/*
   Return a normal vector in worldspace, that is the result of projecting a point on the [Viewport] rectangle by the camera projection. This is useful for casting rays in the form of (origin,normal) for object intersection or picking.
*/
func (o *Camera) ProjectRayNormal(screenPoint *Vector2) *Vector3 {
	log.Println("Calling Camera.ProjectRayNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(screenPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "project_ray_normal", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *Camera) ProjectLocalRayNormal(screenPoint *Vector2) *Vector3 {
	log.Println("Calling Camera.ProjectLocalRayNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(screenPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "project_local_ray_normal", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Return a 3D position in worldspace, that is the result of projecting a point on the [Viewport] rectangle by the camera projection. This is useful for casting rays in the form of (origin,normal) for object intersection or picking.
*/
func (o *Camera) ProjectRayOrigin(screenPoint *Vector2) *Vector3 {
	log.Println("Calling Camera.ProjectRayOrigin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(screenPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "project_ray_origin", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Return how a 3D point in worldspace maps to a 2D coordinate in the [Viewport] rectangle.
*/
func (o *Camera) UnprojectPosition(worldPoint *Vector3) *Vector2 {
	log.Println("Calling Camera.UnprojectPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(worldPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "unproject_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Camera) IsPositionBehind(worldPoint *Vector3) bool {
	log.Println("Calling Camera.IsPositionBehind()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(worldPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_position_behind", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Camera) ProjectPosition(screenPoint *Vector2) *Vector3 {
	log.Println("Calling Camera.ProjectPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(screenPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "project_position", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Set the camera projection to perspective mode, by specifying a [i]FOV[/i] Y angle in degrees (FOV means Field of View), and the [i]near[/i] and [i]far[/i] clip planes in worldspace units.
*/
func (o *Camera) SetPerspective(fov float64, zNear float64, zFar float64) {
	log.Println("Calling Camera.SetPerspective()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(fov)
	goArguments[1] = reflect.ValueOf(zNear)
	goArguments[2] = reflect.ValueOf(zFar)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_perspective", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the camera projection to orthogonal mode, by specifying a width and the [i]near[/i] and [i]far[/i] clip planes in worldspace units. (As a hint, 2D games often use this projection, with values specified in pixels)
*/
func (o *Camera) SetOrthogonal(size float64, zNear float64, zFar float64) {
	log.Println("Calling Camera.SetOrthogonal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(size)
	goArguments[1] = reflect.ValueOf(zNear)
	goArguments[2] = reflect.ValueOf(zFar)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_orthogonal", goArguments, "")

	log.Println("Got return value!")

}

/*
   Make this camera the current Camera for the [Viewport] (see class description). If the Camera Node is outside the scene tree, it will attempt to become current once it's added.
*/
func (o *Camera) MakeCurrent() {
	log.Println("Calling Camera.MakeCurrent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "make_current", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera) ClearCurrent() {
	log.Println("Calling Camera.ClearCurrent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_current", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether the Camera is the current one in the [Viewport], or plans to become current (if outside the scene tree).
*/
func (o *Camera) IsCurrent() bool {
	log.Println("Calling Camera.IsCurrent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_current", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Get the camera transform. Subclassed cameras (such as CharacterCamera) may provide different transforms than the [Node] transform.
*/
func (o *Camera) GetCameraTransform() *Transform {
	log.Println("Calling Camera.GetCameraTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_camera_transform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*

 */
func (o *Camera) GetFov() float64 {
	log.Println("Calling Camera.GetFov()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fov", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Camera) GetSize() float64 {
	log.Println("Calling Camera.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Camera) GetZfar() float64 {
	log.Println("Calling Camera.GetZfar()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_zfar", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Camera) GetZnear() float64 {
	log.Println("Calling Camera.GetZnear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_znear", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Camera) GetProjection() int64 {
	log.Println("Calling Camera.GetProjection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_projection", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Camera) SetHOffset(ofs float64) {
	log.Println("Calling Camera.SetHOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ofs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_h_offset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera) GetHOffset() float64 {
	log.Println("Calling Camera.GetHOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_h_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Camera) SetVOffset(ofs float64) {
	log.Println("Calling Camera.SetVOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ofs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_v_offset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera) GetVOffset() float64 {
	log.Println("Calling Camera.GetVOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_v_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Camera) SetCullMask(mask int64) {
	log.Println("Calling Camera.SetCullMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cull_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera) GetCullMask() int64 {
	log.Println("Calling Camera.GetCullMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cull_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Camera) SetEnvironment(env *Environment) {
	log.Println("Calling Camera.SetEnvironment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(env)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_environment", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera) GetEnvironment() *Environment {
	log.Println("Calling Camera.GetEnvironment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_environment", goArguments, "*Environment")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Environment)

	return returnValue

}

/*

 */
func (o *Camera) SetKeepAspectMode(mode int64) {
	log.Println("Calling Camera.SetKeepAspectMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_keep_aspect_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera) GetKeepAspectMode() int64 {
	log.Println("Calling Camera.GetKeepAspectMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_keep_aspect_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Camera) SetDopplerTracking(mode int64) {
	log.Println("Calling Camera.SetDopplerTracking()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_doppler_tracking", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera) GetDopplerTracking() int64 {
	log.Println("Calling Camera.GetDopplerTracking()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_doppler_tracking", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   CameraImplementer is an interface for Camera objects.
*/
type CameraImplementer interface {
	Class
}

/*

 */
type Listener struct {
	Spatial
}

func (o *Listener) baseClass() string {
	return "Listener"
}

/*

 */
func (o *Listener) MakeCurrent() {
	log.Println("Calling Listener.MakeCurrent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "make_current", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Listener) ClearCurrent() {
	log.Println("Calling Listener.ClearCurrent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_current", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Listener) IsCurrent() bool {
	log.Println("Calling Listener.IsCurrent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_current", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Listener) GetListenerTransform() *Transform {
	log.Println("Calling Listener.GetListenerTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_listener_transform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*
   ListenerImplementer is an interface for Listener objects.
*/
type ListenerImplementer interface {
	Class
}

/*
   This is a helper spatial node for our camera, note that if stereoscopic rendering is applicable (VR-HMD) most of the camera properties are ignored as the HMD information overrides them. The only properties that can be trusted are the near and far planes. The position and orientation of this node is automatically updated by the ARVR Server to represent the location of the HMD if such tracking is available and can thus be used by game logic. Note that in contrast to the ARVR Controller the render thread has access to the most up to date tracking data of the HMD and the location of the ARVRCamera can lag a few milliseconds behind what is used for rendering as a result.
*/
type ARVRCamera struct {
	Camera
}

func (o *ARVRCamera) baseClass() string {
	return "ARVRCamera"
}

/*
   ARVRCameraImplementer is an interface for ARVRCamera objects.
*/
type ARVRCameraImplementer interface {
	Class
}

/*
   This is a helper spatial node that is linked to the tracking of controllers. It also offers several handy pass throughs to the state of buttons and such on the controllers. Controllers are linked by their id. You can create controller nodes before the controllers are available. Say your game always uses two controllers (one for each hand) you can predefine the controllers with id 1 and 2 and they will become active as soon as the controllers are identified. If you expect additional controllers to be used you should react to the signals and add ARVRController nodes to your scene. The position of the controller node is automatically updated by the ARVR Server. This makes this node ideal to add child nodes to visualise the controller.
*/
type ARVRController struct {
	Spatial
}

func (o *ARVRController) baseClass() string {
	return "ARVRController"
}

/*
   Changes the id that identifies the controller bound to this node. The first controller that the ARVR Server detects will have id 1, the second id 2, the third id 3, etc. When a controller is turned off that slot is freed ensuring that controllers will keep the same id while it is turned on even when controllers with lower ids are turned off.
*/
func (o *ARVRController) SetControllerId(controllerId int64) {
	log.Println("Calling ARVRController.SetControllerId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(controllerId)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_controller_id", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the controller id currently assigned to this node.
*/
func (o *ARVRController) GetControllerId() int64 {
	log.Println("Calling ARVRController.GetControllerId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_controller_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   If active, returns the name of the associated controller if provided by the AR/VR SDK used.
*/
func (o *ARVRController) GetControllerName() string {
	log.Println("Calling ARVRController.GetControllerName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_controller_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Returns the ID of the joystick object bound to this. Every controller tracked by the ARVR Server that has buttons and axis will also be registered as a joystick within Godot. This means that all the normal joystick tracking and input mapping will work for buttons and axis found on the AR/VR controllers. This ID is purely offered as information so you can link up the controller with its joystick entry.
*/
func (o *ARVRController) GetJoystickId() int64 {
	log.Println("Calling ARVRController.GetJoystickId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_joystick_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Is the given button currently pressed?
*/
func (o *ARVRController) IsButtonPressed(button int64) int64 {
	log.Println("Calling ARVRController.IsButtonPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(button)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_button_pressed", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the value of the given axis for things like triggers, touchpads, etc. that are embedded into the controller.
*/
func (o *ARVRController) GetJoystickAxis(axis int64) float64 {
	log.Println("Calling ARVRController.GetJoystickAxis()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(axis)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_joystick_axis", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns true if the controller bound to this node is currently active and being tracked.
*/
func (o *ARVRController) GetIsActive() bool {
	log.Println("Calling ARVRController.GetIsActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_is_active", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *ARVRController) GetHand() int64 {
	log.Println("Calling ARVRController.GetHand()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_hand", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   ARVRControllerImplementer is an interface for ARVRController objects.
*/
type ARVRControllerImplementer interface {
	Class
}

/*
   The ARVR Anchor point is a spatial node that maps a real world location identified by the AR platform to a position within the game world. For example, as long as plane detection in ARKit is on, ARKit will identify and update the position of planes (tables, floors, etc) and create anchors for them. This node is mapped to one of the anchors through its unique id. When you receive a signal that a new anchor is available you should add this node to your scene for that anchor. You can predefine nodes and set the id and the nodes will simply remain on 0,0,0 until a plane is recognised. Keep in mind that as long as plane detection is enable the size, placing and orientation of an anchor will be updates as the detection logic learns more about the real world out there especially if only part of the surface is in view.
*/
type ARVRAnchor struct {
	Spatial
}

func (o *ARVRAnchor) baseClass() string {
	return "ARVRAnchor"
}

/*
   Binds this anchor node to an anchor with this id. You can set this before the anchor itself exists. The first anchor that is identified gets id 1, the second id 2, etc. When anchors get removed that slot remains free and can be assigned to the next anchor that is identified. The most common situation where anchors 'disappear' is when the AR server identifies that two anchors represent different parts of the same plane and merge them.
*/
func (o *ARVRAnchor) SetAnchorId(anchorId int64) {
	log.Println("Calling ARVRAnchor.SetAnchorId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anchorId)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_anchor_id", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the anchor id for this anchor.
*/
func (o *ARVRAnchor) GetAnchorId() int64 {
	log.Println("Calling ARVRAnchor.GetAnchorId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_anchor_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the name given to this anchor.
*/
func (o *ARVRAnchor) GetAnchorName() string {
	log.Println("Calling ARVRAnchor.GetAnchorName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_anchor_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Returns true if the anchor is being tracked and false if no anchor with this id is currently known.
*/
func (o *ARVRAnchor) GetIsActive() bool {
	log.Println("Calling ARVRAnchor.GetIsActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_is_active", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns the estimated size of the plane that was detected. Say when the anchor relates to a table in the real world, this is the estimated size of the surface of that table.
*/
func (o *ARVRAnchor) GetSize() *Vector3 {
	log.Println("Calling ARVRAnchor.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   ARVRAnchorImplementer is an interface for ARVRAnchor objects.
*/
type ARVRAnchorImplementer interface {
	Class
}

/*
   This is a special node within the AR/VR system that maps the physical location of the center of our tracking space to the virtual location within our game world. There should be only one of these nodes in your scene and you must have one. All the ARVRCamera, ARVRController and ARVRAnchor nodes should be direct children of this node for spatial tracking to work correctly. It is the position of this node that you update when you're character needs to move through your game world while we're not moving in the real world. Movement in the real world is always in relation to this origin point. So say that your character is driving a car, the ARVROrigin node should be a child node of this car. If you implement a teleport system to move your character, you change the position of this node. Etc.
*/
type ARVROrigin struct {
	Spatial
}

func (o *ARVROrigin) baseClass() string {
	return "ARVROrigin"
}

/*
   Changes the world scaling factor. Most AR/VR platforms will assume a unit size of 1 unit in your game world = 1 meter in the real world. This scale allows you to adjust this to the unit system you use in your game. Note that this method is a passthrough to the ARVRServer itself.
*/
func (o *ARVROrigin) SetWorldScale(worldScale float64) {
	log.Println("Calling ARVROrigin.SetWorldScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(worldScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_world_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the world scale applied to our positioning.
*/
func (o *ARVROrigin) GetWorldScale() float64 {
	log.Println("Calling ARVROrigin.GetWorldScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_world_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   ARVROriginImplementer is an interface for ARVROrigin objects.
*/
type ARVROriginImplementer interface {
	Class
}

/*

 */
type InterpolatedCamera struct {
	Camera
}

func (o *InterpolatedCamera) baseClass() string {
	return "InterpolatedCamera"
}

/*

 */
func (o *InterpolatedCamera) SetTargetPath(targetPath *NodePath) {
	log.Println("Calling InterpolatedCamera.SetTargetPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(targetPath)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_target_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InterpolatedCamera) GetTargetPath() *NodePath {
	log.Println("Calling InterpolatedCamera.GetTargetPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_target_path", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *InterpolatedCamera) SetTarget(target *Object) {
	log.Println("Calling InterpolatedCamera.SetTarget()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(target)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_target", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InterpolatedCamera) SetSpeed(speed float64) {
	log.Println("Calling InterpolatedCamera.SetSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(speed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_speed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InterpolatedCamera) GetSpeed() float64 {
	log.Println("Calling InterpolatedCamera.GetSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_speed", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *InterpolatedCamera) SetInterpolationEnabled(targetPath bool) {
	log.Println("Calling InterpolatedCamera.SetInterpolationEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(targetPath)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_interpolation_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InterpolatedCamera) IsInterpolationEnabled() bool {
	log.Println("Calling InterpolatedCamera.IsInterpolationEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_interpolation_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   InterpolatedCameraImplementer is an interface for InterpolatedCamera objects.
*/
type InterpolatedCameraImplementer interface {
	Class
}

/*
   Base node for geometry based visual instances. Shares some common functionality like visibility and custom materials.
*/
type GeometryInstance struct {
	VisualInstance
}

func (o *GeometryInstance) baseClass() string {
	return "GeometryInstance"
}

/*
   Set the material override for the whole geometry.
*/
func (o *GeometryInstance) SetMaterialOverride(material *Material) {
	log.Println("Calling GeometryInstance.SetMaterialOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(material)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_material_override", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the material override for the whole geometry.
*/
func (o *GeometryInstance) GetMaterialOverride() *Material {
	log.Println("Calling GeometryInstance.GetMaterialOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_material_override", goArguments, "*Material")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Material)

	return returnValue

}

/*

 */
func (o *GeometryInstance) SetFlag(flag int64, value bool) {
	log.Println("Calling GeometryInstance.SetFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(flag)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flag", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GeometryInstance) GetFlag(flag int64) bool {
	log.Println("Calling GeometryInstance.GetFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flag)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_flag", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *GeometryInstance) SetCastShadowsSetting(shadowCastingSetting int64) {
	log.Println("Calling GeometryInstance.SetCastShadowsSetting()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shadowCastingSetting)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cast_shadows_setting", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GeometryInstance) GetCastShadowsSetting() int64 {
	log.Println("Calling GeometryInstance.GetCastShadowsSetting()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cast_shadows_setting", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *GeometryInstance) SetLodMaxHysteresis(mode float64) {
	log.Println("Calling GeometryInstance.SetLodMaxHysteresis()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_lod_max_hysteresis", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GeometryInstance) GetLodMaxHysteresis() float64 {
	log.Println("Calling GeometryInstance.GetLodMaxHysteresis()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_lod_max_hysteresis", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *GeometryInstance) SetLodMaxDistance(mode float64) {
	log.Println("Calling GeometryInstance.SetLodMaxDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_lod_max_distance", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GeometryInstance) GetLodMaxDistance() float64 {
	log.Println("Calling GeometryInstance.GetLodMaxDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_lod_max_distance", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *GeometryInstance) SetLodMinHysteresis(mode float64) {
	log.Println("Calling GeometryInstance.SetLodMinHysteresis()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_lod_min_hysteresis", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GeometryInstance) GetLodMinHysteresis() float64 {
	log.Println("Calling GeometryInstance.GetLodMinHysteresis()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_lod_min_hysteresis", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *GeometryInstance) SetLodMinDistance(mode float64) {
	log.Println("Calling GeometryInstance.SetLodMinDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_lod_min_distance", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GeometryInstance) GetLodMinDistance() float64 {
	log.Println("Calling GeometryInstance.GetLodMinDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_lod_min_distance", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *GeometryInstance) SetExtraCullMargin(margin float64) {
	log.Println("Calling GeometryInstance.SetExtraCullMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_extra_cull_margin", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GeometryInstance) GetExtraCullMargin() float64 {
	log.Println("Calling GeometryInstance.GetExtraCullMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_extra_cull_margin", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   GeometryInstanceImplementer is an interface for GeometryInstance objects.
*/
type GeometryInstanceImplementer interface {
	Class
}

/*
   MeshInstance is a [Node] that takes a [Mesh] resource and adds it to the current scenario by creating an instance of it. This is the class most often used to get 3D geometry rendered and can be used to instance a single [Mesh] in many places. This allows to reuse geometry and save on resources. When a [Mesh] has to be instanced more than thousands of times at close proximity, consider using a [MultiMesh] in a [MultiMeshInstance] instead.
*/
type MeshInstance struct {
	GeometryInstance
}

func (o *MeshInstance) baseClass() string {
	return "MeshInstance"
}

/*

 */
func (o *MeshInstance) SetMesh(mesh *Mesh) {
	log.Println("Calling MeshInstance.SetMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mesh)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mesh", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the current [Mesh] resource for the instance.
*/
func (o *MeshInstance) GetMesh() *Mesh {
	log.Println("Calling MeshInstance.GetMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mesh", goArguments, "*Mesh")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Mesh)

	return returnValue

}

/*

 */
func (o *MeshInstance) SetSkeletonPath(skeletonPath *NodePath) {
	log.Println("Calling MeshInstance.SetSkeletonPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(skeletonPath)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_skeleton_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshInstance) GetSkeletonPath() *NodePath {
	log.Println("Calling MeshInstance.GetSkeletonPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_skeleton_path", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*
   Sets the [Material] for a surface of the [Mesh] resource.
*/
func (o *MeshInstance) SetSurfaceMaterial(surface int64, material *Material) {
	log.Println("Calling MeshInstance.SetSurfaceMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(surface)
	goArguments[1] = reflect.ValueOf(material)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_surface_material", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the [Material] for a surface of the [Mesh] resource.
*/
func (o *MeshInstance) GetSurfaceMaterial(surface int64) *Material {
	log.Println("Calling MeshInstance.GetSurfaceMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(surface)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_surface_material", goArguments, "*Material")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Material)

	return returnValue

}

/*
   This helper creates a [StaticBody] child [Node] with a [ConcavePolygonShape] [CollisionShape] calculated from the mesh geometry. It's mainly used for testing.
*/
func (o *MeshInstance) CreateTrimeshCollision() {
	log.Println("Calling MeshInstance.CreateTrimeshCollision()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create_trimesh_collision", goArguments, "")

	log.Println("Got return value!")

}

/*
   This helper creates a [StaticBody] child [Node] with a [ConvexPolygonShape] [CollisionShape] calculated from the mesh geometry. It's mainly used for testing.
*/
func (o *MeshInstance) CreateConvexCollision() {
	log.Println("Calling MeshInstance.CreateConvexCollision()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create_convex_collision", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *MeshInstance) X_MeshChanged() {
	log.Println("Calling MeshInstance.X_MeshChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_mesh_changed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshInstance) CreateDebugTangents() {
	log.Println("Calling MeshInstance.CreateDebugTangents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create_debug_tangents", goArguments, "")

	log.Println("Got return value!")

}

/*
   MeshInstanceImplementer is an interface for MeshInstance objects.
*/
type MeshInstanceImplementer interface {
	Class
}

/*
   Mesh is a type of [Resource] that contains vertex-array based geometry, divided in [i]surfaces[/i]. Each surface contains a completely separate array and a material used to draw it. Design wise, a mesh with multiple surfaces is preferred to a single surface, because objects created in 3D editing software commonly contain multiple materials.
*/
type Mesh struct {
	Resource
}

func (o *Mesh) baseClass() string {
	return "Mesh"
}

/*
   Calculate a [ConcavePolygonShape] from the mesh.
*/
func (o *Mesh) CreateTrimeshShape() *Shape {
	log.Println("Calling Mesh.CreateTrimeshShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "create_trimesh_shape", goArguments, "*Shape")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Shape)

	return returnValue

}

/*
   Calculate a [ConvexPolygonShape] from the mesh.
*/
func (o *Mesh) CreateConvexShape() *Shape {
	log.Println("Calling Mesh.CreateConvexShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "create_convex_shape", goArguments, "*Shape")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Shape)

	return returnValue

}

/*
   Calculate an outline mesh at a defined offset (margin) from the original mesh. Note: Typically returns the vertices in reverse order (e.g. clockwise to anti-clockwise).
*/
func (o *Mesh) CreateOutline(margin float64) *Mesh {
	log.Println("Calling Mesh.CreateOutline()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "create_outline", goArguments, "*Mesh")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Mesh)

	return returnValue

}

/*
   Returns all the vertices that make up the faces of the mesh. Each three vertices represent one triangle.
*/
func (o *Mesh) GetFaces() *PoolVector3Array {
	log.Println("Calling Mesh.GetFaces()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_faces", goArguments, "*PoolVector3Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector3Array)

	return returnValue

}

/*
   Generate a [TriangleMesh] from the mesh.
*/
func (o *Mesh) GenerateTriangleMesh() *TriangleMesh {
	log.Println("Calling Mesh.GenerateTriangleMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "generate_triangle_mesh", goArguments, "*TriangleMesh")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TriangleMesh)

	return returnValue

}

/*
   MeshImplementer is an interface for Mesh objects.
*/
type MeshImplementer interface {
	Class
}

/*

 */
type ImmediateGeometry struct {
	GeometryInstance
}

func (o *ImmediateGeometry) baseClass() string {
	return "ImmediateGeometry"
}

/*
   Begin drawing (And optionally pass a texture override). When done call end(). For more information on how this works, search for glBegin() glEnd() references. For the type of primitive, use the [Mesh].PRIMITIVE_* enumerations.
*/
func (o *ImmediateGeometry) Begin(primitive int64, texture *Texture) {
	log.Println("Calling ImmediateGeometry.Begin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(primitive)
	goArguments[1] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "begin", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the normal that the next vertex will use to be drawn.
*/
func (o *ImmediateGeometry) SetNormal(normal *Vector3) {
	log.Println("Calling ImmediateGeometry.SetNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(normal)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_normal", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the tangent (and binormal facing) that the next vertex will use to be drawn.
*/
func (o *ImmediateGeometry) SetTangent(tangent *Plane) {
	log.Println("Calling ImmediateGeometry.SetTangent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tangent)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tangent", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the color that the next vertex will use to be drawn.
*/
func (o *ImmediateGeometry) SetColor(color *Color) {
	log.Println("Calling ImmediateGeometry.SetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_color", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the UV that the next vertex will use to be drawn.
*/
func (o *ImmediateGeometry) SetUv(uv *Vector2) {
	log.Println("Calling ImmediateGeometry.SetUv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(uv)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_uv", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the second layer of UV that the next vertex will use to be drawn.
*/
func (o *ImmediateGeometry) SetUv2(uv *Vector2) {
	log.Println("Calling ImmediateGeometry.SetUv2()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(uv)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_uv2", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a vertex with the currently set color/uv/etc.
*/
func (o *ImmediateGeometry) AddVertex(position *Vector3) {
	log.Println("Calling ImmediateGeometry.AddVertex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_vertex", goArguments, "")

	log.Println("Got return value!")

}

/*
   Simple helper to draw a uvsphere, with given latitudes, longitude and radius.
*/
func (o *ImmediateGeometry) AddSphere(lats int64, lons int64, radius float64, addUv bool) {
	log.Println("Calling ImmediateGeometry.AddSphere()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(lats)
	goArguments[1] = reflect.ValueOf(lons)
	goArguments[2] = reflect.ValueOf(radius)
	goArguments[3] = reflect.ValueOf(addUv)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_sphere", goArguments, "")

	log.Println("Got return value!")

}

/*
   Call this when done adding a batch of geometry, otherwise it can't be displayed.
*/
func (o *ImmediateGeometry) End() {
	log.Println("Calling ImmediateGeometry.End()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "end", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear everything that was drawn using begin/end.
*/
func (o *ImmediateGeometry) Clear() {
	log.Println("Calling ImmediateGeometry.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   ImmediateGeometryImplementer is an interface for ImmediateGeometry objects.
*/
type ImmediateGeometryImplementer interface {
	Class
}

/*

 */
type SpriteBase3D struct {
	GeometryInstance
}

func (o *SpriteBase3D) baseClass() string {
	return "SpriteBase3D"
}

/*

 */
func (o *SpriteBase3D) SetCentered(centered bool) {
	log.Println("Calling SpriteBase3D.SetCentered()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(centered)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_centered", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteBase3D) IsCentered() bool {
	log.Println("Calling SpriteBase3D.IsCentered()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_centered", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *SpriteBase3D) SetOffset(offset *Vector2) {
	log.Println("Calling SpriteBase3D.SetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_offset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteBase3D) GetOffset() *Vector2 {
	log.Println("Calling SpriteBase3D.GetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *SpriteBase3D) SetFlipH(flipH bool) {
	log.Println("Calling SpriteBase3D.SetFlipH()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flipH)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flip_h", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteBase3D) IsFlippedH() bool {
	log.Println("Calling SpriteBase3D.IsFlippedH()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_flipped_h", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *SpriteBase3D) SetFlipV(flipV bool) {
	log.Println("Calling SpriteBase3D.SetFlipV()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flipV)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flip_v", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteBase3D) IsFlippedV() bool {
	log.Println("Calling SpriteBase3D.IsFlippedV()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_flipped_v", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *SpriteBase3D) SetModulate(modulate *Color) {
	log.Println("Calling SpriteBase3D.SetModulate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(modulate)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_modulate", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteBase3D) GetModulate() *Color {
	log.Println("Calling SpriteBase3D.GetModulate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_modulate", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *SpriteBase3D) SetOpacity(opacity float64) {
	log.Println("Calling SpriteBase3D.SetOpacity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(opacity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_opacity", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteBase3D) GetOpacity() float64 {
	log.Println("Calling SpriteBase3D.GetOpacity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_opacity", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpriteBase3D) SetPixelSize(pixelSize float64) {
	log.Println("Calling SpriteBase3D.SetPixelSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pixelSize)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pixel_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteBase3D) GetPixelSize() float64 {
	log.Println("Calling SpriteBase3D.GetPixelSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pixel_size", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpriteBase3D) SetAxis(axis int64) {
	log.Println("Calling SpriteBase3D.SetAxis()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(axis)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_axis", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteBase3D) GetAxis() int64 {
	log.Println("Calling SpriteBase3D.GetAxis()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_axis", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpriteBase3D) SetDrawFlag(flag int64, enabled bool) {
	log.Println("Calling SpriteBase3D.SetDrawFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(flag)
	goArguments[1] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_draw_flag", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteBase3D) GetDrawFlag(flag int64) bool {
	log.Println("Calling SpriteBase3D.GetDrawFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flag)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_draw_flag", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *SpriteBase3D) SetAlphaCutMode(mode int64) {
	log.Println("Calling SpriteBase3D.SetAlphaCutMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_alpha_cut_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteBase3D) GetAlphaCutMode() int64 {
	log.Println("Calling SpriteBase3D.GetAlphaCutMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_alpha_cut_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpriteBase3D) GetItemRect() *Rect2 {
	log.Println("Calling SpriteBase3D.GetItemRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpriteBase3D) X_QueueUpdate() {
	log.Println("Calling SpriteBase3D.X_QueueUpdate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_queue_update", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *SpriteBase3D) X_ImUpdate() {
	log.Println("Calling SpriteBase3D.X_ImUpdate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_im_update", goArguments, "")

	log.Println("Got return value!")

}

/*
   SpriteBase3DImplementer is an interface for SpriteBase3D objects.
*/
type SpriteBase3DImplementer interface {
	Class
}

/*

 */
type Sprite3D struct {
	SpriteBase3D
}

func (o *Sprite3D) baseClass() string {
	return "Sprite3D"
}

/*

 */
func (o *Sprite3D) SetTexture(texture *Texture) {
	log.Println("Calling Sprite3D.SetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Sprite3D) GetTexture() *Texture {
	log.Println("Calling Sprite3D.GetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *Sprite3D) SetRegion(enabled bool) {
	log.Println("Calling Sprite3D.SetRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_region", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Sprite3D) IsRegion() bool {
	log.Println("Calling Sprite3D.IsRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_region", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Sprite3D) SetRegionRect(rect *Rect2) {
	log.Println("Calling Sprite3D.SetRegionRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rect)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_region_rect", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Sprite3D) GetRegionRect() *Rect2 {
	log.Println("Calling Sprite3D.GetRegionRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_region_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*

 */
func (o *Sprite3D) SetFrame(frame int64) {
	log.Println("Calling Sprite3D.SetFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(frame)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_frame", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Sprite3D) GetFrame() int64 {
	log.Println("Calling Sprite3D.GetFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_frame", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Sprite3D) SetVframes(vframes int64) {
	log.Println("Calling Sprite3D.SetVframes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vframes)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vframes", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Sprite3D) GetVframes() int64 {
	log.Println("Calling Sprite3D.GetVframes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vframes", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Sprite3D) SetHframes(hframes int64) {
	log.Println("Calling Sprite3D.SetHframes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(hframes)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_hframes", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Sprite3D) GetHframes() int64 {
	log.Println("Calling Sprite3D.GetHframes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_hframes", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Sprite3DImplementer is an interface for Sprite3D objects.
*/
type Sprite3DImplementer interface {
	Class
}

/*

 */
type AnimatedSprite3D struct {
	SpriteBase3D
}

func (o *AnimatedSprite3D) baseClass() string {
	return "AnimatedSprite3D"
}

/*
   Set the [SpriteFrames] resource, which contains all frames.
*/
func (o *AnimatedSprite3D) SetSpriteFrames(spriteFrames *SpriteFrames) {
	log.Println("Calling AnimatedSprite3D.SetSpriteFrames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(spriteFrames)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sprite_frames", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the [SpriteFrames] resource, which contains all frames.
*/
func (o *AnimatedSprite3D) GetSpriteFrames() *SpriteFrames {
	log.Println("Calling AnimatedSprite3D.GetSpriteFrames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sprite_frames", goArguments, "*SpriteFrames")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*SpriteFrames)

	return returnValue

}

/*
   Set the current animation of the node and reinits the frame counter of the animation.
*/
func (o *AnimatedSprite3D) SetAnimation(animation string) {
	log.Println("Calling AnimatedSprite3D.SetAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(animation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_animation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the name of the current animation set to the node.
*/
func (o *AnimatedSprite3D) GetAnimation() string {
	log.Println("Calling AnimatedSprite3D.GetAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_animation", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *AnimatedSprite3D) X_SetPlaying(playing bool) {
	log.Println("Calling AnimatedSprite3D.X_SetPlaying()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(playing)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_playing", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *AnimatedSprite3D) X_IsPlaying() bool {
	log.Println("Calling AnimatedSprite3D.X_IsPlaying()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_is_playing", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Play the animation set in parameter. If no parameter is provided, the current animation is played.
*/
func (o *AnimatedSprite3D) Play(anim string) {
	log.Println("Calling AnimatedSprite3D.Play()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anim)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "play", goArguments, "")

	log.Println("Got return value!")

}

/*
   Stop the current animation (does not reset the frame counter).
*/
func (o *AnimatedSprite3D) Stop() {
	log.Println("Calling AnimatedSprite3D.Stop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "stop", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if an animation if currently being played.
*/
func (o *AnimatedSprite3D) IsPlaying() bool {
	log.Println("Calling AnimatedSprite3D.IsPlaying()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_playing", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the visible sprite frame index (from the list of frames inside the [SpriteFrames] resource).
*/
func (o *AnimatedSprite3D) SetFrame(frame int64) {
	log.Println("Calling AnimatedSprite3D.SetFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(frame)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_frame", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the visible frame index.
*/
func (o *AnimatedSprite3D) GetFrame() int64 {
	log.Println("Calling AnimatedSprite3D.GetFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_frame", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *AnimatedSprite3D) X_ResChanged() {
	log.Println("Calling AnimatedSprite3D.X_ResChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_res_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   AnimatedSprite3DImplementer is an interface for AnimatedSprite3D objects.
*/
type AnimatedSprite3DImplementer interface {
	Class
}

/*
   Sprite frame library for [AnimatedSprite]. Contains frames and animation data for playback.
*/
type SpriteFrames struct {
	Resource
}

func (o *SpriteFrames) baseClass() string {
	return "SpriteFrames"
}

/*
   Adds a new animation to the the library.
*/
func (o *SpriteFrames) AddAnimation(anim string) {
	log.Println("Calling SpriteFrames.AddAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anim)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_animation", goArguments, "")

	log.Println("Got return value!")

}

/*
   If [code]true[/code] the named animation exists.
*/
func (o *SpriteFrames) HasAnimation(anim string) bool {
	log.Println("Calling SpriteFrames.HasAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anim)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_animation", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Removes the given animation.
*/
func (o *SpriteFrames) RemoveAnimation(anim string) {
	log.Println("Calling SpriteFrames.RemoveAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anim)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_animation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Changes the animation's name to [code]newname[/code].
*/
func (o *SpriteFrames) RenameAnimation(anim string, newname string) {
	log.Println("Calling SpriteFrames.RenameAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(anim)
	goArguments[1] = reflect.ValueOf(newname)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rename_animation", goArguments, "")

	log.Println("Got return value!")

}

/*
   The animation's speed in frames per second.
*/
func (o *SpriteFrames) SetAnimationSpeed(anim string, speed float64) {
	log.Println("Calling SpriteFrames.SetAnimationSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(anim)
	goArguments[1] = reflect.ValueOf(speed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_animation_speed", goArguments, "")

	log.Println("Got return value!")

}

/*
   The animation's speed in frames per second.
*/
func (o *SpriteFrames) GetAnimationSpeed(anim string) float64 {
	log.Println("Calling SpriteFrames.GetAnimationSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anim)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_animation_speed", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   If [code]true[/code] the animation will loop.
*/
func (o *SpriteFrames) SetAnimationLoop(anim string, loop bool) {
	log.Println("Calling SpriteFrames.SetAnimationLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(anim)
	goArguments[1] = reflect.ValueOf(loop)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_animation_loop", goArguments, "")

	log.Println("Got return value!")

}

/*
   If [code]true[/code] the given animation will loop.
*/
func (o *SpriteFrames) GetAnimationLoop(anim string) bool {
	log.Println("Calling SpriteFrames.GetAnimationLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anim)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_animation_loop", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Adds a frame to the given animation.
*/
func (o *SpriteFrames) AddFrame(anim string, frame *Texture, atPosition int64) {
	log.Println("Calling SpriteFrames.AddFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(anim)
	goArguments[1] = reflect.ValueOf(frame)
	goArguments[2] = reflect.ValueOf(atPosition)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_frame", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the number of frames in the animation.
*/
func (o *SpriteFrames) GetFrameCount(anim string) int64 {
	log.Println("Calling SpriteFrames.GetFrameCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anim)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_frame_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the animation's selected frame.
*/
func (o *SpriteFrames) GetFrame(anim string, idx int64) *Texture {
	log.Println("Calling SpriteFrames.GetFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(anim)
	goArguments[1] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_frame", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   Sets the texture of the given frame.
*/
func (o *SpriteFrames) SetFrame(anim string, idx int64, txt *Texture) {
	log.Println("Calling SpriteFrames.SetFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(anim)
	goArguments[1] = reflect.ValueOf(idx)
	goArguments[2] = reflect.ValueOf(txt)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_frame", goArguments, "")

	log.Println("Got return value!")

}

/*
   Removes the animation's selected frame.
*/
func (o *SpriteFrames) RemoveFrame(anim string, idx int64) {
	log.Println("Calling SpriteFrames.RemoveFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(anim)
	goArguments[1] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_frame", goArguments, "")

	log.Println("Got return value!")

}

/*
   Removes all frames from the given animation.
*/
func (o *SpriteFrames) Clear(anim string) {
	log.Println("Calling SpriteFrames.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anim)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Removes all animations. A "default" animation will be created.
*/
func (o *SpriteFrames) ClearAll() {
	log.Println("Calling SpriteFrames.ClearAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_all", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *SpriteFrames) X_SetFrames(arg0 *Array) {
	log.Println("Calling SpriteFrames.X_SetFrames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_frames", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *SpriteFrames) X_GetFrames() *Array {
	log.Println("Calling SpriteFrames.X_GetFrames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_frames", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpriteFrames) X_SetAnimations(arg0 *Array) {
	log.Println("Calling SpriteFrames.X_SetAnimations()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_animations", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *SpriteFrames) X_GetAnimations() *Array {
	log.Println("Calling SpriteFrames.X_GetAnimations()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_animations", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   SpriteFramesImplementer is an interface for SpriteFrames objects.
*/
type SpriteFramesImplementer interface {
	Class
}

/*
   Light is the abstract base class for light nodes, so it shouldn't be used directly (It can't be instanced). Other types of light nodes inherit from it. Light contains the common variables and parameters used for lighting.
*/
type Light struct {
	VisualInstance
}

func (o *Light) baseClass() string {
	return "Light"
}

/*

 */
func (o *Light) SetEditorOnly(editorOnly bool) {
	log.Println("Calling Light.SetEditorOnly()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(editorOnly)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_editor_only", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Light) IsEditorOnly() bool {
	log.Println("Calling Light.IsEditorOnly()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_editor_only", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Light) SetParam(param int64, value float64) {
	log.Println("Calling Light.SetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_param", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Light) GetParam(param int64) float64 {
	log.Println("Calling Light.GetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Light) SetShadow(enabled bool) {
	log.Println("Calling Light.SetShadow()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Light) HasShadow() bool {
	log.Println("Calling Light.HasShadow()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_shadow", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Light) SetNegative(enabled bool) {
	log.Println("Calling Light.SetNegative()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_negative", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Light) IsNegative() bool {
	log.Println("Calling Light.IsNegative()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_negative", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Light) SetCullMask(cullMask int64) {
	log.Println("Calling Light.SetCullMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(cullMask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cull_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Light) GetCullMask() int64 {
	log.Println("Calling Light.GetCullMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cull_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Light) SetColor(color *Color) {
	log.Println("Calling Light.SetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Light) GetColor() *Color {
	log.Println("Calling Light.GetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *Light) SetShadowReverseCullFace(enable bool) {
	log.Println("Calling Light.SetShadowReverseCullFace()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_reverse_cull_face", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Light) GetShadowReverseCullFace() bool {
	log.Println("Calling Light.GetShadowReverseCullFace()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_reverse_cull_face", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Light) SetShadowColor(shadowColor *Color) {
	log.Println("Calling Light.SetShadowColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shadowColor)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Light) GetShadowColor() *Color {
	log.Println("Calling Light.GetShadowColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   LightImplementer is an interface for Light objects.
*/
type LightImplementer interface {
	Class
}

/*
   A DirectionalLight is a type of [Light] node that emits light constantly in one direction (the negative z axis of the node). It is used lights with strong intensity that are located far away from the scene to model sunlight or moonlight. The worldspace location of the DirectionalLight transform (origin) is ignored, only the basis is used do determine light direction.
*/
type DirectionalLight struct {
	Light
}

func (o *DirectionalLight) baseClass() string {
	return "DirectionalLight"
}

/*

 */
func (o *DirectionalLight) SetShadowMode(mode int64) {
	log.Println("Calling DirectionalLight.SetShadowMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *DirectionalLight) GetShadowMode() int64 {
	log.Println("Calling DirectionalLight.GetShadowMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *DirectionalLight) SetShadowDepthRange(mode int64) {
	log.Println("Calling DirectionalLight.SetShadowDepthRange()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_depth_range", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *DirectionalLight) GetShadowDepthRange() int64 {
	log.Println("Calling DirectionalLight.GetShadowDepthRange()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_depth_range", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *DirectionalLight) SetBlendSplits(enabled bool) {
	log.Println("Calling DirectionalLight.SetBlendSplits()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_blend_splits", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *DirectionalLight) IsBlendSplitsEnabled() bool {
	log.Println("Calling DirectionalLight.IsBlendSplitsEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_blend_splits_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   DirectionalLightImplementer is an interface for DirectionalLight objects.
*/
type DirectionalLightImplementer interface {
	Class
}

/*
   An OmniDirectional light is a type of [Light] node that emits lights in all directions. The light is attenuated through the distance and this attenuation can be configured by changing the energy, radius and attenuation parameters of [Light].
*/
type OmniLight struct {
	Light
}

func (o *OmniLight) baseClass() string {
	return "OmniLight"
}

/*

 */
func (o *OmniLight) SetShadowMode(mode int64) {
	log.Println("Calling OmniLight.SetShadowMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *OmniLight) GetShadowMode() int64 {
	log.Println("Calling OmniLight.GetShadowMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *OmniLight) SetShadowDetail(detail int64) {
	log.Println("Calling OmniLight.SetShadowDetail()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(detail)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_detail", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *OmniLight) GetShadowDetail() int64 {
	log.Println("Calling OmniLight.GetShadowDetail()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_detail", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   OmniLightImplementer is an interface for OmniLight objects.
*/
type OmniLightImplementer interface {
	Class
}

/*
   A SpotLight light is a type of [Light] node that emits lights in a specific direction, in the shape of a cone. The light is attenuated through the distance and this attenuation can be configured by changing the energy, radius and attenuation parameters of [Light]. TODO: Image of a spotlight.
*/
type SpotLight struct {
	Light
}

func (o *SpotLight) baseClass() string {
	return "SpotLight"
}

/*
   SpotLightImplementer is an interface for SpotLight objects.
*/
type SpotLightImplementer interface {
	Class
}

/*

 */
type ReflectionProbe struct {
	VisualInstance
}

func (o *ReflectionProbe) baseClass() string {
	return "ReflectionProbe"
}

/*

 */
func (o *ReflectionProbe) SetIntensity(intensity float64) {
	log.Println("Calling ReflectionProbe.SetIntensity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(intensity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_intensity", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ReflectionProbe) GetIntensity() float64 {
	log.Println("Calling ReflectionProbe.GetIntensity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_intensity", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ReflectionProbe) SetInteriorAmbient(ambient *Color) {
	log.Println("Calling ReflectionProbe.SetInteriorAmbient()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ambient)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_interior_ambient", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ReflectionProbe) GetInteriorAmbient() *Color {
	log.Println("Calling ReflectionProbe.GetInteriorAmbient()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_interior_ambient", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *ReflectionProbe) SetInteriorAmbientEnergy(ambientEnergy float64) {
	log.Println("Calling ReflectionProbe.SetInteriorAmbientEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ambientEnergy)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_interior_ambient_energy", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ReflectionProbe) GetInteriorAmbientEnergy() float64 {
	log.Println("Calling ReflectionProbe.GetInteriorAmbientEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_interior_ambient_energy", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ReflectionProbe) SetInteriorAmbientProbeContribution(ambientProbeContribution float64) {
	log.Println("Calling ReflectionProbe.SetInteriorAmbientProbeContribution()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ambientProbeContribution)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_interior_ambient_probe_contribution", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ReflectionProbe) GetInteriorAmbientProbeContribution() float64 {
	log.Println("Calling ReflectionProbe.GetInteriorAmbientProbeContribution()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_interior_ambient_probe_contribution", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ReflectionProbe) SetMaxDistance(maxDistance float64) {
	log.Println("Calling ReflectionProbe.SetMaxDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(maxDistance)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_distance", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ReflectionProbe) GetMaxDistance() float64 {
	log.Println("Calling ReflectionProbe.GetMaxDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_max_distance", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ReflectionProbe) SetExtents(extents *Vector3) {
	log.Println("Calling ReflectionProbe.SetExtents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(extents)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_extents", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ReflectionProbe) GetExtents() *Vector3 {
	log.Println("Calling ReflectionProbe.GetExtents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_extents", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *ReflectionProbe) SetOriginOffset(originOffset *Vector3) {
	log.Println("Calling ReflectionProbe.SetOriginOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(originOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_origin_offset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ReflectionProbe) GetOriginOffset() *Vector3 {
	log.Println("Calling ReflectionProbe.GetOriginOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_origin_offset", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *ReflectionProbe) SetAsInterior(enable bool) {
	log.Println("Calling ReflectionProbe.SetAsInterior()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_as_interior", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ReflectionProbe) IsSetAsInterior() bool {
	log.Println("Calling ReflectionProbe.IsSetAsInterior()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_set_as_interior", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *ReflectionProbe) SetEnableBoxProjection(enable bool) {
	log.Println("Calling ReflectionProbe.SetEnableBoxProjection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enable_box_projection", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ReflectionProbe) IsBoxProjectionEnabled() bool {
	log.Println("Calling ReflectionProbe.IsBoxProjectionEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_box_projection_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *ReflectionProbe) SetEnableShadows(enable bool) {
	log.Println("Calling ReflectionProbe.SetEnableShadows()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enable_shadows", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ReflectionProbe) AreShadowsEnabled() bool {
	log.Println("Calling ReflectionProbe.AreShadowsEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "are_shadows_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *ReflectionProbe) SetCullMask(layers int64) {
	log.Println("Calling ReflectionProbe.SetCullMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layers)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cull_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ReflectionProbe) GetCullMask() int64 {
	log.Println("Calling ReflectionProbe.GetCullMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cull_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ReflectionProbe) SetUpdateMode(mode int64) {
	log.Println("Calling ReflectionProbe.SetUpdateMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_update_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ReflectionProbe) GetUpdateMode() int64 {
	log.Println("Calling ReflectionProbe.GetUpdateMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_update_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   ReflectionProbeImplementer is an interface for ReflectionProbe objects.
*/
type ReflectionProbeImplementer interface {
	Class
}

/*

 */
type GIProbe struct {
	VisualInstance
}

func (o *GIProbe) baseClass() string {
	return "GIProbe"
}

/*

 */
func (o *GIProbe) SetProbeData(data *GIProbeData) {
	log.Println("Calling GIProbe.SetProbeData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_probe_data", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbe) GetProbeData() *GIProbeData {
	log.Println("Calling GIProbe.GetProbeData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_probe_data", goArguments, "*GIProbeData")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*GIProbeData)

	return returnValue

}

/*

 */
func (o *GIProbe) SetSubdiv(subdiv int64) {
	log.Println("Calling GIProbe.SetSubdiv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(subdiv)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_subdiv", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbe) GetSubdiv() int64 {
	log.Println("Calling GIProbe.GetSubdiv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_subdiv", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *GIProbe) SetExtents(extents *Vector3) {
	log.Println("Calling GIProbe.SetExtents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(extents)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_extents", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbe) GetExtents() *Vector3 {
	log.Println("Calling GIProbe.GetExtents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_extents", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *GIProbe) SetDynamicRange(max int64) {
	log.Println("Calling GIProbe.SetDynamicRange()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(max)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dynamic_range", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbe) GetDynamicRange() int64 {
	log.Println("Calling GIProbe.GetDynamicRange()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dynamic_range", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *GIProbe) SetEnergy(max float64) {
	log.Println("Calling GIProbe.SetEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(max)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_energy", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbe) GetEnergy() float64 {
	log.Println("Calling GIProbe.GetEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_energy", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *GIProbe) SetBias(max float64) {
	log.Println("Calling GIProbe.SetBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(max)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bias", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbe) GetBias() float64 {
	log.Println("Calling GIProbe.GetBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bias", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *GIProbe) SetNormalBias(max float64) {
	log.Println("Calling GIProbe.SetNormalBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(max)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_normal_bias", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbe) GetNormalBias() float64 {
	log.Println("Calling GIProbe.GetNormalBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_normal_bias", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *GIProbe) SetPropagation(max float64) {
	log.Println("Calling GIProbe.SetPropagation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(max)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_propagation", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbe) GetPropagation() float64 {
	log.Println("Calling GIProbe.GetPropagation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_propagation", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *GIProbe) SetInterior(enable bool) {
	log.Println("Calling GIProbe.SetInterior()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_interior", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbe) IsInterior() bool {
	log.Println("Calling GIProbe.IsInterior()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_interior", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *GIProbe) SetCompress(enable bool) {
	log.Println("Calling GIProbe.SetCompress()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_compress", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbe) IsCompressed() bool {
	log.Println("Calling GIProbe.IsCompressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_compressed", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *GIProbe) Bake(fromNode *Object, createVisualDebug bool) {
	log.Println("Calling GIProbe.Bake()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(fromNode)
	goArguments[1] = reflect.ValueOf(createVisualDebug)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "bake", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbe) DebugBake() {
	log.Println("Calling GIProbe.DebugBake()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "debug_bake", goArguments, "")

	log.Println("Got return value!")

}

/*
   GIProbeImplementer is an interface for GIProbe objects.
*/
type GIProbeImplementer interface {
	Class
}

/*

 */
type GIProbeData struct {
	Resource
}

func (o *GIProbeData) baseClass() string {
	return "GIProbeData"
}

/*

 */
func (o *GIProbeData) SetBounds(bounds *Rect3) {
	log.Println("Calling GIProbeData.SetBounds()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bounds)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bounds", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbeData) GetBounds() *Rect3 {
	log.Println("Calling GIProbeData.GetBounds()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bounds", goArguments, "*Rect3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect3)

	return returnValue

}

/*

 */
func (o *GIProbeData) SetCellSize(cellSize float64) {
	log.Println("Calling GIProbeData.SetCellSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(cellSize)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cell_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbeData) GetCellSize() float64 {
	log.Println("Calling GIProbeData.GetCellSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cell_size", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *GIProbeData) SetToCellXform(toCellXform *Transform) {
	log.Println("Calling GIProbeData.SetToCellXform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toCellXform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_to_cell_xform", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbeData) GetToCellXform() *Transform {
	log.Println("Calling GIProbeData.GetToCellXform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_to_cell_xform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*

 */
func (o *GIProbeData) SetDynamicData(dynamicData *PoolIntArray) {
	log.Println("Calling GIProbeData.SetDynamicData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(dynamicData)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dynamic_data", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbeData) GetDynamicData() *PoolIntArray {
	log.Println("Calling GIProbeData.GetDynamicData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dynamic_data", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*

 */
func (o *GIProbeData) SetDynamicRange(dynamicRange int64) {
	log.Println("Calling GIProbeData.SetDynamicRange()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(dynamicRange)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dynamic_range", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbeData) GetDynamicRange() int64 {
	log.Println("Calling GIProbeData.GetDynamicRange()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dynamic_range", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *GIProbeData) SetEnergy(energy float64) {
	log.Println("Calling GIProbeData.SetEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(energy)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_energy", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbeData) GetEnergy() float64 {
	log.Println("Calling GIProbeData.GetEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_energy", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *GIProbeData) SetBias(bias float64) {
	log.Println("Calling GIProbeData.SetBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bias)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bias", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbeData) GetBias() float64 {
	log.Println("Calling GIProbeData.GetBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bias", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *GIProbeData) SetNormalBias(bias float64) {
	log.Println("Calling GIProbeData.SetNormalBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bias)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_normal_bias", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbeData) GetNormalBias() float64 {
	log.Println("Calling GIProbeData.GetNormalBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_normal_bias", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *GIProbeData) SetPropagation(propagation float64) {
	log.Println("Calling GIProbeData.SetPropagation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(propagation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_propagation", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbeData) GetPropagation() float64 {
	log.Println("Calling GIProbeData.GetPropagation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_propagation", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *GIProbeData) SetInterior(interior bool) {
	log.Println("Calling GIProbeData.SetInterior()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(interior)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_interior", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbeData) IsInterior() bool {
	log.Println("Calling GIProbeData.IsInterior()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_interior", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *GIProbeData) SetCompress(compress bool) {
	log.Println("Calling GIProbeData.SetCompress()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(compress)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_compress", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbeData) IsCompressed() bool {
	log.Println("Calling GIProbeData.IsCompressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_compressed", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   GIProbeDataImplementer is an interface for GIProbeData objects.
*/
type GIProbeDataImplementer interface {
	Class
}

/*
   Animation Player that uses a node graph for the blending. This kind of player is very useful when animating character or other skeleton based rigs, because it can combine several animations to form a desired pose.
*/
type AnimationTreePlayer struct {
	Node
}

func (o *AnimationTreePlayer) baseClass() string {
	return "AnimationTreePlayer"
}

/*
   Add a node of a given type in the graph with given id.
*/
func (o *AnimationTreePlayer) AddNode(aType int64, id string) {
	log.Println("Calling AnimationTreePlayer.AddNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(aType)
	goArguments[1] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_node", goArguments, "")

	log.Println("Got return value!")

}

/*
   Check if a node exists (by name).
*/
func (o *AnimationTreePlayer) NodeExists(node string) bool {
	log.Println("Calling AnimationTreePlayer.NodeExists()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "node_exists", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Rename a node in the graph.
*/
func (o *AnimationTreePlayer) NodeRename(node string, newName string) int64 {
	log.Println("Calling AnimationTreePlayer.NodeRename()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(node)
	goArguments[1] = reflect.ValueOf(newName)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "node_rename", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the node type, will return from NODE_* enum.
*/
func (o *AnimationTreePlayer) NodeGetType(id string) int64 {
	log.Println("Calling AnimationTreePlayer.NodeGetType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "node_get_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the input count for a given node. Different types of nodes have different amount of inputs.
*/
func (o *AnimationTreePlayer) NodeGetInputCount(id string) int64 {
	log.Println("Calling AnimationTreePlayer.NodeGetInputCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "node_get_input_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the input source for a given node input.
*/
func (o *AnimationTreePlayer) NodeGetInputSource(id string, idx int64) string {
	log.Println("Calling AnimationTreePlayer.NodeGetInputSource()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "node_get_input_source", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Set the animation for an animation node.
*/
func (o *AnimationTreePlayer) AnimationNodeSetAnimation(id string, animation *Animation) {
	log.Println("Calling AnimationTreePlayer.AnimationNodeSetAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(animation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "animation_node_set_animation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns an animation given its name.
*/
func (o *AnimationTreePlayer) AnimationNodeGetAnimation(id string) *Animation {
	log.Println("Calling AnimationTreePlayer.AnimationNodeGetAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "animation_node_get_animation", goArguments, "*Animation")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Animation)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) AnimationNodeSetMasterAnimation(id string, source string) {
	log.Println("Calling AnimationTreePlayer.AnimationNodeSetMasterAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(source)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "animation_node_set_master_animation", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) AnimationNodeGetMasterAnimation(id string) string {
	log.Println("Calling AnimationTreePlayer.AnimationNodeGetMasterAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "animation_node_get_master_animation", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) AnimationNodeSetFilterPath(id string, path *NodePath, enable bool) {
	log.Println("Calling AnimationTreePlayer.AnimationNodeSetFilterPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(path)
	goArguments[2] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "animation_node_set_filter_path", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets fade in time of a OneShot node given its name and value in seconds.
*/
func (o *AnimationTreePlayer) OneshotNodeSetFadeinTime(id string, timeSec float64) {
	log.Println("Calling AnimationTreePlayer.OneshotNodeSetFadeinTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(timeSec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "oneshot_node_set_fadein_time", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns fade in time of a OneShot node given its name.
*/
func (o *AnimationTreePlayer) OneshotNodeGetFadeinTime(id string) float64 {
	log.Println("Calling AnimationTreePlayer.OneshotNodeGetFadeinTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "oneshot_node_get_fadein_time", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Sets fade out time of a OneShot node given its name and value in seconds.
*/
func (o *AnimationTreePlayer) OneshotNodeSetFadeoutTime(id string, timeSec float64) {
	log.Println("Calling AnimationTreePlayer.OneshotNodeSetFadeoutTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(timeSec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "oneshot_node_set_fadeout_time", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns fade out time of a OneShot node given its name.
*/
func (o *AnimationTreePlayer) OneshotNodeGetFadeoutTime(id string) float64 {
	log.Println("Calling AnimationTreePlayer.OneshotNodeGetFadeoutTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "oneshot_node_get_fadeout_time", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Sets autorestart property of a OneShot node given its name and value.
*/
func (o *AnimationTreePlayer) OneshotNodeSetAutorestart(id string, enable bool) {
	log.Println("Calling AnimationTreePlayer.OneshotNodeSetAutorestart()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "oneshot_node_set_autorestart", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets autorestart delay of a OneShot node given its name and value in seconds.
*/
func (o *AnimationTreePlayer) OneshotNodeSetAutorestartDelay(id string, delaySec float64) {
	log.Println("Calling AnimationTreePlayer.OneshotNodeSetAutorestartDelay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(delaySec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "oneshot_node_set_autorestart_delay", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets autorestart random delay of a OneShot node given its name and value in seconds.
*/
func (o *AnimationTreePlayer) OneshotNodeSetAutorestartRandomDelay(id string, randSec float64) {
	log.Println("Calling AnimationTreePlayer.OneshotNodeSetAutorestartRandomDelay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(randSec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "oneshot_node_set_autorestart_random_delay", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether a OneShot node will auto restart given its name.
*/
func (o *AnimationTreePlayer) OneshotNodeHasAutorestart(id string) bool {
	log.Println("Calling AnimationTreePlayer.OneshotNodeHasAutorestart()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "oneshot_node_has_autorestart", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns autostart delay of a OneShot node given its name.
*/
func (o *AnimationTreePlayer) OneshotNodeGetAutorestartDelay(id string) float64 {
	log.Println("Calling AnimationTreePlayer.OneshotNodeGetAutorestartDelay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "oneshot_node_get_autorestart_delay", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns autostart random delay of a OneShot node given its name.
*/
func (o *AnimationTreePlayer) OneshotNodeGetAutorestartRandomDelay(id string) float64 {
	log.Println("Calling AnimationTreePlayer.OneshotNodeGetAutorestartRandomDelay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "oneshot_node_get_autorestart_random_delay", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Starts a OneShot node given its name.
*/
func (o *AnimationTreePlayer) OneshotNodeStart(id string) {
	log.Println("Calling AnimationTreePlayer.OneshotNodeStart()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "oneshot_node_start", goArguments, "")

	log.Println("Got return value!")

}

/*
   Stops a OneShot node given its name.
*/
func (o *AnimationTreePlayer) OneshotNodeStop(id string) {
	log.Println("Calling AnimationTreePlayer.OneshotNodeStop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "oneshot_node_stop", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether a OneShot node is active given its name.
*/
func (o *AnimationTreePlayer) OneshotNodeIsActive(id string) bool {
	log.Println("Calling AnimationTreePlayer.OneshotNodeIsActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "oneshot_node_is_active", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) OneshotNodeSetFilterPath(id string, path *NodePath, enable bool) {
	log.Println("Calling AnimationTreePlayer.OneshotNodeSetFilterPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(path)
	goArguments[2] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "oneshot_node_set_filter_path", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets mix amount of a Mix node given its name and value.
*/
func (o *AnimationTreePlayer) MixNodeSetAmount(id string, ratio float64) {
	log.Println("Calling AnimationTreePlayer.MixNodeSetAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(ratio)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "mix_node_set_amount", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns mix amount of a Mix node given its name.
*/
func (o *AnimationTreePlayer) MixNodeGetAmount(id string) float64 {
	log.Println("Calling AnimationTreePlayer.MixNodeGetAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "mix_node_get_amount", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Sets the blend amount of a Blend2 node given its name and value.
*/
func (o *AnimationTreePlayer) Blend2NodeSetAmount(id string, blend float64) {
	log.Println("Calling AnimationTreePlayer.Blend2NodeSetAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(blend)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "blend2_node_set_amount", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the blend amount of a Blend2 node given its name.
*/
func (o *AnimationTreePlayer) Blend2NodeGetAmount(id string) float64 {
	log.Println("Calling AnimationTreePlayer.Blend2NodeGetAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "blend2_node_get_amount", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) Blend2NodeSetFilterPath(id string, path *NodePath, enable bool) {
	log.Println("Calling AnimationTreePlayer.Blend2NodeSetFilterPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(path)
	goArguments[2] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "blend2_node_set_filter_path", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the blend amount of a Blend3 node given its name and value.
*/
func (o *AnimationTreePlayer) Blend3NodeSetAmount(id string, blend float64) {
	log.Println("Calling AnimationTreePlayer.Blend3NodeSetAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(blend)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "blend3_node_set_amount", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the blend amount of a Blend3 node given its name.
*/
func (o *AnimationTreePlayer) Blend3NodeGetAmount(id string) float64 {
	log.Println("Calling AnimationTreePlayer.Blend3NodeGetAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "blend3_node_get_amount", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Sets the blend amount of a Blend4 node given its name and value.
*/
func (o *AnimationTreePlayer) Blend4NodeSetAmount(id string, blend *Vector2) {
	log.Println("Calling AnimationTreePlayer.Blend4NodeSetAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(blend)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "blend4_node_set_amount", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the blend amount of a Blend4 node given its name.
*/
func (o *AnimationTreePlayer) Blend4NodeGetAmount(id string) *Vector2 {
	log.Println("Calling AnimationTreePlayer.Blend4NodeGetAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "blend4_node_get_amount", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Sets time scale value of a TimeScale node given its name and value.
*/
func (o *AnimationTreePlayer) TimescaleNodeSetScale(id string, scale float64) {
	log.Println("Calling AnimationTreePlayer.TimescaleNodeSetScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "timescale_node_set_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns time scale value of a TimeScale node given its name.
*/
func (o *AnimationTreePlayer) TimescaleNodeGetScale(id string) float64 {
	log.Println("Calling AnimationTreePlayer.TimescaleNodeGetScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "timescale_node_get_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Sets time seek value of a TimeSeek node given its name and value.
*/
func (o *AnimationTreePlayer) TimeseekNodeSeek(id string, seconds float64) {
	log.Println("Calling AnimationTreePlayer.TimeseekNodeSeek()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(seconds)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "timeseek_node_seek", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) TransitionNodeSetInputCount(id string, count int64) {
	log.Println("Calling AnimationTreePlayer.TransitionNodeSetInputCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(count)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "transition_node_set_input_count", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) TransitionNodeGetInputCount(id string) int64 {
	log.Println("Calling AnimationTreePlayer.TransitionNodeGetInputCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "transition_node_get_input_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) TransitionNodeDeleteInput(id string, inputIdx int64) {
	log.Println("Calling AnimationTreePlayer.TransitionNodeDeleteInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(inputIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "transition_node_delete_input", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) TransitionNodeSetInputAutoAdvance(id string, inputIdx int64, enable bool) {
	log.Println("Calling AnimationTreePlayer.TransitionNodeSetInputAutoAdvance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(inputIdx)
	goArguments[2] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "transition_node_set_input_auto_advance", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) TransitionNodeHasInputAutoAdvance(id string, inputIdx int64) bool {
	log.Println("Calling AnimationTreePlayer.TransitionNodeHasInputAutoAdvance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(inputIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "transition_node_has_input_auto_advance", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) TransitionNodeSetXfadeTime(id string, timeSec float64) {
	log.Println("Calling AnimationTreePlayer.TransitionNodeSetXfadeTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(timeSec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "transition_node_set_xfade_time", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) TransitionNodeGetXfadeTime(id string) float64 {
	log.Println("Calling AnimationTreePlayer.TransitionNodeGetXfadeTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "transition_node_get_xfade_time", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) TransitionNodeSetCurrent(id string, inputIdx int64) {
	log.Println("Calling AnimationTreePlayer.TransitionNodeSetCurrent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(inputIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "transition_node_set_current", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) TransitionNodeGetCurrent(id string) int64 {
	log.Println("Calling AnimationTreePlayer.TransitionNodeGetCurrent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "transition_node_get_current", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Sets position of a node in the graph given its name and position.
*/
func (o *AnimationTreePlayer) NodeSetPosition(id string, screenPosition *Vector2) {
	log.Println("Calling AnimationTreePlayer.NodeSetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(screenPosition)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "node_set_position", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns position of a node in the graph given its name.
*/
func (o *AnimationTreePlayer) NodeGetPosition(id string) *Vector2 {
	log.Println("Calling AnimationTreePlayer.NodeGetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "node_get_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) RemoveNode(id string) {
	log.Println("Calling AnimationTreePlayer.RemoveNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_node", goArguments, "")

	log.Println("Got return value!")

}

/*
   Connects node [code]id[/code] to [code]dst_id[/code] at the specified input slot.
*/
func (o *AnimationTreePlayer) ConnectNodes(id string, dstId string, dstInputIdx int64) int64 {
	log.Println("Calling AnimationTreePlayer.ConnectNodes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(dstId)
	goArguments[2] = reflect.ValueOf(dstInputIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "connect_nodes", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns whether node [code]id[/code] and [code]dst_id[/code] are connected at the specified slot.
*/
func (o *AnimationTreePlayer) AreNodesConnected(id string, dstId string, dstInputIdx int64) bool {
	log.Println("Calling AnimationTreePlayer.AreNodesConnected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(dstId)
	goArguments[2] = reflect.ValueOf(dstInputIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "are_nodes_connected", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Disconnects nodes connected to [code]id[/code] at the specified input slot.
*/
func (o *AnimationTreePlayer) DisconnectNodes(id string, dstInputIdx int64) {
	log.Println("Calling AnimationTreePlayer.DisconnectNodes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(dstInputIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "disconnect_nodes", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets whether this AnimationTreePlayer is active. AnimationTreePlayer will start processing if set to active.
*/
func (o *AnimationTreePlayer) SetActive(enabled bool) {
	log.Println("Calling AnimationTreePlayer.SetActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_active", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether this AnimationTreePlayer is active.
*/
func (o *AnimationTreePlayer) IsActive() bool {
	log.Println("Calling AnimationTreePlayer.IsActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_active", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Sets base path of this AnimationTreePlayer.
*/
func (o *AnimationTreePlayer) SetBasePath(path *NodePath) {
	log.Println("Calling AnimationTreePlayer.SetBasePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) GetBasePath() *NodePath {
	log.Println("Calling AnimationTreePlayer.GetBasePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_path", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) SetMasterPlayer(nodepath *NodePath) {
	log.Println("Calling AnimationTreePlayer.SetMasterPlayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(nodepath)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_master_player", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) GetMasterPlayer() *NodePath {
	log.Println("Calling AnimationTreePlayer.GetMasterPlayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_master_player", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*
   Returns a PoolStringArray containing the name of all nodes.
*/
func (o *AnimationTreePlayer) GetNodeList() *PoolStringArray {
	log.Println("Calling AnimationTreePlayer.GetNodeList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_list", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Sets process mode (ANIMATION_PROCESS_*) of this AnimationTreePlayer.
*/
func (o *AnimationTreePlayer) SetAnimationProcessMode(mode int64) {
	log.Println("Calling AnimationTreePlayer.SetAnimationProcessMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_animation_process_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns playback process mode of this AnimationTreePlayer.
*/
func (o *AnimationTreePlayer) GetAnimationProcessMode() int64 {
	log.Println("Calling AnimationTreePlayer.GetAnimationProcessMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_animation_process_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) Advance(delta float64) {
	log.Println("Calling AnimationTreePlayer.Advance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(delta)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "advance", goArguments, "")

	log.Println("Got return value!")

}

/*
   Resets this AnimationTreePlayer.
*/
func (o *AnimationTreePlayer) Reset() {
	log.Println("Calling AnimationTreePlayer.Reset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "reset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) RecomputeCaches() {
	log.Println("Calling AnimationTreePlayer.RecomputeCaches()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "recompute_caches", goArguments, "")

	log.Println("Got return value!")

}

/*
   AnimationTreePlayerImplementer is an interface for AnimationTreePlayer objects.
*/
type AnimationTreePlayerImplementer interface {
	Class
}

/*

 */
type Particles struct {
	GeometryInstance
}

func (o *Particles) baseClass() string {
	return "Particles"
}

/*

 */
func (o *Particles) SetEmitting(emitting bool) {
	log.Println("Calling Particles.SetEmitting()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(emitting)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emitting", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetAmount(amount int64) {
	log.Println("Calling Particles.SetAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_amount", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetLifetime(secs float64) {
	log.Println("Calling Particles.SetLifetime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(secs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_lifetime", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetOneShot(enable bool) {
	log.Println("Calling Particles.SetOneShot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_one_shot", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetPreProcessTime(secs float64) {
	log.Println("Calling Particles.SetPreProcessTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(secs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pre_process_time", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetExplosivenessRatio(ratio float64) {
	log.Println("Calling Particles.SetExplosivenessRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ratio)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_explosiveness_ratio", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetRandomnessRatio(ratio float64) {
	log.Println("Calling Particles.SetRandomnessRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ratio)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_randomness_ratio", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetVisibilityAabb(aabb *Rect3) {
	log.Println("Calling Particles.SetVisibilityAabb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aabb)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_visibility_aabb", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetUseLocalCoordinates(enable bool) {
	log.Println("Calling Particles.SetUseLocalCoordinates()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_local_coordinates", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetFixedFps(fps int64) {
	log.Println("Calling Particles.SetFixedFps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fps)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fixed_fps", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetFractionalDelta(enable bool) {
	log.Println("Calling Particles.SetFractionalDelta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fractional_delta", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetProcessMaterial(material *Material) {
	log.Println("Calling Particles.SetProcessMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(material)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_process_material", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetSpeedScale(scale float64) {
	log.Println("Calling Particles.SetSpeedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_speed_scale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) IsEmitting() bool {
	log.Println("Calling Particles.IsEmitting()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_emitting", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Particles) GetAmount() int64 {
	log.Println("Calling Particles.GetAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_amount", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Particles) GetLifetime() float64 {
	log.Println("Calling Particles.GetLifetime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_lifetime", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Particles) GetOneShot() bool {
	log.Println("Calling Particles.GetOneShot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_one_shot", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Particles) GetPreProcessTime() float64 {
	log.Println("Calling Particles.GetPreProcessTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pre_process_time", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Particles) GetExplosivenessRatio() float64 {
	log.Println("Calling Particles.GetExplosivenessRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_explosiveness_ratio", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Particles) GetRandomnessRatio() float64 {
	log.Println("Calling Particles.GetRandomnessRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_randomness_ratio", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Particles) GetVisibilityAabb() *Rect3 {
	log.Println("Calling Particles.GetVisibilityAabb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_visibility_aabb", goArguments, "*Rect3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect3)

	return returnValue

}

/*

 */
func (o *Particles) GetUseLocalCoordinates() bool {
	log.Println("Calling Particles.GetUseLocalCoordinates()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_use_local_coordinates", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Particles) GetFixedFps() int64 {
	log.Println("Calling Particles.GetFixedFps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fixed_fps", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Particles) GetFractionalDelta() bool {
	log.Println("Calling Particles.GetFractionalDelta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fractional_delta", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Particles) GetProcessMaterial() *Material {
	log.Println("Calling Particles.GetProcessMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_process_material", goArguments, "*Material")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Material)

	return returnValue

}

/*

 */
func (o *Particles) GetSpeedScale() float64 {
	log.Println("Calling Particles.GetSpeedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_speed_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Particles) SetDrawOrder(order int64) {
	log.Println("Calling Particles.SetDrawOrder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(order)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_draw_order", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) GetDrawOrder() int64 {
	log.Println("Calling Particles.GetDrawOrder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_draw_order", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Particles) SetDrawPasses(passes int64) {
	log.Println("Calling Particles.SetDrawPasses()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(passes)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_draw_passes", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetDrawPassMesh(pass int64, mesh *Mesh) {
	log.Println("Calling Particles.SetDrawPassMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(pass)
	goArguments[1] = reflect.ValueOf(mesh)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_draw_pass_mesh", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) GetDrawPasses() int64 {
	log.Println("Calling Particles.GetDrawPasses()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_draw_passes", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Particles) GetDrawPassMesh(pass int64) *Mesh {
	log.Println("Calling Particles.GetDrawPassMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pass)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_draw_pass_mesh", goArguments, "*Mesh")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Mesh)

	return returnValue

}

/*

 */
func (o *Particles) Restart() {
	log.Println("Calling Particles.Restart()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "restart", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) CaptureAabb() *Rect3 {
	log.Println("Calling Particles.CaptureAabb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "capture_aabb", goArguments, "*Rect3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect3)

	return returnValue

}

/*
   ParticlesImplementer is an interface for Particles objects.
*/
type ParticlesImplementer interface {
	Class
}

/*
   Generic 3D Position hint for editing. It's just like a plain [Spatial] but displays as a cross in the 3D-Editor at all times.
*/
type Position3D struct {
	Spatial
}

func (o *Position3D) baseClass() string {
	return "Position3D"
}

/*
   Position3DImplementer is an interface for Position3D objects.
*/
type Position3DImplementer interface {
	Class
}

/*

 */
type NavigationMeshInstance struct {
	Spatial
}

func (o *NavigationMeshInstance) baseClass() string {
	return "NavigationMeshInstance"
}

/*

 */
func (o *NavigationMeshInstance) SetNavigationMesh(navmesh *NavigationMesh) {
	log.Println("Calling NavigationMeshInstance.SetNavigationMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(navmesh)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_navigation_mesh", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationMeshInstance) GetNavigationMesh() *NavigationMesh {
	log.Println("Calling NavigationMeshInstance.GetNavigationMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_navigation_mesh", goArguments, "*NavigationMesh")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NavigationMesh)

	return returnValue

}

/*

 */
func (o *NavigationMeshInstance) SetEnabled(enabled bool) {
	log.Println("Calling NavigationMeshInstance.SetEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationMeshInstance) IsEnabled() bool {
	log.Println("Calling NavigationMeshInstance.IsEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   NavigationMeshInstanceImplementer is an interface for NavigationMeshInstance objects.
*/
type NavigationMeshInstanceImplementer interface {
	Class
}

/*

 */
type NavigationMesh struct {
	Resource
}

func (o *NavigationMesh) baseClass() string {
	return "NavigationMesh"
}

/*

 */
func (o *NavigationMesh) SetSamplePartitionType(samplePartitionType int64) {
	log.Println("Calling NavigationMesh.SetSamplePartitionType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(samplePartitionType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sample_partition_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationMesh) GetSamplePartitionType() int64 {
	log.Println("Calling NavigationMesh.GetSamplePartitionType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sample_partition_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *NavigationMesh) SetCellSize(cellSize float64) {
	log.Println("Calling NavigationMesh.SetCellSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(cellSize)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cell_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationMesh) GetCellSize() float64 {
	log.Println("Calling NavigationMesh.GetCellSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cell_size", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *NavigationMesh) SetCellHeight(cellHeight float64) {
	log.Println("Calling NavigationMesh.SetCellHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(cellHeight)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cell_height", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationMesh) GetCellHeight() float64 {
	log.Println("Calling NavigationMesh.GetCellHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cell_height", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *NavigationMesh) SetAgentHeight(agentHeight float64) {
	log.Println("Calling NavigationMesh.SetAgentHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(agentHeight)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_agent_height", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationMesh) GetAgentHeight() float64 {
	log.Println("Calling NavigationMesh.GetAgentHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_agent_height", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *NavigationMesh) SetAgentRadius(agentRadius float64) {
	log.Println("Calling NavigationMesh.SetAgentRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(agentRadius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_agent_radius", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationMesh) GetAgentRadius() float64 {
	log.Println("Calling NavigationMesh.GetAgentRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_agent_radius", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *NavigationMesh) SetAgentMaxClimb(agentMaxClimb float64) {
	log.Println("Calling NavigationMesh.SetAgentMaxClimb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(agentMaxClimb)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_agent_max_climb", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationMesh) GetAgentMaxClimb() float64 {
	log.Println("Calling NavigationMesh.GetAgentMaxClimb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_agent_max_climb", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *NavigationMesh) SetAgentMaxSlope(agentMaxSlope float64) {
	log.Println("Calling NavigationMesh.SetAgentMaxSlope()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(agentMaxSlope)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_agent_max_slope", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationMesh) GetAgentMaxSlope() float64 {
	log.Println("Calling NavigationMesh.GetAgentMaxSlope()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_agent_max_slope", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *NavigationMesh) SetRegionMinSize(regionMinSize float64) {
	log.Println("Calling NavigationMesh.SetRegionMinSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(regionMinSize)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_region_min_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationMesh) GetRegionMinSize() float64 {
	log.Println("Calling NavigationMesh.GetRegionMinSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_region_min_size", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *NavigationMesh) SetRegionMergeSize(regionMergeSize float64) {
	log.Println("Calling NavigationMesh.SetRegionMergeSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(regionMergeSize)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_region_merge_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationMesh) GetRegionMergeSize() float64 {
	log.Println("Calling NavigationMesh.GetRegionMergeSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_region_merge_size", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *NavigationMesh) SetEdgeMaxLength(edgeMaxLength float64) {
	log.Println("Calling NavigationMesh.SetEdgeMaxLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(edgeMaxLength)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_edge_max_length", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationMesh) GetEdgeMaxLength() float64 {
	log.Println("Calling NavigationMesh.GetEdgeMaxLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_edge_max_length", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *NavigationMesh) SetEdgeMaxError(edgeMaxError float64) {
	log.Println("Calling NavigationMesh.SetEdgeMaxError()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(edgeMaxError)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_edge_max_error", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationMesh) GetEdgeMaxError() float64 {
	log.Println("Calling NavigationMesh.GetEdgeMaxError()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_edge_max_error", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *NavigationMesh) SetVertsPerPoly(vertsPerPoly float64) {
	log.Println("Calling NavigationMesh.SetVertsPerPoly()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vertsPerPoly)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_verts_per_poly", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationMesh) GetVertsPerPoly() float64 {
	log.Println("Calling NavigationMesh.GetVertsPerPoly()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_verts_per_poly", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *NavigationMesh) SetDetailSampleDistance(detailSampleDist float64) {
	log.Println("Calling NavigationMesh.SetDetailSampleDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(detailSampleDist)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_detail_sample_distance", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationMesh) GetDetailSampleDistance() float64 {
	log.Println("Calling NavigationMesh.GetDetailSampleDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_detail_sample_distance", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *NavigationMesh) SetDetailSampleMaxError(detailSampleMaxError float64) {
	log.Println("Calling NavigationMesh.SetDetailSampleMaxError()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(detailSampleMaxError)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_detail_sample_max_error", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationMesh) GetDetailSampleMaxError() float64 {
	log.Println("Calling NavigationMesh.GetDetailSampleMaxError()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_detail_sample_max_error", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *NavigationMesh) SetFilterLowHangingObstacles(filterLowHangingObstacles bool) {
	log.Println("Calling NavigationMesh.SetFilterLowHangingObstacles()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(filterLowHangingObstacles)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_filter_low_hanging_obstacles", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationMesh) GetFilterLowHangingObstacles() bool {
	log.Println("Calling NavigationMesh.GetFilterLowHangingObstacles()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_filter_low_hanging_obstacles", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *NavigationMesh) SetFilterLedgeSpans(filterLedgeSpans bool) {
	log.Println("Calling NavigationMesh.SetFilterLedgeSpans()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(filterLedgeSpans)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_filter_ledge_spans", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationMesh) GetFilterLedgeSpans() bool {
	log.Println("Calling NavigationMesh.GetFilterLedgeSpans()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_filter_ledge_spans", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *NavigationMesh) SetFilterWalkableLowHeightSpans(filterWalkableLowHeightSpans bool) {
	log.Println("Calling NavigationMesh.SetFilterWalkableLowHeightSpans()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(filterWalkableLowHeightSpans)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_filter_walkable_low_height_spans", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationMesh) GetFilterWalkableLowHeightSpans() bool {
	log.Println("Calling NavigationMesh.GetFilterWalkableLowHeightSpans()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_filter_walkable_low_height_spans", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *NavigationMesh) SetVertices(vertices *PoolVector3Array) {
	log.Println("Calling NavigationMesh.SetVertices()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vertices)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vertices", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationMesh) GetVertices() *PoolVector3Array {
	log.Println("Calling NavigationMesh.GetVertices()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertices", goArguments, "*PoolVector3Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector3Array)

	return returnValue

}

/*

 */
func (o *NavigationMesh) AddPolygon(polygon *PoolIntArray) {
	log.Println("Calling NavigationMesh.AddPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(polygon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_polygon", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationMesh) GetPolygonCount() int64 {
	log.Println("Calling NavigationMesh.GetPolygonCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_polygon_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *NavigationMesh) GetPolygon(idx int64) *PoolIntArray {
	log.Println("Calling NavigationMesh.GetPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_polygon", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*

 */
func (o *NavigationMesh) ClearPolygons() {
	log.Println("Calling NavigationMesh.ClearPolygons()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_polygons", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationMesh) CreateFromMesh(mesh *Mesh) {
	log.Println("Calling NavigationMesh.CreateFromMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mesh)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create_from_mesh", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *NavigationMesh) X_SetPolygons(polygons *Array) {
	log.Println("Calling NavigationMesh.X_SetPolygons()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(polygons)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_polygons", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *NavigationMesh) X_GetPolygons() *Array {
	log.Println("Calling NavigationMesh.X_GetPolygons()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_polygons", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   NavigationMeshImplementer is an interface for NavigationMesh objects.
*/
type NavigationMeshImplementer interface {
	Class
}

/*

 */
type Navigation struct {
	Spatial
}

func (o *Navigation) baseClass() string {
	return "Navigation"
}

/*

 */
func (o *Navigation) NavmeshCreate(mesh *NavigationMesh, xform *Transform, owner *Object) int64 {
	log.Println("Calling Navigation.NavmeshCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(mesh)
	goArguments[1] = reflect.ValueOf(xform)
	goArguments[2] = reflect.ValueOf(owner)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "navmesh_create", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Navigation) NavmeshSetTransform(id int64, xform *Transform) {
	log.Println("Calling Navigation.NavmeshSetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(xform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "navmesh_set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Navigation) NavmeshRemove(id int64) {
	log.Println("Calling Navigation.NavmeshRemove()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "navmesh_remove", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Navigation) GetSimplePath(start *Vector3, end *Vector3, optimize bool) *PoolVector3Array {
	log.Println("Calling Navigation.GetSimplePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(start)
	goArguments[1] = reflect.ValueOf(end)
	goArguments[2] = reflect.ValueOf(optimize)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_simple_path", goArguments, "*PoolVector3Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector3Array)

	return returnValue

}

/*

 */
func (o *Navigation) GetClosestPointToSegment(start *Vector3, end *Vector3, useCollision bool) *Vector3 {
	log.Println("Calling Navigation.GetClosestPointToSegment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(start)
	goArguments[1] = reflect.ValueOf(end)
	goArguments[2] = reflect.ValueOf(useCollision)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_point_to_segment", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *Navigation) GetClosestPoint(toPoint *Vector3) *Vector3 {
	log.Println("Calling Navigation.GetClosestPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_point", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *Navigation) GetClosestPointNormal(toPoint *Vector3) *Vector3 {
	log.Println("Calling Navigation.GetClosestPointNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_point_normal", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *Navigation) GetClosestPointOwner(toPoint *Vector3) *Object {
	log.Println("Calling Navigation.GetClosestPointOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_point_owner", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*

 */
func (o *Navigation) SetUpVector(up *Vector3) {
	log.Println("Calling Navigation.SetUpVector()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(up)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_up_vector", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Navigation) GetUpVector() *Vector3 {
	log.Println("Calling Navigation.GetUpVector()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_up_vector", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   NavigationImplementer is an interface for Navigation objects.
*/
type NavigationImplementer interface {
	Class
}

/*
   CollisionObject is the base class for physics objects. It can hold any number of collision [Shape]\ s. Each shape must be assigned to a [i]shape owner[/i]. The CollisionObject can have any number of shape owners. Shape owners are not nodes and do not appear in the editor, but are accessible through code using the [code]shape_owner_*[/code] methods.
*/
type CollisionObject struct {
	Spatial
}

func (o *CollisionObject) baseClass() string {
	return "CollisionObject"
}

/*

 */
func (o *CollisionObject) X_InputEvent(camera *Object, event *InputEvent, clickPosition *Vector3, clickNormal *Vector3, shapeIdx int64) {
	log.Println("Calling CollisionObject.X_InputEvent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(camera)
	goArguments[1] = reflect.ValueOf(event)
	goArguments[2] = reflect.ValueOf(clickPosition)
	goArguments[3] = reflect.ValueOf(clickNormal)
	goArguments[4] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_input_event", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionObject) SetRayPickable(rayPickable bool) {
	log.Println("Calling CollisionObject.SetRayPickable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rayPickable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ray_pickable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionObject) IsRayPickable() bool {
	log.Println("Calling CollisionObject.IsRayPickable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_ray_pickable", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *CollisionObject) SetCaptureInputOnDrag(enable bool) {
	log.Println("Calling CollisionObject.SetCaptureInputOnDrag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_capture_input_on_drag", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionObject) GetCaptureInputOnDrag() bool {
	log.Println("Calling CollisionObject.GetCaptureInputOnDrag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_capture_input_on_drag", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns the object's [RID].
*/
func (o *CollisionObject) GetRid() *RID {
	log.Println("Calling CollisionObject.GetRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rid", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Creates a new shape owner for the given object. Returns [code]owner_id[/code] of the new owner for future reference.
*/
func (o *CollisionObject) CreateShapeOwner(owner *Object) int64 {
	log.Println("Calling CollisionObject.CreateShapeOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(owner)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "create_shape_owner", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Removes the given shape owner.
*/
func (o *CollisionObject) RemoveShapeOwner(ownerId int64) {
	log.Println("Calling CollisionObject.RemoveShapeOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ownerId)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_shape_owner", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns an [Array] of [code]owner_id[/code] identifiers. You can use these ids in other methods that take [code]owner_id[/code] as an argument.
*/
func (o *CollisionObject) GetShapeOwners() *Array {
	log.Println("Calling CollisionObject.GetShapeOwners()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shape_owners", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Sets the [Transform] of the given shape owner.
*/
func (o *CollisionObject) ShapeOwnerSetTransform(ownerId int64, transform *Transform) {
	log.Println("Calling CollisionObject.ShapeOwnerSetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ownerId)
	goArguments[1] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shape_owner_set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the shape owner's [Transform].
*/
func (o *CollisionObject) ShapeOwnerGetTransform(ownerId int64) *Transform {
	log.Println("Calling CollisionObject.ShapeOwnerGetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ownerId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_owner_get_transform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*
   Returns the parent object of the given shape owner.
*/
func (o *CollisionObject) ShapeOwnerGetOwner(ownerId int64) *Object {
	log.Println("Calling CollisionObject.ShapeOwnerGetOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ownerId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_owner_get_owner", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*
   If [code]true[/code] disables the given shape owner.
*/
func (o *CollisionObject) ShapeOwnerSetDisabled(ownerId int64, disabled bool) {
	log.Println("Calling CollisionObject.ShapeOwnerSetDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ownerId)
	goArguments[1] = reflect.ValueOf(disabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shape_owner_set_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   If [code]true[/code] the shape owner and its shapes are disabled.
*/
func (o *CollisionObject) IsShapeOwnerDisabled(ownerId int64) bool {
	log.Println("Calling CollisionObject.IsShapeOwnerDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ownerId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_shape_owner_disabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Adds a [Shape] to the shape owner.
*/
func (o *CollisionObject) ShapeOwnerAddShape(ownerId int64, shape *Shape) {
	log.Println("Calling CollisionObject.ShapeOwnerAddShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ownerId)
	goArguments[1] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shape_owner_add_shape", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the number of shapes the given shape owner contains.
*/
func (o *CollisionObject) ShapeOwnerGetShapeCount(ownerId int64) int64 {
	log.Println("Calling CollisionObject.ShapeOwnerGetShapeCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ownerId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_owner_get_shape_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the [Shape] with the given id from the given shape owner.
*/
func (o *CollisionObject) ShapeOwnerGetShape(ownerId int64, shapeId int64) *Shape {
	log.Println("Calling CollisionObject.ShapeOwnerGetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ownerId)
	goArguments[1] = reflect.ValueOf(shapeId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_owner_get_shape", goArguments, "*Shape")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Shape)

	return returnValue

}

/*

 */
func (o *CollisionObject) ShapeOwnerGetShapeIndex(ownerId int64, shapeId int64) int64 {
	log.Println("Calling CollisionObject.ShapeOwnerGetShapeIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ownerId)
	goArguments[1] = reflect.ValueOf(shapeId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_owner_get_shape_index", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Removes a shape from the given shape owner.
*/
func (o *CollisionObject) ShapeOwnerRemoveShape(ownerId int64, shapeId int64) {
	log.Println("Calling CollisionObject.ShapeOwnerRemoveShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ownerId)
	goArguments[1] = reflect.ValueOf(shapeId)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shape_owner_remove_shape", goArguments, "")

	log.Println("Got return value!")

}

/*
   Removes all shapes from the shape owner.
*/
func (o *CollisionObject) ShapeOwnerClearShapes(ownerId int64) {
	log.Println("Calling CollisionObject.ShapeOwnerClearShapes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ownerId)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shape_owner_clear_shapes", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the [code]owner_id[/code] of the given shape.
*/
func (o *CollisionObject) ShapeFindOwner(shapeIndex int64) int64 {
	log.Println("Calling CollisionObject.ShapeFindOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shapeIndex)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_find_owner", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   CollisionObjectImplementer is an interface for CollisionObject objects.
*/
type CollisionObjectImplementer interface {
	Class
}

/*
   PhysicsBody is an abstract base class for implementing a physics body. All *Body types inherit from it.
*/
type PhysicsBody struct {
	CollisionObject
}

func (o *PhysicsBody) baseClass() string {
	return "PhysicsBody"
}

/*

 */
func (o *PhysicsBody) SetCollisionLayer(layer int64) {
	log.Println("Calling PhysicsBody.SetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsBody) GetCollisionLayer() int64 {
	log.Println("Calling PhysicsBody.GetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsBody) SetCollisionMask(mask int64) {
	log.Println("Calling PhysicsBody.SetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsBody) GetCollisionMask() int64 {
	log.Println("Calling PhysicsBody.GetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsBody) SetCollisionMaskBit(bit int64, value bool) {
	log.Println("Calling PhysicsBody.SetCollisionMaskBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(bit)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_mask_bit", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsBody) GetCollisionMaskBit(bit int64) bool {
	log.Println("Calling PhysicsBody.GetCollisionMaskBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bit)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_mask_bit", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *PhysicsBody) SetCollisionLayerBit(bit int64, value bool) {
	log.Println("Calling PhysicsBody.SetCollisionLayerBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(bit)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer_bit", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsBody) GetCollisionLayerBit(bit int64) bool {
	log.Println("Calling PhysicsBody.GetCollisionLayerBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bit)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer_bit", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *PhysicsBody) X_SetLayers(mask int64) {
	log.Println("Calling PhysicsBody.X_SetLayers()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_layers", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *PhysicsBody) X_GetLayers() int64 {
	log.Println("Calling PhysicsBody.X_GetLayers()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_layers", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Adds a body to the list of bodies that this body can't collide with.
*/
func (o *PhysicsBody) AddCollisionExceptionWith(body *Object) {
	log.Println("Calling PhysicsBody.AddCollisionExceptionWith()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_collision_exception_with", goArguments, "")

	log.Println("Got return value!")

}

/*
   Removes a body from the list of bodies that this body can't collide with.
*/
func (o *PhysicsBody) RemoveCollisionExceptionWith(body *Object) {
	log.Println("Calling PhysicsBody.RemoveCollisionExceptionWith()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_collision_exception_with", goArguments, "")

	log.Println("Got return value!")

}

/*
   PhysicsBodyImplementer is an interface for PhysicsBody objects.
*/
type PhysicsBodyImplementer interface {
	Class
}

/*
   Static body for 3D Physics. A static body is a simple body that is not intended to move. They don't consume any CPU resources in contrast to a [RigidBody3D] so they are great for scenario collision. A static body can also be animated by using simulated motion mode. This is useful for implementing functionalities such as moving platforms. When this mode is active the body can be animated and automatically computes linear and angular velocity to apply in that frame and to influence other bodies. Alternatively, a constant linear or angular velocity can be set for the static body, so even if it doesn't move, it affects other bodies as if it was moving (this is useful for simulating conveyor belts or conveyor wheels).
*/
type StaticBody struct {
	PhysicsBody
}

func (o *StaticBody) baseClass() string {
	return "StaticBody"
}

/*
   Set a constant linear velocity for the body. This does not move the body, but affects other bodies touching it, as if it was moving.
*/
func (o *StaticBody) SetConstantLinearVelocity(vel *Vector3) {
	log.Println("Calling StaticBody.SetConstantLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_constant_linear_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set a constant angular velocity for the body. This does not rotate the body, but affects other bodies touching it, as if it was rotating.
*/
func (o *StaticBody) SetConstantAngularVelocity(vel *Vector3) {
	log.Println("Calling StaticBody.SetConstantAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_constant_angular_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the constant linear velocity for the body.
*/
func (o *StaticBody) GetConstantLinearVelocity() *Vector3 {
	log.Println("Calling StaticBody.GetConstantLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_constant_linear_velocity", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Return the constant angular velocity for the body.
*/
func (o *StaticBody) GetConstantAngularVelocity() *Vector3 {
	log.Println("Calling StaticBody.GetConstantAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_constant_angular_velocity", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Set the body friction, from 0 (frictionless) to 1 (full friction).
*/
func (o *StaticBody) SetFriction(friction float64) {
	log.Println("Calling StaticBody.SetFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(friction)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_friction", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the body friction.
*/
func (o *StaticBody) GetFriction() float64 {
	log.Println("Calling StaticBody.GetFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_friction", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the body bounciness, from 0 (not bouncy) to 1 (bouncy).
*/
func (o *StaticBody) SetBounce(bounce float64) {
	log.Println("Calling StaticBody.SetBounce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bounce)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bounce", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the body bounciness.
*/
func (o *StaticBody) GetBounce() float64 {
	log.Println("Calling StaticBody.GetBounce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bounce", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   StaticBodyImplementer is an interface for StaticBody objects.
*/
type StaticBodyImplementer interface {
	Class
}

/*
   This is the node that implements full 3D physics. This means that you do not control a RigidBody directly. Instead you can apply forces to it (gravity, impulses, etc.), and the physics simulation will calculate the resulting movement, collision, bouncing, rotating, etc. This node can use custom force integration, for writing complex physics motion behavior per node. This node can shift state between regular Rigid body, Kinematic, Character or Static. Character mode forbids this node from being rotated. As a warning, don't change RigidBody's position every frame or very often. Sporadic changes work fine, but physics runs at a different granularity (fixed hz) than usual rendering (process callback) and maybe even in a separate thread, so changing this from a process loop will yield strange behavior.
*/
type RigidBody struct {
	PhysicsBody
}

func (o *RigidBody) baseClass() string {
	return "RigidBody"
}

/*
   Called during physics processing, allowing you to read and safely modify the simulation state for the object. By default it works in addition to the usual physics behavior, but [method set_use_custom_integrator] allows you to disable the default behavior and do fully custom force integration for a body.
*/
func (o *RigidBody) X_IntegrateForces(state *PhysicsDirectBodyState) {
	log.Println("Calling RigidBody.X_IntegrateForces()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(state)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_integrate_forces", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the body mode, from the MODE_* enum. This allows to change to a static body or a character body.
*/
func (o *RigidBody) SetMode(mode int64) {
	log.Println("Calling RigidBody.SetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current body mode, see [method set_mode].
*/
func (o *RigidBody) GetMode() int64 {
	log.Println("Calling RigidBody.GetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the body mass.
*/
func (o *RigidBody) SetMass(mass float64) {
	log.Println("Calling RigidBody.SetMass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mass)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mass", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current body mass.
*/
func (o *RigidBody) GetMass() float64 {
	log.Println("Calling RigidBody.GetMass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mass", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the body weight given standard earth-weight (gravity 9.8).
*/
func (o *RigidBody) SetWeight(weight float64) {
	log.Println("Calling RigidBody.SetWeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(weight)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_weight", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current body weight, given standard earth-weight (gravity 9.8).
*/
func (o *RigidBody) GetWeight() float64 {
	log.Println("Calling RigidBody.GetWeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_weight", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the body friction, from 0 (frictionless) to 1 (max friction).
*/
func (o *RigidBody) SetFriction(friction float64) {
	log.Println("Calling RigidBody.SetFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(friction)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_friction", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current body friction, from 0 (frictionless) to 1 (max friction).
*/
func (o *RigidBody) GetFriction() float64 {
	log.Println("Calling RigidBody.GetFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_friction", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the body bounciness, from 0 (no bounciness) to 1 (max bounciness).
*/
func (o *RigidBody) SetBounce(bounce float64) {
	log.Println("Calling RigidBody.SetBounce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bounce)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bounce", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current body bounciness.
*/
func (o *RigidBody) GetBounce() float64 {
	log.Println("Calling RigidBody.GetBounce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bounce", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the body linear velocity. Can be used sporadically, but [b]DON'T SET THIS IN EVERY FRAME[/b], because physics may be running in another thread and definitely runs at a different granularity. Use [method _integrate_forces] as your process loop if you want to have precise control of the body state.
*/
func (o *RigidBody) SetLinearVelocity(linearVelocity *Vector3) {
	log.Println("Calling RigidBody.SetLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(linearVelocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_linear_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current body linear velocity.
*/
func (o *RigidBody) GetLinearVelocity() *Vector3 {
	log.Println("Calling RigidBody.GetLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_linear_velocity", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Set the body angular velocity. Can be used sporadically, but [b]DON'T SET THIS IN EVERY FRAME[/b], because physics may be running in another thread and definitely runs at a different granularity. Use [method _integrate_forces] as your process loop if you want to have precise control of the body state.
*/
func (o *RigidBody) SetAngularVelocity(angularVelocity *Vector3) {
	log.Println("Calling RigidBody.SetAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(angularVelocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_angular_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current body angular velocity.
*/
func (o *RigidBody) GetAngularVelocity() *Vector3 {
	log.Println("Calling RigidBody.GetAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_angular_velocity", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Set the gravity factor. This factor multiplies gravity intensity just for this body.
*/
func (o *RigidBody) SetGravityScale(gravityScale float64) {
	log.Println("Calling RigidBody.SetGravityScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(gravityScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current body gravity scale.
*/
func (o *RigidBody) GetGravityScale() float64 {
	log.Println("Calling RigidBody.GetGravityScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gravity_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the linear damp for this body. Default of -1, cannot be less than -1. If this value is different from -1, any linear damp derived from the world or areas will be overridden.
*/
func (o *RigidBody) SetLinearDamp(linearDamp float64) {
	log.Println("Calling RigidBody.SetLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(linearDamp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_linear_damp", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current body linear damp. Default is -1.
*/
func (o *RigidBody) GetLinearDamp() float64 {
	log.Println("Calling RigidBody.GetLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_linear_damp", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the angular damp for this body. Default of -1, cannot be less than -1. If this value is different from -1, any angular damp derived from the world or areas will be overridden.
*/
func (o *RigidBody) SetAngularDamp(angularDamp float64) {
	log.Println("Calling RigidBody.SetAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(angularDamp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_angular_damp", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current body angular damp. Default is -1.
*/
func (o *RigidBody) GetAngularDamp() float64 {
	log.Println("Calling RigidBody.GetAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_angular_damp", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the maximum contacts to report. Bodies can keep a log of the contacts with other bodies, this is enabled by setting the maximum amount of contacts reported to a number greater than 0.
*/
func (o *RigidBody) SetMaxContactsReported(amount int64) {
	log.Println("Calling RigidBody.SetMaxContactsReported()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_contacts_reported", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the maximum contacts that can be reported. See [method set_max_contacts_reported].
*/
func (o *RigidBody) GetMaxContactsReported() int64 {
	log.Println("Calling RigidBody.GetMaxContactsReported()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_max_contacts_reported", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Pass true to disable the internal force integration (like gravity or air friction) for this body. Other than collision response, the body will only move as determined by the [method _integrate_forces] function, if defined.
*/
func (o *RigidBody) SetUseCustomIntegrator(enable bool) {
	log.Println("Calling RigidBody.SetUseCustomIntegrator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_custom_integrator", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether the body is using a custom integrator.
*/
func (o *RigidBody) IsUsingCustomIntegrator() bool {
	log.Println("Calling RigidBody.IsUsingCustomIntegrator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_using_custom_integrator", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Enable contact monitoring. This allows the body to emit signals when it collides with another.
*/
func (o *RigidBody) SetContactMonitor(enabled bool) {
	log.Println("Calling RigidBody.SetContactMonitor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_contact_monitor", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether contact monitoring is enabled.
*/
func (o *RigidBody) IsContactMonitorEnabled() bool {
	log.Println("Calling RigidBody.IsContactMonitorEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_contact_monitor_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the continuous collision detection mode from the enum CCD_MODE_*. Continuous collision detection tries to predict where a moving body will collide, instead of moving it and correcting its movement if it collided. The first is more precise, and misses less impacts by small, fast-moving objects. The second is faster to compute, but can miss small, fast-moving objects.
*/
func (o *RigidBody) SetUseContinuousCollisionDetection(enable bool) {
	log.Println("Calling RigidBody.SetUseContinuousCollisionDetection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_continuous_collision_detection", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether this body is using continuous collision detection.
*/
func (o *RigidBody) IsUsingContinuousCollisionDetection() bool {
	log.Println("Calling RigidBody.IsUsingContinuousCollisionDetection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_using_continuous_collision_detection", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set an axis velocity. The velocity in the given vector axis will be set as the given vector length. This is useful for jumping behavior.
*/
func (o *RigidBody) SetAxisVelocity(axisVelocity *Vector3) {
	log.Println("Calling RigidBody.SetAxisVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(axisVelocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_axis_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Apply a positioned impulse (which will be affected by the body mass and shape). This is the equivalent of hitting a billiard ball with a cue: a force that is applied once, and only once. Both the impulse and the offset from the body origin are in global coordinates.
*/
func (o *RigidBody) ApplyImpulse(position *Vector3, impulse *Vector3) {
	log.Println("Calling RigidBody.ApplyImpulse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(position)
	goArguments[1] = reflect.ValueOf(impulse)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "apply_impulse", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether a body is sleeping or not. Sleeping bodies are not affected by forces until a collision or an [method apply_impulse] wakes them up. Until then, they behave like a static body.
*/
func (o *RigidBody) SetSleeping(sleeping bool) {
	log.Println("Calling RigidBody.SetSleeping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sleeping)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sleeping", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether the body is sleeping.
*/
func (o *RigidBody) IsSleeping() bool {
	log.Println("Calling RigidBody.IsSleeping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_sleeping", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the body ability to fall asleep when not moving. This saves an enormous amount of processor time when there are plenty of rigid bodies (non static) in a scene. Sleeping bodies are not affected by forces until a collision or an [method apply_impulse] / [method set_applied_force] wakes them up. Until then, they behave like a static body.
*/
func (o *RigidBody) SetCanSleep(ableToSleep bool) {
	log.Println("Calling RigidBody.SetCanSleep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ableToSleep)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_can_sleep", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether the body has the ability to fall asleep when not moving. See [method set_can_sleep].
*/
func (o *RigidBody) IsAbleToSleep() bool {
	log.Println("Calling RigidBody.IsAbleToSleep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_able_to_sleep", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody) X_DirectStateChanged(arg0 *Object) {
	log.Println("Calling RigidBody.X_DirectStateChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_direct_state_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *RigidBody) X_BodyEnterTree(arg0 int64) {
	log.Println("Calling RigidBody.X_BodyEnterTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_body_enter_tree", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *RigidBody) X_BodyExitTree(arg0 int64) {
	log.Println("Calling RigidBody.X_BodyExitTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_body_exit_tree", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the axis lock of the body, from the AXIS_LOCK_* enum. Axis lock stops the body from moving along the specified axis(X/Y/Z) and rotating along the other two axes.
*/
func (o *RigidBody) SetAxisLock(axisLock int64) {
	log.Println("Calling RigidBody.SetAxisLock()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(axisLock)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_axis_lock", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current axis lock of the body. One of AXIS_LOCK_* enum.
*/
func (o *RigidBody) GetAxisLock() int64 {
	log.Println("Calling RigidBody.GetAxisLock()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_axis_lock", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return a list of the bodies colliding with this one. By default, number of max contacts reported is at 0 , see [method set_max_contacts_reported] to increase it.
*/
func (o *RigidBody) GetCollidingBodies() *Array {
	log.Println("Calling RigidBody.GetCollidingBodies()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_colliding_bodies", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   RigidBodyImplementer is an interface for RigidBody objects.
*/
type RigidBodyImplementer interface {
	Class
}

/*
   Contains collision data for KinematicBody collisions. When a [KinematicBody] is moved using [method KinematicBody.move_and_collide], it stops if it detects a collision with another body. If a collision is detected, a KinematicCollision object is returned. This object contains information about the collision, including the colliding object, the remaining motion, and the collision position. This information can be used to calculate a collision response.
*/
type KinematicCollision struct {
	Reference
}

func (o *KinematicCollision) baseClass() string {
	return "KinematicCollision"
}

/*

 */
func (o *KinematicCollision) GetPosition() *Vector3 {
	log.Println("Calling KinematicCollision.GetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_position", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *KinematicCollision) GetNormal() *Vector3 {
	log.Println("Calling KinematicCollision.GetNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_normal", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *KinematicCollision) GetTravel() *Vector3 {
	log.Println("Calling KinematicCollision.GetTravel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_travel", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *KinematicCollision) GetRemainder() *Vector3 {
	log.Println("Calling KinematicCollision.GetRemainder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_remainder", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *KinematicCollision) GetLocalShape() *Object {
	log.Println("Calling KinematicCollision.GetLocalShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_local_shape", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*

 */
func (o *KinematicCollision) GetCollider() *Object {
	log.Println("Calling KinematicCollision.GetCollider()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*

 */
func (o *KinematicCollision) GetColliderId() int64 {
	log.Println("Calling KinematicCollision.GetColliderId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *KinematicCollision) GetColliderShape() *Object {
	log.Println("Calling KinematicCollision.GetColliderShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider_shape", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*

 */
func (o *KinematicCollision) GetColliderShapeIndex() int64 {
	log.Println("Calling KinematicCollision.GetColliderShapeIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider_shape_index", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *KinematicCollision) GetColliderVelocity() *Vector3 {
	log.Println("Calling KinematicCollision.GetColliderVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider_velocity", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *KinematicCollision) GetColliderMetadata() *Variant {
	log.Println("Calling KinematicCollision.GetColliderMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider_metadata", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   KinematicCollisionImplementer is an interface for KinematicCollision objects.
*/
type KinematicCollisionImplementer interface {
	Class
}

/*
   Kinematic bodies are special types of bodies that are meant to be user-controlled. They are not affected by physics at all (to other types of bodies, such a character or a rigid body, these are the same as a static body). They have however, two main uses: Simulated Motion: When these bodies are moved manually, either from code or from an AnimationPlayer (with process mode set to fixed), the physics will automatically compute an estimate of their linear and angular velocity. This makes them very useful for moving platforms or other AnimationPlayer-controlled objects (like a door, a bridge that opens, etc). Kinematic Characters: KinematicBody also has an api for moving objects (the [method move] method) while performing collision tests. This makes them really useful to implement characters that collide against a world, but that don't require advanced physics.
*/
type KinematicBody struct {
	PhysicsBody
}

func (o *KinematicBody) baseClass() string {
	return "KinematicBody"
}

/*

 */
func (o *KinematicBody) MoveAndCollide(relVec *Vector3) *KinematicCollision {
	log.Println("Calling KinematicBody.MoveAndCollide()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(relVec)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "move_and_collide", goArguments, "*KinematicCollision")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*KinematicCollision)

	return returnValue

}

/*

 */
func (o *KinematicBody) MoveAndSlide(linearVelocity *Vector3, floorNormal *Vector3, slopeStopMinVelocity float64, maxSlides int64, floorMaxAngle float64) *Vector3 {
	log.Println("Calling KinematicBody.MoveAndSlide()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(linearVelocity)
	goArguments[1] = reflect.ValueOf(floorNormal)
	goArguments[2] = reflect.ValueOf(slopeStopMinVelocity)
	goArguments[3] = reflect.ValueOf(maxSlides)
	goArguments[4] = reflect.ValueOf(floorMaxAngle)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "move_and_slide", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *KinematicBody) TestMove(from *Transform, relVec *Vector3) bool {
	log.Println("Calling KinematicBody.TestMove()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(relVec)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "test_move", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *KinematicBody) IsOnFloor() bool {
	log.Println("Calling KinematicBody.IsOnFloor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_on_floor", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *KinematicBody) IsOnCeiling() bool {
	log.Println("Calling KinematicBody.IsOnCeiling()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_on_ceiling", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *KinematicBody) IsOnWall() bool {
	log.Println("Calling KinematicBody.IsOnWall()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_on_wall", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *KinematicBody) GetFloorVelocity() *Vector3 {
	log.Println("Calling KinematicBody.GetFloorVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_floor_velocity", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *KinematicBody) SetSafeMargin(pixels float64) {
	log.Println("Calling KinematicBody.SetSafeMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pixels)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_safe_margin", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *KinematicBody) GetSafeMargin() float64 {
	log.Println("Calling KinematicBody.GetSafeMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_safe_margin", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *KinematicBody) GetSlideCount() int64 {
	log.Println("Calling KinematicBody.GetSlideCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_slide_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *KinematicBody) GetSlideCollision(slideIdx int64) *KinematicCollision {
	log.Println("Calling KinematicBody.GetSlideCollision()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(slideIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_slide_collision", goArguments, "*KinematicCollision")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*KinematicCollision)

	return returnValue

}

/*
   KinematicBodyImplementer is an interface for KinematicBody objects.
*/
type KinematicBodyImplementer interface {
	Class
}

/*

 */
type VehicleBody struct {
	PhysicsBody
}

func (o *VehicleBody) baseClass() string {
	return "VehicleBody"
}

/*

 */
func (o *VehicleBody) SetMass(mass float64) {
	log.Println("Calling VehicleBody.SetMass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mass)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mass", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleBody) GetMass() float64 {
	log.Println("Calling VehicleBody.GetMass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mass", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *VehicleBody) SetFriction(friction float64) {
	log.Println("Calling VehicleBody.SetFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(friction)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_friction", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleBody) GetFriction() float64 {
	log.Println("Calling VehicleBody.GetFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_friction", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *VehicleBody) SetEngineForce(engineForce float64) {
	log.Println("Calling VehicleBody.SetEngineForce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(engineForce)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_engine_force", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleBody) GetEngineForce() float64 {
	log.Println("Calling VehicleBody.GetEngineForce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_engine_force", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *VehicleBody) SetBrake(brake float64) {
	log.Println("Calling VehicleBody.SetBrake()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(brake)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_brake", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleBody) GetBrake() float64 {
	log.Println("Calling VehicleBody.GetBrake()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_brake", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the steering angle (in radians).
*/
func (o *VehicleBody) SetSteering(steering float64) {
	log.Println("Calling VehicleBody.SetSteering()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(steering)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_steering", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the steering angle (in radians).
*/
func (o *VehicleBody) GetSteering() float64 {
	log.Println("Calling VehicleBody.GetSteering()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_steering", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns the VehicleBody's velocity vector. To get the absolute speed in scalar value, get the length of the return vector in pixels/second. Example: [codeblock] # vehicle is an instance of VehicleBody var speed = vehicle.get_linear_velocity().length() [/codeblock]
*/
func (o *VehicleBody) GetLinearVelocity() *Vector3 {
	log.Println("Calling VehicleBody.GetLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_linear_velocity", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Undocumented
*/
func (o *VehicleBody) X_DirectStateChanged(arg0 *Object) {
	log.Println("Calling VehicleBody.X_DirectStateChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_direct_state_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   VehicleBodyImplementer is an interface for VehicleBody objects.
*/
type VehicleBodyImplementer interface {
	Class
}

/*

 */
type VehicleWheel struct {
	Spatial
}

func (o *VehicleWheel) baseClass() string {
	return "VehicleWheel"
}

/*

 */
func (o *VehicleWheel) SetRadius(length float64) {
	log.Println("Calling VehicleWheel.SetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(length)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_radius", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleWheel) GetRadius() float64 {
	log.Println("Calling VehicleWheel.GetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_radius", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *VehicleWheel) SetSuspensionRestLength(length float64) {
	log.Println("Calling VehicleWheel.SetSuspensionRestLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(length)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_suspension_rest_length", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleWheel) GetSuspensionRestLength() float64 {
	log.Println("Calling VehicleWheel.GetSuspensionRestLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_suspension_rest_length", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *VehicleWheel) SetSuspensionTravel(length float64) {
	log.Println("Calling VehicleWheel.SetSuspensionTravel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(length)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_suspension_travel", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleWheel) GetSuspensionTravel() float64 {
	log.Println("Calling VehicleWheel.GetSuspensionTravel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_suspension_travel", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *VehicleWheel) SetSuspensionStiffness(length float64) {
	log.Println("Calling VehicleWheel.SetSuspensionStiffness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(length)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_suspension_stiffness", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleWheel) GetSuspensionStiffness() float64 {
	log.Println("Calling VehicleWheel.GetSuspensionStiffness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_suspension_stiffness", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *VehicleWheel) SetSuspensionMaxForce(length float64) {
	log.Println("Calling VehicleWheel.SetSuspensionMaxForce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(length)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_suspension_max_force", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleWheel) GetSuspensionMaxForce() float64 {
	log.Println("Calling VehicleWheel.GetSuspensionMaxForce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_suspension_max_force", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *VehicleWheel) SetDampingCompression(length float64) {
	log.Println("Calling VehicleWheel.SetDampingCompression()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(length)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_damping_compression", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleWheel) GetDampingCompression() float64 {
	log.Println("Calling VehicleWheel.GetDampingCompression()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_damping_compression", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *VehicleWheel) SetDampingRelaxation(length float64) {
	log.Println("Calling VehicleWheel.SetDampingRelaxation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(length)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_damping_relaxation", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleWheel) GetDampingRelaxation() float64 {
	log.Println("Calling VehicleWheel.GetDampingRelaxation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_damping_relaxation", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *VehicleWheel) SetUseAsTraction(enable bool) {
	log.Println("Calling VehicleWheel.SetUseAsTraction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_as_traction", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleWheel) IsUsedAsTraction() bool {
	log.Println("Calling VehicleWheel.IsUsedAsTraction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_used_as_traction", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *VehicleWheel) SetUseAsSteering(enable bool) {
	log.Println("Calling VehicleWheel.SetUseAsSteering()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_as_steering", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleWheel) IsUsedAsSteering() bool {
	log.Println("Calling VehicleWheel.IsUsedAsSteering()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_used_as_steering", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *VehicleWheel) SetFrictionSlip(length float64) {
	log.Println("Calling VehicleWheel.SetFrictionSlip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(length)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_friction_slip", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleWheel) GetFrictionSlip() float64 {
	log.Println("Calling VehicleWheel.GetFrictionSlip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_friction_slip", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *VehicleWheel) IsInContact() bool {
	log.Println("Calling VehicleWheel.IsInContact()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_in_contact", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *VehicleWheel) SetRollInfluence(rollInfluence float64) {
	log.Println("Calling VehicleWheel.SetRollInfluence()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rollInfluence)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_roll_influence", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleWheel) GetRollInfluence() float64 {
	log.Println("Calling VehicleWheel.GetRollInfluence()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_roll_influence", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   VehicleWheelImplementer is an interface for VehicleWheel objects.
*/
type VehicleWheelImplementer interface {
	Class
}

/*
   3D area that detects [CollisionObject] nodes overlapping, entering, or exiting. Can also alter or override local physics parameters (gravity, damping).
*/
type Area struct {
	CollisionObject
}

func (o *Area) baseClass() string {
	return "Area"
}

/*
   Undocumented
*/
func (o *Area) X_BodyEnterTree(id int64) {
	log.Println("Calling Area.X_BodyEnterTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_body_enter_tree", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Area) X_BodyExitTree(id int64) {
	log.Println("Calling Area.X_BodyExitTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_body_exit_tree", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Area) X_AreaEnterTree(id int64) {
	log.Println("Calling Area.X_AreaEnterTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_area_enter_tree", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Area) X_AreaExitTree(id int64) {
	log.Println("Calling Area.X_AreaExitTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_area_exit_tree", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the space override mode. This mode controls how an area affects gravity and damp. AREA_SPACE_OVERRIDE_DISABLED: This area does not affect gravity/damp. These are generally areas that exist only to detect collisions, and objects entering or exiting them. AREA_SPACE_OVERRIDE_COMBINE: This area adds its gravity/damp values to whatever has been calculated so far. This way, many overlapping areas can combine their physics to make interesting effects. AREA_SPACE_OVERRIDE_COMBINE_REPLACE: This area adds its gravity/damp values to whatever has been calculated so far. Then stops taking into account the rest of the areas, even the default one. AREA_SPACE_OVERRIDE_REPLACE: This area replaces any gravity/damp, even the default one, and stops taking into account the rest of the areas. AREA_SPACE_OVERRIDE_REPLACE_COMBINE: This area replaces any gravity/damp calculated so far, but keeps calculating the rest of the areas, down to the default one.
*/
func (o *Area) SetSpaceOverrideMode(enable int64) {
	log.Println("Calling Area.SetSpaceOverrideMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_space_override_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the space override mode.
*/
func (o *Area) GetSpaceOverrideMode() int64 {
	log.Println("Calling Area.GetSpaceOverrideMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_space_override_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   When overriding space parameters, this method sets whether this area has a center of gravity. To set/get the location of the center of gravity, use [method set_gravity_vector]/[method get_gravity_vector].
*/
func (o *Area) SetGravityIsPoint(enable bool) {
	log.Println("Calling Area.SetGravityIsPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity_is_point", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether gravity is a point. A point gravity will attract objects towards it, as opposed to a gravity vector, which moves them in a given direction.
*/
func (o *Area) IsGravityAPoint() bool {
	log.Println("Calling Area.IsGravityAPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_gravity_a_point", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the falloff factor for point gravity. The greater this value is, the faster the strength of gravity decreases with the square of distance.
*/
func (o *Area) SetGravityDistanceScale(distanceScale float64) {
	log.Println("Calling Area.SetGravityDistanceScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(distanceScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity_distance_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the falloff factor for point gravity.
*/
func (o *Area) GetGravityDistanceScale() float64 {
	log.Println("Calling Area.GetGravityDistanceScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gravity_distance_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the gravity vector. This vector does not have to be normalized. If gravity is a point (see [method is_gravity_a_point]), this will be the attraction center.
*/
func (o *Area) SetGravityVector(vector *Vector3) {
	log.Println("Calling Area.SetGravityVector()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vector)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity_vector", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the gravity vector. If gravity is a point (see [method is_gravity_a_point]), this will be the attraction center.
*/
func (o *Area) GetGravityVector() *Vector3 {
	log.Println("Calling Area.GetGravityVector()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gravity_vector", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Set the gravity intensity. This is useful to alter the force of gravity without altering its direction. This value multiplies the gravity vector, whether it is the given vector ([method set_gravity_vector]), or a calculated one (when using a center of gravity).
*/
func (o *Area) SetGravity(gravity float64) {
	log.Println("Calling Area.SetGravity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(gravity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the gravity intensity.
*/
func (o *Area) GetGravity() float64 {
	log.Println("Calling Area.GetGravity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gravity", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the rate at which objects stop spinning in this area, if there are not any other forces making it spin. The value is a fraction of its current speed, lost per second. Thus, a value of 1.0 should mean stopping immediately, and 0.0 means the object never stops. In practice, as the fraction of speed lost gets smaller with each frame, a value of 1.0 does not mean the object will stop in exactly one second. Only when the physics calculations are done at 1 frame per second, it does stop in a second.
*/
func (o *Area) SetAngularDamp(angularDamp float64) {
	log.Println("Calling Area.SetAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(angularDamp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_angular_damp", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the angular damp rate.
*/
func (o *Area) GetAngularDamp() float64 {
	log.Println("Calling Area.GetAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_angular_damp", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the rate at which objects stop moving in this area, if there are not any other forces moving it. The value is a fraction of its current speed, lost per second. Thus, a value of 1.0 should mean stopping immediately, and 0.0 means the object never stops. In practice, as the fraction of speed lost gets smaller with each frame, a value of 1.0 does not mean the object will stop in exactly one second. Only when the physics calculations are done at 1 frame per second, it does stop in a second.
*/
func (o *Area) SetLinearDamp(linearDamp float64) {
	log.Println("Calling Area.SetLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(linearDamp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_linear_damp", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the linear damp rate.
*/
func (o *Area) GetLinearDamp() float64 {
	log.Println("Calling Area.GetLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_linear_damp", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the order in which the area is processed. Greater values mean the area gets processed first. This is useful for areas which have a space override different from AREA_SPACE_OVERRIDE_DISABLED or AREA_SPACE_OVERRIDE_COMBINE, as they replace values, and are thus order-dependent. Areas with the same priority value get evaluated in an unpredictable order, and should be differentiated if evaluation order is to be important.
*/
func (o *Area) SetPriority(priority float64) {
	log.Println("Calling Area.SetPriority()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(priority)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_priority", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the processing order of this area.
*/
func (o *Area) GetPriority() float64 {
	log.Println("Calling Area.GetPriority()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_priority", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the physics layers this area can scan for collisions.
*/
func (o *Area) SetCollisionMask(collisionMask int64) {
	log.Println("Calling Area.SetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collisionMask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the physics layers this area can scan for collisions.
*/
func (o *Area) GetCollisionMask() int64 {
	log.Println("Calling Area.GetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the physics layers this area is in. Collidable objects can exist in any of 32 different layers. These layers are not visual, but more of a tagging system instead. A collidable can use these layers/tags to select with which objects it can collide, using [method set_collision_mask]. A contact is detected if object A is in any of the layers that object B scans, or object B is in any layer scanned by object A.
*/
func (o *Area) SetCollisionLayer(collisionLayer int64) {
	log.Println("Calling Area.SetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collisionLayer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the physics layer this area is in.
*/
func (o *Area) GetCollisionLayer() int64 {
	log.Println("Calling Area.GetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set/clear individual bits on the collision mask. This makes selecting the areas scanned easier.
*/
func (o *Area) SetCollisionMaskBit(bit int64, value bool) {
	log.Println("Calling Area.SetCollisionMaskBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(bit)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_mask_bit", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return an individual bit on the collision mask.
*/
func (o *Area) GetCollisionMaskBit(bit int64) bool {
	log.Println("Calling Area.GetCollisionMaskBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bit)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_mask_bit", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set/clear individual bits on the layer mask. This makes getting an area in/out of only one layer easier.
*/
func (o *Area) SetCollisionLayerBit(bit int64, value bool) {
	log.Println("Calling Area.SetCollisionLayerBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(bit)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer_bit", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return an individual bit on the layer mask.
*/
func (o *Area) GetCollisionLayerBit(bit int64) bool {
	log.Println("Calling Area.GetCollisionLayerBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bit)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer_bit", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set whether this area can be detected by other, monitoring, areas. Only areas need to be marked as monitorable. Bodies are always so.
*/
func (o *Area) SetMonitorable(enable bool) {
	log.Println("Calling Area.SetMonitorable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_monitorable", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether this area can be detected by other, monitoring, areas.
*/
func (o *Area) IsMonitorable() bool {
	log.Println("Calling Area.IsMonitorable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_monitorable", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set whether this area can detect bodies/areas entering/exiting it.
*/
func (o *Area) SetMonitoring(enable bool) {
	log.Println("Calling Area.SetMonitoring()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_monitoring", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether this area detects bodies/areas entering/exiting it.
*/
func (o *Area) IsMonitoring() bool {
	log.Println("Calling Area.IsMonitoring()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_monitoring", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns a list of intersecting [PhysicsBody]\ s.
*/
func (o *Area) GetOverlappingBodies() *Array {
	log.Println("Calling Area.GetOverlappingBodies()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_overlapping_bodies", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Returns a list of intersecting [Area]\ s.
*/
func (o *Area) GetOverlappingAreas() *Array {
	log.Println("Calling Area.GetOverlappingAreas()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_overlapping_areas", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   If [code]true[/code] the given body overlaps the Area.
*/
func (o *Area) OverlapsBody(body *Object) bool {
	log.Println("Calling Area.OverlapsBody()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "overlaps_body", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   If [code]true[/code] the given area overlaps the Area.
*/
func (o *Area) OverlapsArea(area *Object) bool {
	log.Println("Calling Area.OverlapsArea()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "overlaps_area", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area) X_BodyInout(arg0 int64, arg1 *RID, arg2 int64, arg3 int64, arg4 int64) {
	log.Println("Calling Area.X_BodyInout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(arg0)
	goArguments[1] = reflect.ValueOf(arg1)
	goArguments[2] = reflect.ValueOf(arg2)
	goArguments[3] = reflect.ValueOf(arg3)
	goArguments[4] = reflect.ValueOf(arg4)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_body_inout", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Area) X_AreaInout(arg0 int64, arg1 *RID, arg2 int64, arg3 int64, arg4 int64) {
	log.Println("Calling Area.X_AreaInout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(arg0)
	goArguments[1] = reflect.ValueOf(arg1)
	goArguments[2] = reflect.ValueOf(arg2)
	goArguments[3] = reflect.ValueOf(arg3)
	goArguments[4] = reflect.ValueOf(arg4)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_area_inout", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Area) SetAudioBusOverride(enable bool) {
	log.Println("Calling Area.SetAudioBusOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_audio_bus_override", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Area) IsOverridingAudioBus() bool {
	log.Println("Calling Area.IsOverridingAudioBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_overriding_audio_bus", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Area) SetAudioBus(name string) {
	log.Println("Calling Area.SetAudioBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_audio_bus", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Area) GetAudioBus() string {
	log.Println("Calling Area.GetAudioBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_audio_bus", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *Area) SetUseReverbBus(enable bool) {
	log.Println("Calling Area.SetUseReverbBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_reverb_bus", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Area) IsUsingReverbBus() bool {
	log.Println("Calling Area.IsUsingReverbBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_using_reverb_bus", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Area) SetReverbBus(name string) {
	log.Println("Calling Area.SetReverbBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_reverb_bus", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Area) GetReverbBus() string {
	log.Println("Calling Area.GetReverbBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_reverb_bus", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *Area) SetReverbAmount(amount float64) {
	log.Println("Calling Area.SetReverbAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_reverb_amount", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Area) GetReverbAmount() float64 {
	log.Println("Calling Area.GetReverbAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_reverb_amount", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Area) SetReverbUniformity(amount float64) {
	log.Println("Calling Area.SetReverbUniformity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_reverb_uniformity", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Area) GetReverbUniformity() float64 {
	log.Println("Calling Area.GetReverbUniformity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_reverb_uniformity", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   AreaImplementer is an interface for Area objects.
*/
type AreaImplementer interface {
	Class
}

/*
   General purpose proximity-detection node.
*/
type ProximityGroup struct {
	Spatial
}

func (o *ProximityGroup) baseClass() string {
	return "ProximityGroup"
}

/*

 */
func (o *ProximityGroup) SetGroupName(name string) {
	log.Println("Calling ProximityGroup.SetGroupName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_group_name", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProximityGroup) Broadcast(name string, parameters *Variant) {
	log.Println("Calling ProximityGroup.Broadcast()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(parameters)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "broadcast", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProximityGroup) SetDispatchMode(mode int64) {
	log.Println("Calling ProximityGroup.SetDispatchMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dispatch_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ProximityGroup) X_ProximityGroupBroadcast(name string, params *Variant) {
	log.Println("Calling ProximityGroup.X_ProximityGroupBroadcast()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(params)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_proximity_group_broadcast", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProximityGroup) SetGridRadius(radius *Vector3) {
	log.Println("Calling ProximityGroup.SetGridRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_grid_radius", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProximityGroup) GetGridRadius() *Vector3 {
	log.Println("Calling ProximityGroup.GetGridRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_grid_radius", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   ProximityGroupImplementer is an interface for ProximityGroup objects.
*/
type ProximityGroupImplementer interface {
	Class
}

/*
   Editor facility for creating and editing collision shapes in 3D space. You can use this node to represent all sorts of collision shapes, for example, add this to an [Area] to give it a detection shape, or add it to a [PhysicsBody] to give create solid object. [b]IMPORTANT[/b]: this is an Editor-only helper to create shapes, use [method get_shape] to get the actual shape.
*/
type CollisionShape struct {
	Spatial
}

func (o *CollisionShape) baseClass() string {
	return "CollisionShape"
}

/*
   If this method exists within a script it will be called whenever the shape resource has been modified.
*/
func (o *CollisionShape) ResourceChanged(resource *Resource) {
	log.Println("Calling CollisionShape.ResourceChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(resource)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "resource_changed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionShape) SetShape(shape *Shape) {
	log.Println("Calling CollisionShape.SetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionShape) GetShape() *Shape {
	log.Println("Calling CollisionShape.GetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shape", goArguments, "*Shape")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Shape)

	return returnValue

}

/*

 */
func (o *CollisionShape) SetDisabled(enable bool) {
	log.Println("Calling CollisionShape.SetDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionShape) IsDisabled() bool {
	log.Println("Calling CollisionShape.IsDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_disabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Sets the collision shape's shape to the addition of all its convexed [MeshInstance] siblings geometry.
*/
func (o *CollisionShape) MakeConvexFromBrothers() {
	log.Println("Calling CollisionShape.MakeConvexFromBrothers()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "make_convex_from_brothers", goArguments, "")

	log.Println("Got return value!")

}

/*
   CollisionShapeImplementer is an interface for CollisionShape objects.
*/
type CollisionShapeImplementer interface {
	Class
}

/*
   Base class for all 3D shape resources. All 3D shapes that inherit from this can be set into a [PhysicsBody] or [Area].
*/
type Shape struct {
	Resource
}

func (o *Shape) baseClass() string {
	return "Shape"
}

/*
   ShapeImplementer is an interface for Shape objects.
*/
type ShapeImplementer interface {
	Class
}

/*
   Allows editing a collision polygon's vertices on a selected plane. Can also set a depth perpendicular to that plane. This class is only available in the editor. It will not appear in the scene tree at runtime. Creates a [Shape] for gameplay. Properties modified during gameplay will have no effect.
*/
type CollisionPolygon struct {
	Spatial
}

func (o *CollisionPolygon) baseClass() string {
	return "CollisionPolygon"
}

/*

 */
func (o *CollisionPolygon) SetDepth(depth float64) {
	log.Println("Calling CollisionPolygon.SetDepth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(depth)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_depth", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionPolygon) GetDepth() float64 {
	log.Println("Calling CollisionPolygon.GetDepth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_depth", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *CollisionPolygon) SetPolygon(polygon *PoolVector2Array) {
	log.Println("Calling CollisionPolygon.SetPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(polygon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_polygon", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionPolygon) GetPolygon() *PoolVector2Array {
	log.Println("Calling CollisionPolygon.GetPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_polygon", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*

 */
func (o *CollisionPolygon) SetDisabled(disabled bool) {
	log.Println("Calling CollisionPolygon.SetDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(disabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionPolygon) IsDisabled() bool {
	log.Println("Calling CollisionPolygon.IsDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_disabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   CollisionPolygonImplementer is an interface for CollisionPolygon objects.
*/
type CollisionPolygonImplementer interface {
	Class
}

/*
   A RayCast represents a line from its origin to its destination position, [code]cast_to[/code]. It is used to query the 3D space in order to find the closest object along the path of the ray. RayCast can ignore some objects by adding them to the exception list via [code]add_exception[/code], by setting proper filtering with collision layers, or by filtering object types with type masks. Only enabled raycasts will be able to query the space and report collisions. RayCast calculates intersection every fixed frame (see [Node]), and the result is cached so it can be used later until the next frame. If multiple queries are required between fixed frames (or during the same frame) use [method force_raycast_update] after adjusting the raycast.
*/
type RayCast struct {
	Spatial
}

func (o *RayCast) baseClass() string {
	return "RayCast"
}

/*
   Enables the RayCast2D. Only enabled raycasts will be able to query the space and report collisions.
*/
func (o *RayCast) SetEnabled(enabled bool) {
	log.Println("Calling RayCast.SetEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether the ray is enabled or not.
*/
func (o *RayCast) IsEnabled() bool {
	log.Println("Calling RayCast.IsEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Sets the ray destination point, so that the ray will test from the ray's origin to [code]local_point[/code].
*/
func (o *RayCast) SetCastTo(localPoint *Vector3) {
	log.Println("Calling RayCast.SetCastTo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(localPoint)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cast_to", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the destination point of this ray object.
*/
func (o *RayCast) GetCastTo() *Vector3 {
	log.Println("Calling RayCast.GetCastTo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cast_to", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Return whether the closest object the ray is pointing to is colliding with the vector (considering the vector length).
*/
func (o *RayCast) IsColliding() bool {
	log.Println("Calling RayCast.IsColliding()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_colliding", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Updates the collision information for the ray. Use this method to update the collision information immediately instead of waiting for the next [code]_fixed_process[/code] call, for example if the ray or its parent has changed state. Note: [code]enabled == true[/code] is not required for this to work.
*/
func (o *RayCast) ForceRaycastUpdate() {
	log.Println("Calling RayCast.ForceRaycastUpdate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "force_raycast_update", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the closest object the ray is pointing to. Note that this does not consider the length of the ray, so you must also use [method is_colliding] to check if the object returned is actually colliding with the ray. Example: [codeblock] if RayCast.is_colliding(): var collider = RayCast.get_collider() [/codeblock]
*/
func (o *RayCast) GetCollider() *Object {
	log.Println("Calling RayCast.GetCollider()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*
   Returns the collision shape of the closest object the ray is pointing to. Note that this does not consider the length of the ray, so you must also use [method is_colliding] to check if the object returned is actually colliding with the ray. Example: [codeblock] if RayCast.is_colliding(): var shape = RayCast.get_collider_shape() [/codeblock]
*/
func (o *RayCast) GetColliderShape() int64 {
	log.Println("Calling RayCast.GetColliderShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider_shape", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the collision point at which the ray intersects the closest object. Note: this point is in the [b]global[/b] coordinate system.
*/
func (o *RayCast) GetCollisionPoint() *Vector3 {
	log.Println("Calling RayCast.GetCollisionPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_point", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Returns the normal of the intersecting object's shape at the collision point.
*/
func (o *RayCast) GetCollisionNormal() *Vector3 {
	log.Println("Calling RayCast.GetCollisionNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_normal", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Adds a collision exception so the ray does not report collisions with the specified [RID].
*/
func (o *RayCast) AddExceptionRid(rid *RID) {
	log.Println("Calling RayCast.AddExceptionRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rid)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_exception_rid", goArguments, "")

	log.Println("Got return value!")

}

/*
   Adds a collision exception so the ray does not report collisions with the specified node.
*/
func (o *RayCast) AddException(node *Object) {
	log.Println("Calling RayCast.AddException()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_exception", goArguments, "")

	log.Println("Got return value!")

}

/*
   Removes a collision exception so the ray does report collisions with the specified [RID].
*/
func (o *RayCast) RemoveExceptionRid(rid *RID) {
	log.Println("Calling RayCast.RemoveExceptionRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rid)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_exception_rid", goArguments, "")

	log.Println("Got return value!")

}

/*
   Removes a collision exception so the ray does report collisions with the specified node.
*/
func (o *RayCast) RemoveException(node *Object) {
	log.Println("Calling RayCast.RemoveException()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_exception", goArguments, "")

	log.Println("Got return value!")

}

/*
   Removes all collision exceptions for this ray.
*/
func (o *RayCast) ClearExceptions() {
	log.Println("Calling RayCast.ClearExceptions()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_exceptions", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the mask to filter objects. Only objects with at least the same mask element set will be detected.
*/
func (o *RayCast) SetCollisionLayer(layer int64) {
	log.Println("Calling RayCast.SetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the collision layer for this ray.
*/
func (o *RayCast) GetCollisionLayer() int64 {
	log.Println("Calling RayCast.GetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the types of objects to detect. For [code]mask[/code] use a logic sum (OR operation) of constants defined in [PhysicsDirectSpaceState], eg. [code]PhysicsDirectSpaceState.TYPE_MASK_STATIC_BODY | PhysicsDirectSpaceState.TYPE_MASK_KINEMATIC_BODY[/code] to detect only those two types.
*/
func (o *RayCast) SetTypeMask(mask int64) {
	log.Println("Calling RayCast.SetTypeMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_type_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the type mask (types of objects to detect) for this ray. The value is a sum (bitwise OR'd) of constants available for [PhysicsDirectSpaceState].
*/
func (o *RayCast) GetTypeMask() int64 {
	log.Println("Calling RayCast.GetTypeMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_type_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   RayCastImplementer is an interface for RayCast objects.
*/
type RayCastImplementer interface {
	Class
}

/*
   MultiMeshInstance is a [Node] that takes a [MultiMesh] resource and adds it to the current scenario by creating an instance of it (yes, this is an instance of instances).
*/
type MultiMeshInstance struct {
	GeometryInstance
}

func (o *MultiMeshInstance) baseClass() string {
	return "MultiMeshInstance"
}

/*
   Set the [MultiMesh] to be instanced.
*/
func (o *MultiMeshInstance) SetMultimesh(multimesh *MultiMesh) {
	log.Println("Calling MultiMeshInstance.SetMultimesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(multimesh)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_multimesh", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the [MultiMesh] that is used for instancing.
*/
func (o *MultiMeshInstance) GetMultimesh() *MultiMesh {
	log.Println("Calling MultiMeshInstance.GetMultimesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_multimesh", goArguments, "*MultiMesh")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*MultiMesh)

	return returnValue

}

/*
   MultiMeshInstanceImplementer is an interface for MultiMeshInstance objects.
*/
type MultiMeshInstanceImplementer interface {
	Class
}

/*
   MultiMesh provides low level mesh instancing. If the amount of [Mesh] instances needed goes from hundreds to thousands (and most need to be visible at close proximity) creating such a large amount of [MeshInstance] nodes may affect performance by using too much CPU or video memory. For this case a MultiMesh becomes very useful, as it can draw thousands of instances with little API overhead. As a drawback, if the instances are too far away of each other, performance may be reduced as every single instance will always rendered (they are spatially indexed as one, for the whole object). Since instances may have any behavior, the Rect3 used for visibility must be provided by the user.
*/
type MultiMesh struct {
	Resource
}

func (o *MultiMesh) baseClass() string {
	return "MultiMesh"
}

/*
   Set the [Mesh] resource to be drawn in multiple instances.
*/
func (o *MultiMesh) SetMesh(mesh *Mesh) {
	log.Println("Calling MultiMesh.SetMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mesh)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mesh", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the [Mesh] resource drawn as multiple instances.
*/
func (o *MultiMesh) GetMesh() *Mesh {
	log.Println("Calling MultiMesh.GetMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mesh", goArguments, "*Mesh")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Mesh)

	return returnValue

}

/*

 */
func (o *MultiMesh) SetColorFormat(format int64) {
	log.Println("Calling MultiMesh.SetColorFormat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(format)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_color_format", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MultiMesh) GetColorFormat() int64 {
	log.Println("Calling MultiMesh.GetColorFormat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_color_format", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *MultiMesh) SetTransformFormat(format int64) {
	log.Println("Calling MultiMesh.SetTransformFormat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(format)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_transform_format", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MultiMesh) GetTransformFormat() int64 {
	log.Println("Calling MultiMesh.GetTransformFormat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_transform_format", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the amount of instances that is going to be drawn. Changing this number will erase all the existing instance transform and color data.
*/
func (o *MultiMesh) SetInstanceCount(count int64) {
	log.Println("Calling MultiMesh.SetInstanceCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(count)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_instance_count", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the amount of instances that is going to be drawn.
*/
func (o *MultiMesh) GetInstanceCount() int64 {
	log.Println("Calling MultiMesh.GetInstanceCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_instance_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the transform for a specific instance.
*/
func (o *MultiMesh) SetInstanceTransform(instance int64, transform *Transform) {
	log.Println("Calling MultiMesh.SetInstanceTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(instance)
	goArguments[1] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_instance_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the transform of a specific instance.
*/
func (o *MultiMesh) GetInstanceTransform(instance int64) *Transform {
	log.Println("Calling MultiMesh.GetInstanceTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(instance)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_instance_transform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*
   Set the color of a specific instance.
*/
func (o *MultiMesh) SetInstanceColor(instance int64, color *Color) {
	log.Println("Calling MultiMesh.SetInstanceColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(instance)
	goArguments[1] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_instance_color", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the color of a specific instance.
*/
func (o *MultiMesh) GetInstanceColor(instance int64) *Color {
	log.Println("Calling MultiMesh.GetInstanceColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(instance)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_instance_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Return the visibility Rect3.
*/
func (o *MultiMesh) GetAabb() *Rect3 {
	log.Println("Calling MultiMesh.GetAabb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_aabb", goArguments, "*Rect3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect3)

	return returnValue

}

/*
   Undocumented
*/
func (o *MultiMesh) X_SetTransformArray(arg0 *PoolVector3Array) {
	log.Println("Calling MultiMesh.X_SetTransformArray()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_transform_array", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *MultiMesh) X_GetTransformArray() *PoolVector3Array {
	log.Println("Calling MultiMesh.X_GetTransformArray()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_transform_array", goArguments, "*PoolVector3Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector3Array)

	return returnValue

}

/*
   Undocumented
*/
func (o *MultiMesh) X_SetColorArray(arg0 *PoolColorArray) {
	log.Println("Calling MultiMesh.X_SetColorArray()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_color_array", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *MultiMesh) X_GetColorArray() *PoolColorArray {
	log.Println("Calling MultiMesh.X_GetColorArray()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_color_array", goArguments, "*PoolColorArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolColorArray)

	return returnValue

}

/*
   MultiMeshImplementer is an interface for MultiMesh objects.
*/
type MultiMeshImplementer interface {
	Class
}

/*
   This class describes a Bezier curve in 3D space. It is mainly used to give a shape to a [Path], but can be manually sampled for other purposes. It keeps a cache of precalculated points along the curve, to speed further calculations up.
*/
type Curve3D struct {
	Resource
}

func (o *Curve3D) baseClass() string {
	return "Curve3D"
}

/*
   Returns the number of points describing the curve.
*/
func (o *Curve3D) GetPointCount() int64 {
	log.Println("Calling Curve3D.GetPointCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Adds a point to a curve, at "position", with control points "in" and "out". If "at_position" is given, the point is inserted before the point number "at_position", moving that point (and every point after) after the inserted point. If "at_position" is not given, or is an illegal value (at_position <0 or at_position >= [method get_point_count]), the point will be appended at the end of the point list.
*/
func (o *Curve3D) AddPoint(position *Vector3, in *Vector3, out *Vector3, atPosition int64) {
	log.Println("Calling Curve3D.AddPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(position)
	goArguments[1] = reflect.ValueOf(in)
	goArguments[2] = reflect.ValueOf(out)
	goArguments[3] = reflect.ValueOf(atPosition)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_point", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the position for the vertex "idx". If the index is out of bounds, the function sends an error to the console.
*/
func (o *Curve3D) SetPointPosition(idx int64, position *Vector3) {
	log.Println("Calling Curve3D.SetPointPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_position", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the position of the vertex "idx". If the index is out of bounds, the function sends an error to the console, and returns (0, 0, 0).
*/
func (o *Curve3D) GetPointPosition(idx int64) *Vector3 {
	log.Println("Calling Curve3D.GetPointPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_position", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Sets the tilt angle in radians for the point "idx". If the index is out of bounds, the function sends an error to the console. The tilt controls the rotation along the look-at axis an object traveling the path would have. In the case of a curve controlling a [PathFollow], this tilt is an offset over the natural tilt the PathFollow calculates.
*/
func (o *Curve3D) SetPointTilt(idx int64, tilt float64) {
	log.Println("Calling Curve3D.SetPointTilt()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(tilt)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_tilt", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the tilt angle in radians for the point "idx". If the index is out of bounds, the function sends an error to the console, and returns 0.
*/
func (o *Curve3D) GetPointTilt(idx int64) float64 {
	log.Println("Calling Curve3D.GetPointTilt()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_tilt", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Sets the position of the control point leading to the vertex "idx". If the index is out of bounds, the function sends an error to the console.
*/
func (o *Curve3D) SetPointIn(idx int64, position *Vector3) {
	log.Println("Calling Curve3D.SetPointIn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_in", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the position of the control point leading to the vertex "idx". If the index is out of bounds, the function sends an error to the console, and returns (0, 0, 0).
*/
func (o *Curve3D) GetPointIn(idx int64) *Vector3 {
	log.Println("Calling Curve3D.GetPointIn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_in", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Sets the position of the control point leading out of the vertex "idx". If the index is out of bounds, the function sends an error to the console.
*/
func (o *Curve3D) SetPointOut(idx int64, position *Vector3) {
	log.Println("Calling Curve3D.SetPointOut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_out", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the position of the control point leading out of the vertex "idx". If the index is out of bounds, the function sends an error to the console, and returns (0, 0, 0).
*/
func (o *Curve3D) GetPointOut(idx int64) *Vector3 {
	log.Println("Calling Curve3D.GetPointOut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_out", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Deletes the point "idx" from the curve. Sends an error to the console if "idx" is out of bounds.
*/
func (o *Curve3D) RemovePoint(idx int64) {
	log.Println("Calling Curve3D.RemovePoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_point", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve3D) ClearPoints() {
	log.Println("Calling Curve3D.ClearPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_points", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the position between the vertex "idx" and the vertex "idx"+1, where "t" controls if the point is the first vertex (t = 0.0), the last vertex (t = 1.0), or in between. Values of "t" outside the range (0.0 >= t <=1) give strange, but predictable results. If "idx" is out of bounds it is truncated to the first or last vertex, and "t" is ignored. If the curve has no points, the function sends an error to the console, and returns (0, 0, 0).
*/
func (o *Curve3D) Interpolate(idx int64, t float64) *Vector3 {
	log.Println("Calling Curve3D.Interpolate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(t)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "interpolate", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Returns the position at the vertex "fofs". It calls [method interpolate] using the integer part of fofs as "idx", and its fractional part as "t".
*/
func (o *Curve3D) Interpolatef(fofs float64) *Vector3 {
	log.Println("Calling Curve3D.Interpolatef()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fofs)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "interpolatef", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Sets the distance in 3D units between two adjacent cached points. Changing it forces the cache to be recomputed the next time a xxx_baked_xxx function is called. The less distance, the more points the cache will have, and the more memory it will consume, so use with care.
*/
func (o *Curve3D) SetBakeInterval(distance float64) {
	log.Println("Calling Curve3D.SetBakeInterval()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(distance)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bake_interval", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the distance between two adjacent cached points.
*/
func (o *Curve3D) GetBakeInterval() float64 {
	log.Println("Calling Curve3D.GetBakeInterval()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bake_interval", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns the total length of the curve, based on the cached points. Given enough density (see [method set_bake_interval]), it should be approximate enough.
*/
func (o *Curve3D) GetBakedLength() float64 {
	log.Println("Calling Curve3D.GetBakedLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_baked_length", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns a point within the curve at position "offset", where "offset" is measured as a distance in 3D units along the curve. To do that, it finds the two cached points where the "offset" lies between, then interpolates the values. This interpolation is cubic if "cubic" is set to true, or linear if set to false. Cubic interpolation tends to follow the curves better, but linear is faster (and often, precise enough).
*/
func (o *Curve3D) InterpolateBaked(offset float64, cubic bool) *Vector3 {
	log.Println("Calling Curve3D.InterpolateBaked()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(offset)
	goArguments[1] = reflect.ValueOf(cubic)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "interpolate_baked", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Returns the cache of points as a [PoolVector3Array].
*/
func (o *Curve3D) GetBakedPoints() *PoolVector3Array {
	log.Println("Calling Curve3D.GetBakedPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_baked_points", goArguments, "*PoolVector3Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector3Array)

	return returnValue

}

/*
   Returns the cache of tilts as a [RealArray].
*/
func (o *Curve3D) GetBakedTilts() *PoolRealArray {
	log.Println("Calling Curve3D.GetBakedTilts()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_baked_tilts", goArguments, "*PoolRealArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolRealArray)

	return returnValue

}

/*
   Returns a list of points along the curve, with a curvature controlled point density. That is, the curvier parts will have more points than the straighter parts. This approximation makes straight segments between each point, then subdivides those segments until the resulting shape is similar enough. "max_stages" controls how many subdivisions a curve segment may face before it is considered approximate enough. Each subdivision splits the segment in half, so the default 5 stages may mean up to 32 subdivisions per curve segment. Increase with care! "tolerance_degrees" controls how many degrees the midpoint of a segment may deviate from the real curve, before the segment has to be subdivided.
*/
func (o *Curve3D) Tessellate(maxStages int64, toleranceDegrees float64) *PoolVector3Array {
	log.Println("Calling Curve3D.Tessellate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(maxStages)
	goArguments[1] = reflect.ValueOf(toleranceDegrees)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tessellate", goArguments, "*PoolVector3Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector3Array)

	return returnValue

}

/*
   Undocumented
*/
func (o *Curve3D) X_GetData() *Dictionary {
	log.Println("Calling Curve3D.X_GetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_data", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
   Undocumented
*/
func (o *Curve3D) X_SetData(arg0 *Dictionary) {
	log.Println("Calling Curve3D.X_SetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_data", goArguments, "")

	log.Println("Got return value!")

}

/*
   Curve3DImplementer is an interface for Curve3D objects.
*/
type Curve3DImplementer interface {
	Class
}

/*
   This class is a container/Node-ification of a [Curve3D], so it can have [Spatial] properties and [Node] info.
*/
type Path struct {
	Spatial
}

func (o *Path) baseClass() string {
	return "Path"
}

/*
   Sets the [Curve3D].
*/
func (o *Path) SetCurve(curve *Curve3D) {
	log.Println("Calling Path.SetCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(curve)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_curve", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the [Curve3D] contained.
*/
func (o *Path) GetCurve() *Curve3D {
	log.Println("Calling Path.GetCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_curve", goArguments, "*Curve3D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Curve3D)

	return returnValue

}

/*
   Undocumented
*/
func (o *Path) X_CurveChanged() {
	log.Println("Calling Path.X_CurveChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_curve_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   PathImplementer is an interface for Path objects.
*/
type PathImplementer interface {
	Class
}

/*
   This node takes its parent [Path], and returns the coordinates of a point within it, given a distance from the first vertex. It is useful for making other nodes follow a path, without coding the movement pattern. For that, the nodes must be descendants of this node. Then, when setting an offset in this node, the descendant nodes will move accordingly.
*/
type PathFollow struct {
	Spatial
}

func (o *PathFollow) baseClass() string {
	return "PathFollow"
}

/*
   Sets the distance from the first vertex, measured in 3D units along the path. This sets this node's position to a point within the path.
*/
func (o *PathFollow) SetOffset(offset float64) {
	log.Println("Calling PathFollow.SetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the distance along the path in 3D units.
*/
func (o *PathFollow) GetOffset() float64 {
	log.Println("Calling PathFollow.GetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Moves this node in the X axis. As this node's position will be set every time its offset is set, this allows many PathFollow to share the same curve (and thus the same movement pattern), yet not return the same position for a given path offset. A similar effect may be achieved moving the this node's descendants.
*/
func (o *PathFollow) SetHOffset(hOffset float64) {
	log.Println("Calling PathFollow.SetHOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(hOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_h_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the X displacement this node has from its parent [Path].
*/
func (o *PathFollow) GetHOffset() float64 {
	log.Println("Calling PathFollow.GetHOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_h_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Moves this node in the Y axis, for the same reasons of [method set_h_offset].
*/
func (o *PathFollow) SetVOffset(vOffset float64) {
	log.Println("Calling PathFollow.SetVOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_v_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the Y displacement this node has from its parent [Path].
*/
func (o *PathFollow) GetVOffset() float64 {
	log.Println("Calling PathFollow.GetVOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_v_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Sets the distance from the first vertex, considering 0.0 as the first vertex and 1.0 as the last. This is just another way of expressing the offset within the path, as the offset supplied is multiplied internally by the path's length.
*/
func (o *PathFollow) SetUnitOffset(unitOffset float64) {
	log.Println("Calling PathFollow.SetUnitOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(unitOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_unit_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the distance along the path as a number in the range 0.0 (for the first vertex) to 1.0 (for the last).
*/
func (o *PathFollow) GetUnitOffset() float64 {
	log.Println("Calling PathFollow.GetUnitOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_unit_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Allows or forbids rotation on one or more axes, per the constants below.
*/
func (o *PathFollow) SetRotationMode(rotationMode int64) {
	log.Println("Calling PathFollow.SetRotationMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rotationMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rotation_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the rotation mode. The constants below list which axes are allowed to rotate for each mode.
*/
func (o *PathFollow) GetRotationMode() int64 {
	log.Println("Calling PathFollow.GetRotationMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rotation_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   The points along the [Curve3D] of the [Path] are precomputed before use, for faster calculations. The point at the requested offset is then calculated interpolating between two adjacent cached points. This may present a problem if the curve makes sharp turns, as the cached points may not follow the curve closely enough. There are two answers to this problem: Either increase the number of cached points and increase memory consumption, or make a cubic interpolation between two points at the cost of (slightly) slower calculations. This method controls whether the position between two cached points is interpolated linearly, or cubicly.
*/
func (o *PathFollow) SetCubicInterpolation(enable bool) {
	log.Println("Calling PathFollow.SetCubicInterpolation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cubic_interpolation", goArguments, "")

	log.Println("Got return value!")

}

/*
   This method returns whether the position between two cached points (see [method set_cubic_interpolation]) is interpolated linearly, or cubicly.
*/
func (o *PathFollow) GetCubicInterpolation() bool {
	log.Println("Calling PathFollow.GetCubicInterpolation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cubic_interpolation", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   If set, any offset outside the path's length (whether set by [method set_offset] or [method set_unit_offset] will wrap around, instead of stopping at the ends. Set it for cyclic paths.
*/
func (o *PathFollow) SetLoop(loop bool) {
	log.Println("Calling PathFollow.SetLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(loop)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_loop", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether this node wraps its offsets around, or truncates them to the path ends.
*/
func (o *PathFollow) HasLoop() bool {
	log.Println("Calling PathFollow.HasLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_loop", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   PathFollowImplementer is an interface for PathFollow objects.
*/
type PathFollowImplementer interface {
	Class
}

/*
   The VisibilityNotifier detects when it is visible on the screen. It also notifies when its bounding rectangle enters or exits the screen or a [Camera]'s view.
*/
type VisibilityNotifier struct {
	Spatial
}

func (o *VisibilityNotifier) baseClass() string {
	return "VisibilityNotifier"
}

/*
   Set the visibility bounding box of the VisibilityNotifier.
*/
func (o *VisibilityNotifier) SetAabb(rect *Rect3) {
	log.Println("Calling VisibilityNotifier.SetAabb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rect)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_aabb", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the bounding box of the VisibilityNotifier.
*/
func (o *VisibilityNotifier) GetAabb() *Rect3 {
	log.Println("Calling VisibilityNotifier.GetAabb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_aabb", goArguments, "*Rect3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect3)

	return returnValue

}

/*
   If [code]true[/code] the bounding box is on the screen.
*/
func (o *VisibilityNotifier) IsOnScreen() bool {
	log.Println("Calling VisibilityNotifier.IsOnScreen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_on_screen", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   VisibilityNotifierImplementer is an interface for VisibilityNotifier objects.
*/
type VisibilityNotifierImplementer interface {
	Class
}

/*
   The VisibilityEnabler will disable [RigidBody] and [AnimationPlayer] nodes when they are not visible. It will only affect other nodes within the same scene as the VisibilityEnabler itself.
*/
type VisibilityEnabler struct {
	VisibilityNotifier
}

func (o *VisibilityEnabler) baseClass() string {
	return "VisibilityEnabler"
}

/*
   Set an enabler to true for all nodes of its type to be disabled when the VisibilityEnabler is not in view. See the constants for enablers and what they affect.
*/
func (o *VisibilityEnabler) SetEnabler(enabler int64, enabled bool) {
	log.Println("Calling VisibilityEnabler.SetEnabler()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(enabler)
	goArguments[1] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enabler", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether the specified enabler was set to true or not.
*/
func (o *VisibilityEnabler) IsEnablerEnabled(enabler int64) bool {
	log.Println("Calling VisibilityEnabler.IsEnablerEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabler)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_enabler_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisibilityEnabler) X_NodeRemoved(arg0 *Object) {
	log.Println("Calling VisibilityEnabler.X_NodeRemoved()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_node_removed", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisibilityEnablerImplementer is an interface for VisibilityEnabler objects.
*/
type VisibilityEnablerImplementer interface {
	Class
}

/*
   The [WorldEnvironment] node can be added to a scene in order to set default [Environment] variables for the scene. The [WorldEnvironment] can be overridden by an [Environment] node set on the current [Camera]. Additionally, only one [WorldEnvironment] may be instanced in a given scene at a time. The [WorldEnvironment] allows the user to specify default lighting parameters (e.g. ambient lighting), various post-processing effects (e.g. SSAO, DOF, Tonemapping), and how to draw the background (e.g. solid color, skybox).
*/
type WorldEnvironment struct {
	Node
}

func (o *WorldEnvironment) baseClass() string {
	return "WorldEnvironment"
}

/*
   Set the currently bound [Environment] to the one specified.
*/
func (o *WorldEnvironment) SetEnvironment(env *Environment) {
	log.Println("Calling WorldEnvironment.SetEnvironment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(env)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_environment", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the [Environment] currently bound.
*/
func (o *WorldEnvironment) GetEnvironment() *Environment {
	log.Println("Calling WorldEnvironment.GetEnvironment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_environment", goArguments, "*Environment")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Environment)

	return returnValue

}

/*
   WorldEnvironmentImplementer is an interface for WorldEnvironment objects.
*/
type WorldEnvironmentImplementer interface {
	Class
}

/*
   Resource for environment nodes (like [WorldEnvironment]) that define multiple environment operations (such as background [Sky] or [Color], ambient light, fog, depth-of-field...).	These parameters affect the final render of the scene. The order of these operations is: - DOF Blur - Motion Blur - Bloom - Tonemap (auto exposure) - Adjustments
*/
type Environment struct {
	Resource
}

func (o *Environment) baseClass() string {
	return "Environment"
}

/*

 */
func (o *Environment) SetBackground(mode int64) {
	log.Println("Calling Environment.SetBackground()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_background", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetSky(sky *Sky) {
	log.Println("Calling Environment.SetSky()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sky)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sky", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetSkyScale(scale float64) {
	log.Println("Calling Environment.SetSkyScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sky_scale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetBgColor(color *Color) {
	log.Println("Calling Environment.SetBgColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bg_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetBgEnergy(energy float64) {
	log.Println("Calling Environment.SetBgEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(energy)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bg_energy", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetCanvasMaxLayer(layer int64) {
	log.Println("Calling Environment.SetCanvasMaxLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_canvas_max_layer", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetAmbientLightColor(color *Color) {
	log.Println("Calling Environment.SetAmbientLightColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ambient_light_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetAmbientLightEnergy(energy float64) {
	log.Println("Calling Environment.SetAmbientLightEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(energy)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ambient_light_energy", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetAmbientLightSkyContribution(energy float64) {
	log.Println("Calling Environment.SetAmbientLightSkyContribution()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(energy)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ambient_light_sky_contribution", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetBackground() int64 {
	log.Println("Calling Environment.GetBackground()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_background", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Environment) GetSky() *Sky {
	log.Println("Calling Environment.GetSky()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sky", goArguments, "*Sky")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Sky)

	return returnValue

}

/*

 */
func (o *Environment) GetSkyScale() float64 {
	log.Println("Calling Environment.GetSkyScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sky_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetBgColor() *Color {
	log.Println("Calling Environment.GetBgColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bg_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *Environment) GetBgEnergy() float64 {
	log.Println("Calling Environment.GetBgEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bg_energy", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetCanvasMaxLayer() int64 {
	log.Println("Calling Environment.GetCanvasMaxLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_canvas_max_layer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Environment) GetAmbientLightColor() *Color {
	log.Println("Calling Environment.GetAmbientLightColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ambient_light_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *Environment) GetAmbientLightEnergy() float64 {
	log.Println("Calling Environment.GetAmbientLightEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ambient_light_energy", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetAmbientLightSkyContribution() float64 {
	log.Println("Calling Environment.GetAmbientLightSkyContribution()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ambient_light_sky_contribution", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetFogEnabled(enabled bool) {
	log.Println("Calling Environment.SetFogEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fog_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) IsFogEnabled() bool {
	log.Println("Calling Environment.IsFogEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_fog_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Environment) SetFogColor(color *Color) {
	log.Println("Calling Environment.SetFogColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fog_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetFogColor() *Color {
	log.Println("Calling Environment.GetFogColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fog_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *Environment) SetFogSunColor(color *Color) {
	log.Println("Calling Environment.SetFogSunColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fog_sun_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetFogSunColor() *Color {
	log.Println("Calling Environment.GetFogSunColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fog_sun_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *Environment) SetFogSunAmount(amount float64) {
	log.Println("Calling Environment.SetFogSunAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fog_sun_amount", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetFogSunAmount() float64 {
	log.Println("Calling Environment.GetFogSunAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fog_sun_amount", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetFogDepthEnabled(enabled bool) {
	log.Println("Calling Environment.SetFogDepthEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fog_depth_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) IsFogDepthEnabled() bool {
	log.Println("Calling Environment.IsFogDepthEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_fog_depth_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Environment) SetFogDepthBegin(distance float64) {
	log.Println("Calling Environment.SetFogDepthBegin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(distance)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fog_depth_begin", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetFogDepthBegin() float64 {
	log.Println("Calling Environment.GetFogDepthBegin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fog_depth_begin", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetFogDepthCurve(curve float64) {
	log.Println("Calling Environment.SetFogDepthCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(curve)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fog_depth_curve", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetFogDepthCurve() float64 {
	log.Println("Calling Environment.GetFogDepthCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fog_depth_curve", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetFogTransmitEnabled(enabled bool) {
	log.Println("Calling Environment.SetFogTransmitEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fog_transmit_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) IsFogTransmitEnabled() bool {
	log.Println("Calling Environment.IsFogTransmitEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_fog_transmit_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Environment) SetFogTransmitCurve(curve float64) {
	log.Println("Calling Environment.SetFogTransmitCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(curve)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fog_transmit_curve", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetFogTransmitCurve() float64 {
	log.Println("Calling Environment.GetFogTransmitCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fog_transmit_curve", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetFogHeightEnabled(enabled bool) {
	log.Println("Calling Environment.SetFogHeightEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fog_height_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) IsFogHeightEnabled() bool {
	log.Println("Calling Environment.IsFogHeightEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_fog_height_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Environment) SetFogHeightMin(height float64) {
	log.Println("Calling Environment.SetFogHeightMin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(height)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fog_height_min", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetFogHeightMin() float64 {
	log.Println("Calling Environment.GetFogHeightMin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fog_height_min", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetFogHeightMax(height float64) {
	log.Println("Calling Environment.SetFogHeightMax()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(height)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fog_height_max", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetFogHeightMax() float64 {
	log.Println("Calling Environment.GetFogHeightMax()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fog_height_max", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetFogHeightCurve(curve float64) {
	log.Println("Calling Environment.SetFogHeightCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(curve)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fog_height_curve", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetFogHeightCurve() float64 {
	log.Println("Calling Environment.GetFogHeightCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fog_height_curve", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetTonemapper(mode int64) {
	log.Println("Calling Environment.SetTonemapper()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tonemapper", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetTonemapper() int64 {
	log.Println("Calling Environment.GetTonemapper()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tonemapper", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Environment) SetTonemapExposure(exposure float64) {
	log.Println("Calling Environment.SetTonemapExposure()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(exposure)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tonemap_exposure", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetTonemapExposure() float64 {
	log.Println("Calling Environment.GetTonemapExposure()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tonemap_exposure", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetTonemapWhite(white float64) {
	log.Println("Calling Environment.SetTonemapWhite()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(white)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tonemap_white", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetTonemapWhite() float64 {
	log.Println("Calling Environment.GetTonemapWhite()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tonemap_white", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetTonemapAutoExposure(autoExposure bool) {
	log.Println("Calling Environment.SetTonemapAutoExposure()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(autoExposure)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tonemap_auto_exposure", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetTonemapAutoExposure() bool {
	log.Println("Calling Environment.GetTonemapAutoExposure()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tonemap_auto_exposure", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Environment) SetTonemapAutoExposureMax(exposureMax float64) {
	log.Println("Calling Environment.SetTonemapAutoExposureMax()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(exposureMax)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tonemap_auto_exposure_max", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetTonemapAutoExposureMax() float64 {
	log.Println("Calling Environment.GetTonemapAutoExposureMax()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tonemap_auto_exposure_max", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetTonemapAutoExposureMin(exposureMin float64) {
	log.Println("Calling Environment.SetTonemapAutoExposureMin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(exposureMin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tonemap_auto_exposure_min", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetTonemapAutoExposureMin() float64 {
	log.Println("Calling Environment.GetTonemapAutoExposureMin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tonemap_auto_exposure_min", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetTonemapAutoExposureSpeed(exposureSpeed float64) {
	log.Println("Calling Environment.SetTonemapAutoExposureSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(exposureSpeed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tonemap_auto_exposure_speed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetTonemapAutoExposureSpeed() float64 {
	log.Println("Calling Environment.GetTonemapAutoExposureSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tonemap_auto_exposure_speed", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetTonemapAutoExposureGrey(exposureGrey float64) {
	log.Println("Calling Environment.SetTonemapAutoExposureGrey()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(exposureGrey)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tonemap_auto_exposure_grey", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetTonemapAutoExposureGrey() float64 {
	log.Println("Calling Environment.GetTonemapAutoExposureGrey()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tonemap_auto_exposure_grey", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetSsrEnabled(enabled bool) {
	log.Println("Calling Environment.SetSsrEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssr_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) IsSsrEnabled() bool {
	log.Println("Calling Environment.IsSsrEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_ssr_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Environment) SetSsrMaxSteps(maxSteps int64) {
	log.Println("Calling Environment.SetSsrMaxSteps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(maxSteps)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssr_max_steps", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetSsrMaxSteps() int64 {
	log.Println("Calling Environment.GetSsrMaxSteps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ssr_max_steps", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Environment) SetSsrFadeIn(fadeIn float64) {
	log.Println("Calling Environment.SetSsrFadeIn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fadeIn)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssr_fade_in", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetSsrFadeIn() float64 {
	log.Println("Calling Environment.GetSsrFadeIn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ssr_fade_in", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetSsrFadeOut(fadeOut float64) {
	log.Println("Calling Environment.SetSsrFadeOut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fadeOut)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssr_fade_out", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetSsrFadeOut() float64 {
	log.Println("Calling Environment.GetSsrFadeOut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ssr_fade_out", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetSsrDepthTolerance(depthTolerance float64) {
	log.Println("Calling Environment.SetSsrDepthTolerance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(depthTolerance)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssr_depth_tolerance", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetSsrDepthTolerance() float64 {
	log.Println("Calling Environment.GetSsrDepthTolerance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ssr_depth_tolerance", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetSsrRough(rough bool) {
	log.Println("Calling Environment.SetSsrRough()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rough)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssr_rough", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) IsSsrRough() bool {
	log.Println("Calling Environment.IsSsrRough()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_ssr_rough", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Environment) SetSsaoEnabled(enabled bool) {
	log.Println("Calling Environment.SetSsaoEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssao_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) IsSsaoEnabled() bool {
	log.Println("Calling Environment.IsSsaoEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_ssao_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Environment) SetSsaoRadius(radius float64) {
	log.Println("Calling Environment.SetSsaoRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssao_radius", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetSsaoRadius() float64 {
	log.Println("Calling Environment.GetSsaoRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ssao_radius", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetSsaoIntensity(intensity float64) {
	log.Println("Calling Environment.SetSsaoIntensity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(intensity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssao_intensity", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetSsaoIntensity() float64 {
	log.Println("Calling Environment.GetSsaoIntensity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ssao_intensity", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetSsaoRadius2(radius float64) {
	log.Println("Calling Environment.SetSsaoRadius2()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssao_radius2", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetSsaoRadius2() float64 {
	log.Println("Calling Environment.GetSsaoRadius2()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ssao_radius2", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetSsaoIntensity2(intensity float64) {
	log.Println("Calling Environment.SetSsaoIntensity2()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(intensity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssao_intensity2", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetSsaoIntensity2() float64 {
	log.Println("Calling Environment.GetSsaoIntensity2()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ssao_intensity2", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetSsaoBias(bias float64) {
	log.Println("Calling Environment.SetSsaoBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bias)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssao_bias", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetSsaoBias() float64 {
	log.Println("Calling Environment.GetSsaoBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ssao_bias", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetSsaoDirectLightAffect(amount float64) {
	log.Println("Calling Environment.SetSsaoDirectLightAffect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssao_direct_light_affect", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetSsaoDirectLightAffect() float64 {
	log.Println("Calling Environment.GetSsaoDirectLightAffect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ssao_direct_light_affect", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetSsaoColor(color *Color) {
	log.Println("Calling Environment.SetSsaoColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssao_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetSsaoColor() *Color {
	log.Println("Calling Environment.GetSsaoColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ssao_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *Environment) SetSsaoBlur(enabled bool) {
	log.Println("Calling Environment.SetSsaoBlur()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssao_blur", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) IsSsaoBlurEnabled() bool {
	log.Println("Calling Environment.IsSsaoBlurEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_ssao_blur_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Environment) SetDofBlurFarEnabled(enabled bool) {
	log.Println("Calling Environment.SetDofBlurFarEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dof_blur_far_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) IsDofBlurFarEnabled() bool {
	log.Println("Calling Environment.IsDofBlurFarEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_dof_blur_far_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Environment) SetDofBlurFarDistance(intensity float64) {
	log.Println("Calling Environment.SetDofBlurFarDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(intensity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dof_blur_far_distance", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetDofBlurFarDistance() float64 {
	log.Println("Calling Environment.GetDofBlurFarDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dof_blur_far_distance", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetDofBlurFarTransition(intensity float64) {
	log.Println("Calling Environment.SetDofBlurFarTransition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(intensity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dof_blur_far_transition", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetDofBlurFarTransition() float64 {
	log.Println("Calling Environment.GetDofBlurFarTransition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dof_blur_far_transition", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetDofBlurFarAmount(intensity float64) {
	log.Println("Calling Environment.SetDofBlurFarAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(intensity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dof_blur_far_amount", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetDofBlurFarAmount() float64 {
	log.Println("Calling Environment.GetDofBlurFarAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dof_blur_far_amount", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetDofBlurFarQuality(intensity int64) {
	log.Println("Calling Environment.SetDofBlurFarQuality()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(intensity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dof_blur_far_quality", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetDofBlurFarQuality() int64 {
	log.Println("Calling Environment.GetDofBlurFarQuality()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dof_blur_far_quality", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Environment) SetDofBlurNearEnabled(enabled bool) {
	log.Println("Calling Environment.SetDofBlurNearEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dof_blur_near_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) IsDofBlurNearEnabled() bool {
	log.Println("Calling Environment.IsDofBlurNearEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_dof_blur_near_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Environment) SetDofBlurNearDistance(intensity float64) {
	log.Println("Calling Environment.SetDofBlurNearDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(intensity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dof_blur_near_distance", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetDofBlurNearDistance() float64 {
	log.Println("Calling Environment.GetDofBlurNearDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dof_blur_near_distance", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetDofBlurNearTransition(intensity float64) {
	log.Println("Calling Environment.SetDofBlurNearTransition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(intensity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dof_blur_near_transition", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetDofBlurNearTransition() float64 {
	log.Println("Calling Environment.GetDofBlurNearTransition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dof_blur_near_transition", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetDofBlurNearAmount(intensity float64) {
	log.Println("Calling Environment.SetDofBlurNearAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(intensity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dof_blur_near_amount", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetDofBlurNearAmount() float64 {
	log.Println("Calling Environment.GetDofBlurNearAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dof_blur_near_amount", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetDofBlurNearQuality(level int64) {
	log.Println("Calling Environment.SetDofBlurNearQuality()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(level)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dof_blur_near_quality", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetDofBlurNearQuality() int64 {
	log.Println("Calling Environment.GetDofBlurNearQuality()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dof_blur_near_quality", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Environment) SetGlowEnabled(enabled bool) {
	log.Println("Calling Environment.SetGlowEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_glow_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) IsGlowEnabled() bool {
	log.Println("Calling Environment.IsGlowEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_glow_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Environment) SetGlowLevel(idx int64, enabled bool) {
	log.Println("Calling Environment.SetGlowLevel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_glow_level", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) IsGlowLevelEnabled(idx int64) bool {
	log.Println("Calling Environment.IsGlowLevelEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_glow_level_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Environment) SetGlowIntensity(intensity float64) {
	log.Println("Calling Environment.SetGlowIntensity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(intensity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_glow_intensity", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetGlowIntensity() float64 {
	log.Println("Calling Environment.GetGlowIntensity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_glow_intensity", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetGlowStrength(strength float64) {
	log.Println("Calling Environment.SetGlowStrength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(strength)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_glow_strength", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetGlowStrength() float64 {
	log.Println("Calling Environment.GetGlowStrength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_glow_strength", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetGlowBloom(amount float64) {
	log.Println("Calling Environment.SetGlowBloom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_glow_bloom", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetGlowBloom() float64 {
	log.Println("Calling Environment.GetGlowBloom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_glow_bloom", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetGlowBlendMode(mode int64) {
	log.Println("Calling Environment.SetGlowBlendMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_glow_blend_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetGlowBlendMode() int64 {
	log.Println("Calling Environment.GetGlowBlendMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_glow_blend_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Environment) SetGlowHdrBleedThreshold(threshold float64) {
	log.Println("Calling Environment.SetGlowHdrBleedThreshold()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(threshold)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_glow_hdr_bleed_threshold", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetGlowHdrBleedThreshold() float64 {
	log.Println("Calling Environment.GetGlowHdrBleedThreshold()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_glow_hdr_bleed_threshold", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetGlowHdrBleedScale(scale float64) {
	log.Println("Calling Environment.SetGlowHdrBleedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_glow_hdr_bleed_scale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetGlowHdrBleedScale() float64 {
	log.Println("Calling Environment.GetGlowHdrBleedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_glow_hdr_bleed_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetGlowBicubicUpscale(enabled bool) {
	log.Println("Calling Environment.SetGlowBicubicUpscale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_glow_bicubic_upscale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) IsGlowBicubicUpscaleEnabled() bool {
	log.Println("Calling Environment.IsGlowBicubicUpscaleEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_glow_bicubic_upscale_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Environment) SetAdjustmentEnable(enabled bool) {
	log.Println("Calling Environment.SetAdjustmentEnable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_adjustment_enable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) IsAdjustmentEnabled() bool {
	log.Println("Calling Environment.IsAdjustmentEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_adjustment_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Environment) SetAdjustmentBrightness(brightness float64) {
	log.Println("Calling Environment.SetAdjustmentBrightness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(brightness)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_adjustment_brightness", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetAdjustmentBrightness() float64 {
	log.Println("Calling Environment.GetAdjustmentBrightness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_adjustment_brightness", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetAdjustmentContrast(contrast float64) {
	log.Println("Calling Environment.SetAdjustmentContrast()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contrast)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_adjustment_contrast", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetAdjustmentContrast() float64 {
	log.Println("Calling Environment.GetAdjustmentContrast()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_adjustment_contrast", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetAdjustmentSaturation(saturation float64) {
	log.Println("Calling Environment.SetAdjustmentSaturation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(saturation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_adjustment_saturation", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetAdjustmentSaturation() float64 {
	log.Println("Calling Environment.GetAdjustmentSaturation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_adjustment_saturation", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) SetAdjustmentColorCorrection(colorCorrection *Texture) {
	log.Println("Calling Environment.SetAdjustmentColorCorrection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(colorCorrection)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_adjustment_color_correction", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) GetAdjustmentColorCorrection() *Texture {
	log.Println("Calling Environment.GetAdjustmentColorCorrection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_adjustment_color_correction", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   EnvironmentImplementer is an interface for Environment objects.
*/
type EnvironmentImplementer interface {
	Class
}

/*

 */
type RemoteTransform struct {
	Spatial
}

func (o *RemoteTransform) baseClass() string {
	return "RemoteTransform"
}

/*

 */
func (o *RemoteTransform) SetRemoteNode(path *NodePath) {
	log.Println("Calling RemoteTransform.SetRemoteNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_remote_node", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RemoteTransform) GetRemoteNode() *NodePath {
	log.Println("Calling RemoteTransform.GetRemoteNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_remote_node", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *RemoteTransform) SetUseGlobalCoordinates(useGlobalCoordinates bool) {
	log.Println("Calling RemoteTransform.SetUseGlobalCoordinates()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(useGlobalCoordinates)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_global_coordinates", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RemoteTransform) GetUseGlobalCoordinates() bool {
	log.Println("Calling RemoteTransform.GetUseGlobalCoordinates()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_use_global_coordinates", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *RemoteTransform) SetUpdatePosition(updateRemotePosition bool) {
	log.Println("Calling RemoteTransform.SetUpdatePosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(updateRemotePosition)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_update_position", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RemoteTransform) GetUpdatePosition() bool {
	log.Println("Calling RemoteTransform.GetUpdatePosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_update_position", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *RemoteTransform) SetUpdateRotation(updateRemoteRotation bool) {
	log.Println("Calling RemoteTransform.SetUpdateRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(updateRemoteRotation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_update_rotation", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RemoteTransform) GetUpdateRotation() bool {
	log.Println("Calling RemoteTransform.GetUpdateRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_update_rotation", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *RemoteTransform) SetUpdateScale(updateRemoteScale bool) {
	log.Println("Calling RemoteTransform.SetUpdateScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(updateRemoteScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_update_scale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RemoteTransform) GetUpdateScale() bool {
	log.Println("Calling RemoteTransform.GetUpdateScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_update_scale", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   RemoteTransformImplementer is an interface for RemoteTransform objects.
*/
type RemoteTransformImplementer interface {
	Class
}

/*

 */
type Joint struct {
	Spatial
}

func (o *Joint) baseClass() string {
	return "Joint"
}

/*

 */
func (o *Joint) SetNodeA(node *NodePath) {
	log.Println("Calling Joint.SetNodeA()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_node_a", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Joint) GetNodeA() *NodePath {
	log.Println("Calling Joint.GetNodeA()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_a", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *Joint) SetNodeB(node *NodePath) {
	log.Println("Calling Joint.SetNodeB()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_node_b", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Joint) GetNodeB() *NodePath {
	log.Println("Calling Joint.GetNodeB()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_b", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *Joint) SetSolverPriority(priority int64) {
	log.Println("Calling Joint.SetSolverPriority()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(priority)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_solver_priority", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Joint) GetSolverPriority() int64 {
	log.Println("Calling Joint.GetSolverPriority()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_solver_priority", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Joint) SetExcludeNodesFromCollision(enable bool) {
	log.Println("Calling Joint.SetExcludeNodesFromCollision()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_exclude_nodes_from_collision", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Joint) GetExcludeNodesFromCollision() bool {
	log.Println("Calling Joint.GetExcludeNodesFromCollision()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_exclude_nodes_from_collision", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   JointImplementer is an interface for Joint objects.
*/
type JointImplementer interface {
	Class
}

/*

 */
type PinJoint struct {
	Joint
}

func (o *PinJoint) baseClass() string {
	return "PinJoint"
}

/*

 */
func (o *PinJoint) SetParam(param int64, value float64) {
	log.Println("Calling PinJoint.SetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_param", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PinJoint) GetParam(param int64) float64 {
	log.Println("Calling PinJoint.GetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   PinJointImplementer is an interface for PinJoint objects.
*/
type PinJointImplementer interface {
	Class
}

/*

 */
type HingeJoint struct {
	Joint
}

func (o *HingeJoint) baseClass() string {
	return "HingeJoint"
}

/*

 */
func (o *HingeJoint) SetParam(param int64, value float64) {
	log.Println("Calling HingeJoint.SetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_param", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *HingeJoint) GetParam(param int64) float64 {
	log.Println("Calling HingeJoint.GetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *HingeJoint) SetFlag(flag int64, enabled bool) {
	log.Println("Calling HingeJoint.SetFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(flag)
	goArguments[1] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flag", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *HingeJoint) GetFlag(flag int64) bool {
	log.Println("Calling HingeJoint.GetFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flag)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_flag", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *HingeJoint) X_SetUpperLimit(upperLimit float64) {
	log.Println("Calling HingeJoint.X_SetUpperLimit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(upperLimit)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_upper_limit", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *HingeJoint) X_GetUpperLimit() float64 {
	log.Println("Calling HingeJoint.X_GetUpperLimit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_upper_limit", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Undocumented
*/
func (o *HingeJoint) X_SetLowerLimit(lowerLimit float64) {
	log.Println("Calling HingeJoint.X_SetLowerLimit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(lowerLimit)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_lower_limit", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *HingeJoint) X_GetLowerLimit() float64 {
	log.Println("Calling HingeJoint.X_GetLowerLimit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_lower_limit", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   HingeJointImplementer is an interface for HingeJoint objects.
*/
type HingeJointImplementer interface {
	Class
}

/*

 */
type SliderJoint struct {
	Joint
}

func (o *SliderJoint) baseClass() string {
	return "SliderJoint"
}

/*

 */
func (o *SliderJoint) SetParam(param int64, value float64) {
	log.Println("Calling SliderJoint.SetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_param", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SliderJoint) GetParam(param int64) float64 {
	log.Println("Calling SliderJoint.GetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Undocumented
*/
func (o *SliderJoint) X_SetUpperLimitAngular(upperLimitAngular float64) {
	log.Println("Calling SliderJoint.X_SetUpperLimitAngular()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(upperLimitAngular)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_upper_limit_angular", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *SliderJoint) X_GetUpperLimitAngular() float64 {
	log.Println("Calling SliderJoint.X_GetUpperLimitAngular()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_upper_limit_angular", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Undocumented
*/
func (o *SliderJoint) X_SetLowerLimitAngular(lowerLimitAngular float64) {
	log.Println("Calling SliderJoint.X_SetLowerLimitAngular()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(lowerLimitAngular)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_lower_limit_angular", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *SliderJoint) X_GetLowerLimitAngular() float64 {
	log.Println("Calling SliderJoint.X_GetLowerLimitAngular()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_lower_limit_angular", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   SliderJointImplementer is an interface for SliderJoint objects.
*/
type SliderJointImplementer interface {
	Class
}

/*

 */
type Generic6DOFJoint struct {
	Joint
}

func (o *Generic6DOFJoint) baseClass() string {
	return "Generic6DOFJoint"
}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) X_SetAngularHiLimitX(angle float64) {
	log.Println("Calling Generic6DOFJoint.X_SetAngularHiLimitX()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(angle)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_angular_hi_limit_x", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) X_GetAngularHiLimitX() float64 {
	log.Println("Calling Generic6DOFJoint.X_GetAngularHiLimitX()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_angular_hi_limit_x", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) X_SetAngularLoLimitX(angle float64) {
	log.Println("Calling Generic6DOFJoint.X_SetAngularLoLimitX()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(angle)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_angular_lo_limit_x", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) X_GetAngularLoLimitX() float64 {
	log.Println("Calling Generic6DOFJoint.X_GetAngularLoLimitX()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_angular_lo_limit_x", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) X_SetAngularHiLimitY(angle float64) {
	log.Println("Calling Generic6DOFJoint.X_SetAngularHiLimitY()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(angle)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_angular_hi_limit_y", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) X_GetAngularHiLimitY() float64 {
	log.Println("Calling Generic6DOFJoint.X_GetAngularHiLimitY()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_angular_hi_limit_y", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) X_SetAngularLoLimitY(angle float64) {
	log.Println("Calling Generic6DOFJoint.X_SetAngularLoLimitY()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(angle)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_angular_lo_limit_y", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) X_GetAngularLoLimitY() float64 {
	log.Println("Calling Generic6DOFJoint.X_GetAngularLoLimitY()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_angular_lo_limit_y", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) X_SetAngularHiLimitZ(angle float64) {
	log.Println("Calling Generic6DOFJoint.X_SetAngularHiLimitZ()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(angle)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_angular_hi_limit_z", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) X_GetAngularHiLimitZ() float64 {
	log.Println("Calling Generic6DOFJoint.X_GetAngularHiLimitZ()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_angular_hi_limit_z", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) X_SetAngularLoLimitZ(angle float64) {
	log.Println("Calling Generic6DOFJoint.X_SetAngularLoLimitZ()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(angle)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_angular_lo_limit_z", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) X_GetAngularLoLimitZ() float64 {
	log.Println("Calling Generic6DOFJoint.X_GetAngularLoLimitZ()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_angular_lo_limit_z", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Generic6DOFJoint) SetParamX(param int64, value float64) {
	log.Println("Calling Generic6DOFJoint.SetParamX()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_param_x", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Generic6DOFJoint) GetParamX(param int64) float64 {
	log.Println("Calling Generic6DOFJoint.GetParamX()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_param_x", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Generic6DOFJoint) SetParamY(param int64, value float64) {
	log.Println("Calling Generic6DOFJoint.SetParamY()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_param_y", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Generic6DOFJoint) GetParamY(param int64) float64 {
	log.Println("Calling Generic6DOFJoint.GetParamY()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_param_y", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Generic6DOFJoint) SetParamZ(param int64, value float64) {
	log.Println("Calling Generic6DOFJoint.SetParamZ()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_param_z", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Generic6DOFJoint) GetParamZ(param int64) float64 {
	log.Println("Calling Generic6DOFJoint.GetParamZ()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_param_z", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Generic6DOFJoint) SetFlagX(flag int64, value bool) {
	log.Println("Calling Generic6DOFJoint.SetFlagX()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(flag)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flag_x", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Generic6DOFJoint) GetFlagX(flag int64) bool {
	log.Println("Calling Generic6DOFJoint.GetFlagX()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flag)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_flag_x", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Generic6DOFJoint) SetFlagY(flag int64, value bool) {
	log.Println("Calling Generic6DOFJoint.SetFlagY()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(flag)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flag_y", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Generic6DOFJoint) GetFlagY(flag int64) bool {
	log.Println("Calling Generic6DOFJoint.GetFlagY()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flag)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_flag_y", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Generic6DOFJoint) SetFlagZ(flag int64, value bool) {
	log.Println("Calling Generic6DOFJoint.SetFlagZ()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(flag)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flag_z", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Generic6DOFJoint) GetFlagZ(flag int64) bool {
	log.Println("Calling Generic6DOFJoint.GetFlagZ()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flag)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_flag_z", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Generic6DOFJointImplementer is an interface for Generic6DOFJoint objects.
*/
type Generic6DOFJointImplementer interface {
	Class
}

/*

 */
type ConeTwistJoint struct {
	Joint
}

func (o *ConeTwistJoint) baseClass() string {
	return "ConeTwistJoint"
}

/*

 */
func (o *ConeTwistJoint) SetParam(param int64, value float64) {
	log.Println("Calling ConeTwistJoint.SetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_param", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ConeTwistJoint) GetParam(param int64) float64 {
	log.Println("Calling ConeTwistJoint.GetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Undocumented
*/
func (o *ConeTwistJoint) X_SetSwingSpan(swingSpan float64) {
	log.Println("Calling ConeTwistJoint.X_SetSwingSpan()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(swingSpan)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_swing_span", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ConeTwistJoint) X_GetSwingSpan() float64 {
	log.Println("Calling ConeTwistJoint.X_GetSwingSpan()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_swing_span", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Undocumented
*/
func (o *ConeTwistJoint) X_SetTwistSpan(twistSpan float64) {
	log.Println("Calling ConeTwistJoint.X_SetTwistSpan()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(twistSpan)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_twist_span", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ConeTwistJoint) X_GetTwistSpan() float64 {
	log.Println("Calling ConeTwistJoint.X_GetTwistSpan()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_twist_span", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   ConeTwistJointImplementer is an interface for ConeTwistJoint objects.
*/
type ConeTwistJointImplementer interface {
	Class
}

/*
   Library of meshes. Contains a list of [Mesh] resources, each with name and ID. Useful for GridMap or painting Terrain.
*/
type MeshLibrary struct {
	Resource
}

func (o *MeshLibrary) baseClass() string {
	return "MeshLibrary"
}

/*
   Create a new item in the library, supplied an id.
*/
func (o *MeshLibrary) CreateItem(id int64) {
	log.Println("Calling MeshLibrary.CreateItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create_item", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the name of the item.
*/
func (o *MeshLibrary) SetItemName(id int64, name string) {
	log.Println("Calling MeshLibrary.SetItemName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_name", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the mesh of the item.
*/
func (o *MeshLibrary) SetItemMesh(id int64, mesh *Mesh) {
	log.Println("Calling MeshLibrary.SetItemMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(mesh)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_mesh", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshLibrary) SetItemNavmesh(id int64, navmesh *NavigationMesh) {
	log.Println("Calling MeshLibrary.SetItemNavmesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(navmesh)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_navmesh", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshLibrary) SetItemShapes(id int64, shapes *Array) {
	log.Println("Calling MeshLibrary.SetItemShapes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(shapes)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_shapes", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshLibrary) SetItemPreview(id int64, texture *Texture) {
	log.Println("Calling MeshLibrary.SetItemPreview()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_preview", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the name of the item.
*/
func (o *MeshLibrary) GetItemName(id int64) string {
	log.Println("Calling MeshLibrary.GetItemName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the mesh of the item.
*/
func (o *MeshLibrary) GetItemMesh(id int64) *Mesh {
	log.Println("Calling MeshLibrary.GetItemMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_mesh", goArguments, "*Mesh")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Mesh)

	return returnValue

}

/*

 */
func (o *MeshLibrary) GetItemNavmesh(id int64) *NavigationMesh {
	log.Println("Calling MeshLibrary.GetItemNavmesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_navmesh", goArguments, "*NavigationMesh")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NavigationMesh)

	return returnValue

}

/*

 */
func (o *MeshLibrary) GetItemShapes(id int64) *Array {
	log.Println("Calling MeshLibrary.GetItemShapes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_shapes", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *MeshLibrary) GetItemPreview(id int64) *Texture {
	log.Println("Calling MeshLibrary.GetItemPreview()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_preview", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   Remove the item.
*/
func (o *MeshLibrary) RemoveItem(id int64) {
	log.Println("Calling MeshLibrary.RemoveItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_item", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshLibrary) FindItemByName(name string) int64 {
	log.Println("Calling MeshLibrary.FindItemByName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "find_item_by_name", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Clear the library.
*/
func (o *MeshLibrary) Clear() {
	log.Println("Calling MeshLibrary.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the list of items.
*/
func (o *MeshLibrary) GetItemList() *PoolIntArray {
	log.Println("Calling MeshLibrary.GetItemList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_list", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*
   Get an unused id for a new item.
*/
func (o *MeshLibrary) GetLastUnusedItemId() int64 {
	log.Println("Calling MeshLibrary.GetLastUnusedItemId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_last_unused_item_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   MeshLibraryImplementer is an interface for MeshLibrary objects.
*/
type MeshLibraryImplementer interface {
	Class
}

/*
   To be changed, ignore.
*/
type Shader struct {
	Resource
}

func (o *Shader) baseClass() string {
	return "Shader"
}

/*

 */
func (o *Shader) GetMode() int64 {
	log.Println("Calling Shader.GetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Shader) SetCode(code string) {
	log.Println("Calling Shader.SetCode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(code)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_code", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Shader) GetCode() string {
	log.Println("Calling Shader.GetCode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_code", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *Shader) SetDefaultTextureParam(param string, texture *Texture) {
	log.Println("Calling Shader.SetDefaultTextureParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_default_texture_param", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Shader) GetDefaultTextureParam(param string) *Texture {
	log.Println("Calling Shader.GetDefaultTextureParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_default_texture_param", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *Shader) HasParam(name string) bool {
	log.Println("Calling Shader.HasParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_param", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   ShaderImplementer is an interface for Shader objects.
*/
type ShaderImplementer interface {
	Class
}

/*
   Material is a base [Resource] used for coloring and shading geometry. All materials inherit from it and almost all [VisualInstance] derived nodes carry a Material. A few flags and parameters are shared between all material types and are configured here.
*/
type Material struct {
	Resource
}

func (o *Material) baseClass() string {
	return "Material"
}

/*

 */
func (o *Material) SetNextPass(nextPass *Material) {
	log.Println("Calling Material.SetNextPass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(nextPass)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_next_pass", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Material) GetNextPass() *Material {
	log.Println("Calling Material.GetNextPass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_next_pass", goArguments, "*Material")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Material)

	return returnValue

}

/*

 */
func (o *Material) SetRenderPriority(priority int64) {
	log.Println("Calling Material.SetRenderPriority()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(priority)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_render_priority", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Material) GetRenderPriority() int64 {
	log.Println("Calling Material.GetRenderPriority()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_render_priority", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   MaterialImplementer is an interface for Material objects.
*/
type MaterialImplementer interface {
	Class
}

/*

 */
type ShaderMaterial struct {
	Material
}

func (o *ShaderMaterial) baseClass() string {
	return "ShaderMaterial"
}

/*

 */
func (o *ShaderMaterial) SetShader(shader *Shader) {
	log.Println("Calling ShaderMaterial.SetShader()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shader)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shader", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ShaderMaterial) GetShader() *Shader {
	log.Println("Calling ShaderMaterial.GetShader()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shader", goArguments, "*Shader")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Shader)

	return returnValue

}

/*

 */
func (o *ShaderMaterial) SetShaderParam(param string, value *Variant) {
	log.Println("Calling ShaderMaterial.SetShaderParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shader_param", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ShaderMaterial) GetShaderParam(param string) *Variant {
	log.Println("Calling ShaderMaterial.GetShaderParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shader_param", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   ShaderMaterialImplementer is an interface for ShaderMaterial objects.
*/
type ShaderMaterialImplementer interface {
	Class
}

/*

 */
type CanvasItemMaterial struct {
	Material
}

func (o *CanvasItemMaterial) baseClass() string {
	return "CanvasItemMaterial"
}

/*

 */
func (o *CanvasItemMaterial) SetBlendMode(blendMode int64) {
	log.Println("Calling CanvasItemMaterial.SetBlendMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(blendMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_blend_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CanvasItemMaterial) GetBlendMode() int64 {
	log.Println("Calling CanvasItemMaterial.GetBlendMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_blend_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CanvasItemMaterial) SetLightMode(lightMode int64) {
	log.Println("Calling CanvasItemMaterial.SetLightMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(lightMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_light_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CanvasItemMaterial) GetLightMode() int64 {
	log.Println("Calling CanvasItemMaterial.GetLightMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_light_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   CanvasItemMaterialImplementer is an interface for CanvasItemMaterial objects.
*/
type CanvasItemMaterialImplementer interface {
	Class
}

/*
   Particles2D is a particle system 2D [Node] that is used to simulate several types of particle effects, such as explosions, rain, snow, fireflies, or other magical-like shinny sparkles. Particles are drawn using impostors, and given their dynamic behavior, the user must provide a visibility bounding box (although helpers to create one automatically exist).
*/
type Particles2D struct {
	Node2D
}

func (o *Particles2D) baseClass() string {
	return "Particles2D"
}

/*
   If this is set to true then the particle emitter will emit particles, if its false it will not.
*/
func (o *Particles2D) SetEmitting(emitting bool) {
	log.Println("Calling Particles2D.SetEmitting()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(emitting)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emitting", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the amount of particles spawned at each emission
*/
func (o *Particles2D) SetAmount(amount int64) {
	log.Println("Calling Particles2D.SetAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_amount", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the amount of seconds that each particle will be visible.
*/
func (o *Particles2D) SetLifetime(secs float64) {
	log.Println("Calling Particles2D.SetLifetime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(secs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_lifetime", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) SetOneShot(secs bool) {
	log.Println("Calling Particles2D.SetOneShot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(secs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_one_shot", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) SetPreProcessTime(secs float64) {
	log.Println("Calling Particles2D.SetPreProcessTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(secs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pre_process_time", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) SetExplosivenessRatio(ratio float64) {
	log.Println("Calling Particles2D.SetExplosivenessRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ratio)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_explosiveness_ratio", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) SetRandomnessRatio(ratio float64) {
	log.Println("Calling Particles2D.SetRandomnessRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ratio)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_randomness_ratio", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) SetVisibilityRect(aabb *Rect2) {
	log.Println("Calling Particles2D.SetVisibilityRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aabb)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_visibility_rect", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) SetUseLocalCoordinates(enable bool) {
	log.Println("Calling Particles2D.SetUseLocalCoordinates()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_local_coordinates", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) SetFixedFps(fps int64) {
	log.Println("Calling Particles2D.SetFixedFps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fps)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fixed_fps", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) SetFractionalDelta(enable bool) {
	log.Println("Calling Particles2D.SetFractionalDelta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fractional_delta", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) SetProcessMaterial(material *Material) {
	log.Println("Calling Particles2D.SetProcessMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(material)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_process_material", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) SetSpeedScale(scale float64) {
	log.Println("Calling Particles2D.SetSpeedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_speed_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether this emitter is currently emitting or not
*/
func (o *Particles2D) IsEmitting() bool {
	log.Println("Calling Particles2D.IsEmitting()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_emitting", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns the amount of particles spawned at each emission
*/
func (o *Particles2D) GetAmount() int64 {
	log.Println("Calling Particles2D.GetAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_amount", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Gets the amount of seconds that each particle will be visible.
*/
func (o *Particles2D) GetLifetime() float64 {
	log.Println("Calling Particles2D.GetLifetime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_lifetime", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Particles2D) GetOneShot() bool {
	log.Println("Calling Particles2D.GetOneShot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_one_shot", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Particles2D) GetPreProcessTime() float64 {
	log.Println("Calling Particles2D.GetPreProcessTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pre_process_time", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Particles2D) GetExplosivenessRatio() float64 {
	log.Println("Calling Particles2D.GetExplosivenessRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_explosiveness_ratio", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Particles2D) GetRandomnessRatio() float64 {
	log.Println("Calling Particles2D.GetRandomnessRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_randomness_ratio", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Particles2D) GetVisibilityRect() *Rect2 {
	log.Println("Calling Particles2D.GetVisibilityRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_visibility_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*

 */
func (o *Particles2D) GetUseLocalCoordinates() bool {
	log.Println("Calling Particles2D.GetUseLocalCoordinates()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_use_local_coordinates", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Particles2D) GetFixedFps() int64 {
	log.Println("Calling Particles2D.GetFixedFps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fixed_fps", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Particles2D) GetFractionalDelta() bool {
	log.Println("Calling Particles2D.GetFractionalDelta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fractional_delta", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Particles2D) GetProcessMaterial() *Material {
	log.Println("Calling Particles2D.GetProcessMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_process_material", goArguments, "*Material")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Material)

	return returnValue

}

/*

 */
func (o *Particles2D) GetSpeedScale() float64 {
	log.Println("Calling Particles2D.GetSpeedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_speed_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Particles2D) SetDrawOrder(order int64) {
	log.Println("Calling Particles2D.SetDrawOrder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(order)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_draw_order", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) GetDrawOrder() int64 {
	log.Println("Calling Particles2D.GetDrawOrder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_draw_order", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Particles2D) SetTexture(texture *Texture) {
	log.Println("Calling Particles2D.SetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the texture for emitted particles
*/
func (o *Particles2D) GetTexture() *Texture {
	log.Println("Calling Particles2D.GetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *Particles2D) SetNormalMap(texture *Texture) {
	log.Println("Calling Particles2D.SetNormalMap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_normal_map", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) GetNormalMap() *Texture {
	log.Println("Calling Particles2D.GetNormalMap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_normal_map", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *Particles2D) CaptureRect() *Rect2 {
	log.Println("Calling Particles2D.CaptureRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "capture_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*

 */
func (o *Particles2D) SetVFrames(frames int64) {
	log.Println("Calling Particles2D.SetVFrames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(frames)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_v_frames", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) GetVFrames() int64 {
	log.Println("Calling Particles2D.GetVFrames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_v_frames", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Particles2D) SetHFrames(frames int64) {
	log.Println("Calling Particles2D.SetHFrames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(frames)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_h_frames", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) GetHFrames() int64 {
	log.Println("Calling Particles2D.GetHFrames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_h_frames", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Particles2D) Restart() {
	log.Println("Calling Particles2D.Restart()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "restart", goArguments, "")

	log.Println("Got return value!")

}

/*
   Particles2DImplementer is an interface for Particles2D objects.
*/
type Particles2DImplementer interface {
	Class
}

/*
   A node that displays a 2D texture. The texture displayed can be a region from a larger atlas texture, or a frame from a sprite sheet animation.
*/
type Sprite struct {
	Node2D
}

func (o *Sprite) baseClass() string {
	return "Sprite"
}

/*
   Set the base texture for the sprite.
*/
func (o *Sprite) SetTexture(texture *Texture) {
	log.Println("Calling Sprite.SetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the base texture for the sprite.
*/
func (o *Sprite) GetTexture() *Texture {
	log.Println("Calling Sprite.GetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *Sprite) SetNormalMap(normalMap *Texture) {
	log.Println("Calling Sprite.SetNormalMap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(normalMap)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_normal_map", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Sprite) GetNormalMap() *Texture {
	log.Println("Calling Sprite.GetNormalMap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_normal_map", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   Set whether the sprite should be centered on the origin.
*/
func (o *Sprite) SetCentered(centered bool) {
	log.Println("Calling Sprite.SetCentered()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(centered)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_centered", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return if the sprite is centered at the local origin.
*/
func (o *Sprite) IsCentered() bool {
	log.Println("Calling Sprite.IsCentered()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_centered", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the sprite draw offset, useful for setting rotation pivots.
*/
func (o *Sprite) SetOffset(offset *Vector2) {
	log.Println("Calling Sprite.SetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return sprite draw offset.
*/
func (o *Sprite) GetOffset() *Vector2 {
	log.Println("Calling Sprite.GetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set true to flip the sprite horizontally.
*/
func (o *Sprite) SetFlipH(flipH bool) {
	log.Println("Calling Sprite.SetFlipH()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flipH)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flip_h", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if the sprite is flipped horizontally.
*/
func (o *Sprite) IsFlippedH() bool {
	log.Println("Calling Sprite.IsFlippedH()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_flipped_h", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set true to flip the sprite vertically.
*/
func (o *Sprite) SetFlipV(flipV bool) {
	log.Println("Calling Sprite.SetFlipV()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flipV)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flip_v", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if the sprite is flipped vertically.
*/
func (o *Sprite) IsFlippedV() bool {
	log.Println("Calling Sprite.IsFlippedV()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_flipped_v", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the sprite as a sub-region of a bigger texture. Useful for texture-atlases.
*/
func (o *Sprite) SetRegion(enabled bool) {
	log.Println("Calling Sprite.SetRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_region", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return if the sprite reads from a region.
*/
func (o *Sprite) IsRegion() bool {
	log.Println("Calling Sprite.IsRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_region", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the region rect to read from.
*/
func (o *Sprite) SetRegionRect(rect *Rect2) {
	log.Println("Calling Sprite.SetRegionRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rect)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_region_rect", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the region rect to read from.
*/
func (o *Sprite) GetRegionRect() *Rect2 {
	log.Println("Calling Sprite.GetRegionRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_region_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*

 */
func (o *Sprite) SetRegionFilterClip(enabled bool) {
	log.Println("Calling Sprite.SetRegionFilterClip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_region_filter_clip", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Sprite) IsRegionFilterClipEnabled() bool {
	log.Println("Calling Sprite.IsRegionFilterClipEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_region_filter_clip_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the texture frame for a sprite-sheet, works when vframes or hframes are greater than 1.
*/
func (o *Sprite) SetFrame(frame int64) {
	log.Println("Calling Sprite.SetFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(frame)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_frame", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the texture frame for a sprite-sheet, works when vframes or hframes are greater than 1.
*/
func (o *Sprite) GetFrame() int64 {
	log.Println("Calling Sprite.GetFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_frame", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the amount of vertical frames and converts the sprite into a sprite-sheet. This is useful for animation.
*/
func (o *Sprite) SetVframes(vframes int64) {
	log.Println("Calling Sprite.SetVframes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vframes)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vframes", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the amount of vertical frames. See [method set_vframes].
*/
func (o *Sprite) GetVframes() int64 {
	log.Println("Calling Sprite.GetVframes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vframes", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the amount of horizontal frames and converts the sprite into a sprite-sheet. This is useful for animation.
*/
func (o *Sprite) SetHframes(hframes int64) {
	log.Println("Calling Sprite.SetHframes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(hframes)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_hframes", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the amount of horizontal frames. See [method set_hframes].
*/
func (o *Sprite) GetHframes() int64 {
	log.Println("Calling Sprite.GetHframes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_hframes", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   SpriteImplementer is an interface for Sprite objects.
*/
type SpriteImplementer interface {
	Class
}

/*
   Sprite node that can use multiple textures for animation.
*/
type AnimatedSprite struct {
	Node2D
}

func (o *AnimatedSprite) baseClass() string {
	return "AnimatedSprite"
}

/*
   Set the [SpriteFrames] resource, which contains all frames.
*/
func (o *AnimatedSprite) SetSpriteFrames(spriteFrames *SpriteFrames) {
	log.Println("Calling AnimatedSprite.SetSpriteFrames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(spriteFrames)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sprite_frames", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the [SpriteFrames] resource, which contains all frames.
*/
func (o *AnimatedSprite) GetSpriteFrames() *SpriteFrames {
	log.Println("Calling AnimatedSprite.GetSpriteFrames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sprite_frames", goArguments, "*SpriteFrames")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*SpriteFrames)

	return returnValue

}

/*
   Set the current animation of the node and reinits the frame counter of the animation.
*/
func (o *AnimatedSprite) SetAnimation(animation string) {
	log.Println("Calling AnimatedSprite.SetAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(animation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_animation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the name of the current animation set to the node.
*/
func (o *AnimatedSprite) GetAnimation() string {
	log.Println("Calling AnimatedSprite.GetAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_animation", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *AnimatedSprite) X_SetPlaying(playing bool) {
	log.Println("Calling AnimatedSprite.X_SetPlaying()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(playing)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_playing", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *AnimatedSprite) X_IsPlaying() bool {
	log.Println("Calling AnimatedSprite.X_IsPlaying()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_is_playing", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Play the animation set in parameter. If no parameter is provided, the current animation is played.
*/
func (o *AnimatedSprite) Play(anim string) {
	log.Println("Calling AnimatedSprite.Play()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anim)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "play", goArguments, "")

	log.Println("Got return value!")

}

/*
   Stop the current animation (does not reset the frame counter).
*/
func (o *AnimatedSprite) Stop() {
	log.Println("Calling AnimatedSprite.Stop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "stop", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if an animation if currently being played.
*/
func (o *AnimatedSprite) IsPlaying() bool {
	log.Println("Calling AnimatedSprite.IsPlaying()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_playing", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   When turned on, offset at (0,0) is the center of the sprite, when off, the top-left corner is.
*/
func (o *AnimatedSprite) SetCentered(centered bool) {
	log.Println("Calling AnimatedSprite.SetCentered()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(centered)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_centered", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true when centered. See [method set_centered].
*/
func (o *AnimatedSprite) IsCentered() bool {
	log.Println("Calling AnimatedSprite.IsCentered()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_centered", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the offset of the sprite in the node origin. Position varies depending on whether it is centered or not.
*/
func (o *AnimatedSprite) SetOffset(offset *Vector2) {
	log.Println("Calling AnimatedSprite.SetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the offset of the sprite in the node origin.
*/
func (o *AnimatedSprite) GetOffset() *Vector2 {
	log.Println("Calling AnimatedSprite.GetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   If true, sprite is flipped horizontally.
*/
func (o *AnimatedSprite) SetFlipH(flipH bool) {
	log.Println("Calling AnimatedSprite.SetFlipH()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flipH)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flip_h", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if sprite is flipped horizontally.
*/
func (o *AnimatedSprite) IsFlippedH() bool {
	log.Println("Calling AnimatedSprite.IsFlippedH()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_flipped_h", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   If true, sprite is flipped vertically.
*/
func (o *AnimatedSprite) SetFlipV(flipV bool) {
	log.Println("Calling AnimatedSprite.SetFlipV()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flipV)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flip_v", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if sprite is flipped vertically.
*/
func (o *AnimatedSprite) IsFlippedV() bool {
	log.Println("Calling AnimatedSprite.IsFlippedV()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_flipped_v", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the visible sprite frame index (from the list of frames inside the [SpriteFrames] resource).
*/
func (o *AnimatedSprite) SetFrame(frame int64) {
	log.Println("Calling AnimatedSprite.SetFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(frame)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_frame", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the visible frame index.
*/
func (o *AnimatedSprite) GetFrame() int64 {
	log.Println("Calling AnimatedSprite.GetFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_frame", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *AnimatedSprite) X_ResChanged() {
	log.Println("Calling AnimatedSprite.X_ResChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_res_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   AnimatedSpriteImplementer is an interface for AnimatedSprite objects.
*/
type AnimatedSpriteImplementer interface {
	Class
}

/*
   Generic 2D Position hint for editing. It's just like a plain [Node2D] but displays as a cross in the 2D-Editor at all times.
*/
type Position2D struct {
	Node2D
}

func (o *Position2D) baseClass() string {
	return "Position2D"
}

/*
   Position2DImplementer is an interface for Position2D objects.
*/
type Position2DImplementer interface {
	Class
}

/*
   A line through several points in 2D space.
*/
type Line2D struct {
	Node2D
}

func (o *Line2D) baseClass() string {
	return "Line2D"
}

/*

 */
func (o *Line2D) SetPoints(points *PoolVector2Array) {
	log.Println("Calling Line2D.SetPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(points)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_points", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Line2D) GetPoints() *PoolVector2Array {
	log.Println("Calling Line2D.GetPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_points", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*

 */
func (o *Line2D) SetPointPosition(i int64, position *Vector2) {
	log.Println("Calling Line2D.SetPointPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(i)
	goArguments[1] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_position", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Line2D) GetPointPosition(i int64) *Vector2 {
	log.Println("Calling Line2D.GetPointPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(i)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Line2D) GetPointCount() int64 {
	log.Println("Calling Line2D.GetPointCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Add a point at the x/y position in the supplied [Vector2]
*/
func (o *Line2D) AddPoint(position *Vector2) {
	log.Println("Calling Line2D.AddPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_point", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove the point at index 'i' from the line.
*/
func (o *Line2D) RemovePoint(i int64) {
	log.Println("Calling Line2D.RemovePoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(i)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_point", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Line2D) SetWidth(width float64) {
	log.Println("Calling Line2D.SetWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(width)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_width", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Line2D) GetWidth() float64 {
	log.Println("Calling Line2D.GetWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_width", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Line2D) SetDefaultColor(color *Color) {
	log.Println("Calling Line2D.SetDefaultColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_default_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Line2D) GetDefaultColor() *Color {
	log.Println("Calling Line2D.GetDefaultColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_default_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *Line2D) SetGradient(color *Gradient) {
	log.Println("Calling Line2D.SetGradient()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gradient", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Line2D) GetGradient() *Gradient {
	log.Println("Calling Line2D.GetGradient()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gradient", goArguments, "*Gradient")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Gradient)

	return returnValue

}

/*

 */
func (o *Line2D) SetTexture(texture *Texture) {
	log.Println("Calling Line2D.SetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Line2D) GetTexture() *Texture {
	log.Println("Calling Line2D.GetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *Line2D) SetTextureMode(mode int64) {
	log.Println("Calling Line2D.SetTextureMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Line2D) GetTextureMode() int64 {
	log.Println("Calling Line2D.GetTextureMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Line2D) SetJointMode(mode int64) {
	log.Println("Calling Line2D.SetJointMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_joint_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Line2D) GetJointMode() int64 {
	log.Println("Calling Line2D.GetJointMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_joint_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Line2D) SetBeginCapMode(mode int64) {
	log.Println("Calling Line2D.SetBeginCapMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_begin_cap_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Line2D) GetBeginCapMode() int64 {
	log.Println("Calling Line2D.GetBeginCapMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_begin_cap_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Line2D) SetEndCapMode(mode int64) {
	log.Println("Calling Line2D.SetEndCapMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_end_cap_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Line2D) GetEndCapMode() int64 {
	log.Println("Calling Line2D.GetEndCapMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_end_cap_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Line2D) SetSharpLimit(limit float64) {
	log.Println("Calling Line2D.SetSharpLimit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(limit)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sharp_limit", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Line2D) GetSharpLimit() float64 {
	log.Println("Calling Line2D.GetSharpLimit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sharp_limit", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Line2D) SetRoundPrecision(precision int64) {
	log.Println("Calling Line2D.SetRoundPrecision()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(precision)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_round_precision", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Line2D) GetRoundPrecision() int64 {
	log.Println("Calling Line2D.GetRoundPrecision()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_round_precision", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *Line2D) X_GradientChanged() {
	log.Println("Calling Line2D.X_GradientChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_gradient_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Line2DImplementer is an interface for Line2D objects.
*/
type Line2DImplementer interface {
	Class
}

/*
   Given a set of colors, this node will interpolate them in order, meaning, that if you have color 1, color 2 and color3, the ramp will interpolate (generate the colors between two colors) from color 1 to color 2 and from color 2 to color 3. Initially the ramp will have 2 colors (black and white), one (black) at ramp lower offset offset 0 and the other (white) at the ramp higher offset 1.
*/
type Gradient struct {
	Resource
}

func (o *Gradient) baseClass() string {
	return "Gradient"
}

/*
   Adds the specified color to the end of the ramp, with the specified offset
*/
func (o *Gradient) AddPoint(offset float64, color *Color) {
	log.Println("Calling Gradient.AddPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(offset)
	goArguments[1] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_point", goArguments, "")

	log.Println("Got return value!")

}

/*
   Removes the color at the index [i]offset[/i]
*/
func (o *Gradient) RemovePoint(offset int64) {
	log.Println("Calling Gradient.RemovePoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_point", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the offset for the ramp color at index [i]point[/i]
*/
func (o *Gradient) SetOffset(point int64, offset float64) {
	log.Println("Calling Gradient.SetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(point)
	goArguments[1] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the offset of the ramp color at index [i]point[/i]
*/
func (o *Gradient) GetOffset(point int64) float64 {
	log.Println("Calling Gradient.GetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(point)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Sets the color of the ramp color at index [i]point[/i]
*/
func (o *Gradient) SetColor(point int64, color *Color) {
	log.Println("Calling Gradient.SetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(point)
	goArguments[1] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_color", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the color of the ramp color at index [i]point[/i]
*/
func (o *Gradient) GetColor(point int64) *Color {
	log.Println("Calling Gradient.GetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(point)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Returns the interpolated color specified by [i]offset[/i]
*/
func (o *Gradient) Interpolate(offset float64) *Color {
	log.Println("Calling Gradient.Interpolate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "interpolate", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Returns the number of colors in the ramp
*/
func (o *Gradient) GetPointCount() int64 {
	log.Println("Calling Gradient.GetPointCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Sets the offset for the specified amount of elements. Calling this function with a different number of elements than previously defined causes the ramp to resize its colors and offsets array to accommodate the new elements, all new colors will be black by default.
*/
func (o *Gradient) SetOffsets(offsets *PoolRealArray) {
	log.Println("Calling Gradient.SetOffsets()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offsets)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_offsets", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the offsets for the colors in this ramp
*/
func (o *Gradient) GetOffsets() *PoolRealArray {
	log.Println("Calling Gradient.GetOffsets()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_offsets", goArguments, "*PoolRealArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolRealArray)

	return returnValue

}

/*
   Sets the colors for the specified amount of elements. Calling this function with a different number of elements than previously defined causes the ramp to resize its colors and offsets array to accommodate the new elements.
*/
func (o *Gradient) SetColors(colors *PoolColorArray) {
	log.Println("Calling Gradient.SetColors()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(colors)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_colors", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the colors in the ramp
*/
func (o *Gradient) GetColors() *PoolColorArray {
	log.Println("Calling Gradient.GetColors()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_colors", goArguments, "*PoolColorArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolColorArray)

	return returnValue

}

/*
   GradientImplementer is an interface for Gradient objects.
*/
type GradientImplementer interface {
	Class
}

/*
   CollisionObject2D is the base class for 2D physics objects. It can hold any number of 2D collision [Shape2D]\ s. Each shape must be assigned to a [i]shape owner[/i]. The CollisionObject2D can have any number of shape owners. Shape owners are not nodes and do not appear in the editor, but are accessible through code using the [code]shape_owner_*[/code] methods.
*/
type CollisionObject2D struct {
	Node2D
}

func (o *CollisionObject2D) baseClass() string {
	return "CollisionObject2D"
}

/*

 */
func (o *CollisionObject2D) X_InputEvent(viewport *Object, event *InputEvent, shapeIdx int64) {
	log.Println("Calling CollisionObject2D.X_InputEvent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(viewport)
	goArguments[1] = reflect.ValueOf(event)
	goArguments[2] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_input_event", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the object's [RID].
*/
func (o *CollisionObject2D) GetRid() *RID {
	log.Println("Calling CollisionObject2D.GetRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rid", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Set whether this object is pickable. A pickable object can detect the mouse pointer enter/leave it and, if the mouse is inside it, report input events.
*/
func (o *CollisionObject2D) SetPickable(enabled bool) {
	log.Println("Calling CollisionObject2D.SetPickable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pickable", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether this object is pickable.
*/
func (o *CollisionObject2D) IsPickable() bool {
	log.Println("Calling CollisionObject2D.IsPickable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_pickable", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Creates a new shape owner for the given object. Returns [code]owner_id[/code] of the new owner for future reference.
*/
func (o *CollisionObject2D) CreateShapeOwner(owner *Object) int64 {
	log.Println("Calling CollisionObject2D.CreateShapeOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(owner)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "create_shape_owner", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Removes the given shape owner.
*/
func (o *CollisionObject2D) RemoveShapeOwner(ownerId int64) {
	log.Println("Calling CollisionObject2D.RemoveShapeOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ownerId)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_shape_owner", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns an [Array] of [code]owner_id[/code] identifiers. You can use these ids in other methods that take [code]owner_id[/code] as an argument.
*/
func (o *CollisionObject2D) GetShapeOwners() *Array {
	log.Println("Calling CollisionObject2D.GetShapeOwners()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shape_owners", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Sets the [Transform2D] of the given shape owner.
*/
func (o *CollisionObject2D) ShapeOwnerSetTransform(ownerId int64, transform *Transform2D) {
	log.Println("Calling CollisionObject2D.ShapeOwnerSetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ownerId)
	goArguments[1] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shape_owner_set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the shape owner's [Transform2D].
*/
func (o *CollisionObject2D) ShapeOwnerGetTransform(ownerId int64) *Transform2D {
	log.Println("Calling CollisionObject2D.ShapeOwnerGetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ownerId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_owner_get_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Returns the parent object of the given shape owner.
*/
func (o *CollisionObject2D) ShapeOwnerGetOwner(ownerId int64) *Object {
	log.Println("Calling CollisionObject2D.ShapeOwnerGetOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ownerId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_owner_get_owner", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*
   If [code]true[/code] disables the given shape owner.
*/
func (o *CollisionObject2D) ShapeOwnerSetDisabled(ownerId int64, disabled bool) {
	log.Println("Calling CollisionObject2D.ShapeOwnerSetDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ownerId)
	goArguments[1] = reflect.ValueOf(disabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shape_owner_set_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   If [code]true[/code] the shape owner and its shapes are disabled.
*/
func (o *CollisionObject2D) IsShapeOwnerDisabled(ownerId int64) bool {
	log.Println("Calling CollisionObject2D.IsShapeOwnerDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ownerId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_shape_owner_disabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *CollisionObject2D) ShapeOwnerSetOneWayCollision(ownerId int64, enable bool) {
	log.Println("Calling CollisionObject2D.ShapeOwnerSetOneWayCollision()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ownerId)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shape_owner_set_one_way_collision", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionObject2D) IsShapeOwnerOneWayCollisionEnabled(ownerId int64) bool {
	log.Println("Calling CollisionObject2D.IsShapeOwnerOneWayCollisionEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ownerId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_shape_owner_one_way_collision_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Adds a [Shape2D] to the shape owner.
*/
func (o *CollisionObject2D) ShapeOwnerAddShape(ownerId int64, shape *Shape2D) {
	log.Println("Calling CollisionObject2D.ShapeOwnerAddShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ownerId)
	goArguments[1] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shape_owner_add_shape", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the number of shapes the given shape owner contains.
*/
func (o *CollisionObject2D) ShapeOwnerGetShapeCount(ownerId int64) int64 {
	log.Println("Calling CollisionObject2D.ShapeOwnerGetShapeCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ownerId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_owner_get_shape_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the [Shape2D] with the given id from the given shape owner.
*/
func (o *CollisionObject2D) ShapeOwnerGetShape(ownerId int64, shapeId int64) *Shape2D {
	log.Println("Calling CollisionObject2D.ShapeOwnerGetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ownerId)
	goArguments[1] = reflect.ValueOf(shapeId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_owner_get_shape", goArguments, "*Shape2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Shape2D)

	return returnValue

}

/*

 */
func (o *CollisionObject2D) ShapeOwnerGetShapeIndex(ownerId int64, shapeId int64) int64 {
	log.Println("Calling CollisionObject2D.ShapeOwnerGetShapeIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ownerId)
	goArguments[1] = reflect.ValueOf(shapeId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_owner_get_shape_index", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Removes a shape from the given shape owner.
*/
func (o *CollisionObject2D) ShapeOwnerRemoveShape(ownerId int64, shapeId int64) {
	log.Println("Calling CollisionObject2D.ShapeOwnerRemoveShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ownerId)
	goArguments[1] = reflect.ValueOf(shapeId)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shape_owner_remove_shape", goArguments, "")

	log.Println("Got return value!")

}

/*
   Removes all shapes from the shape owner.
*/
func (o *CollisionObject2D) ShapeOwnerClearShapes(ownerId int64) {
	log.Println("Calling CollisionObject2D.ShapeOwnerClearShapes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ownerId)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shape_owner_clear_shapes", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the [code]owner_id[/code] of the given shape.
*/
func (o *CollisionObject2D) ShapeFindOwner(shapeIndex int64) int64 {
	log.Println("Calling CollisionObject2D.ShapeFindOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shapeIndex)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_find_owner", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   CollisionObject2DImplementer is an interface for CollisionObject2D objects.
*/
type CollisionObject2DImplementer interface {
	Class
}

/*
   PhysicsBody2D is an abstract base class for implementing a physics body. All *Body2D types inherit from it.
*/
type PhysicsBody2D struct {
	CollisionObject2D
}

func (o *PhysicsBody2D) baseClass() string {
	return "PhysicsBody2D"
}

/*
   Set the physics layers this area is in. Collidable objects can exist in any of 32 different layers. These layers are not visual, but more of a tagging system instead. A collidable can use these layers/tags to select with which objects it can collide, using [method set_collision_mask]. A contact is detected if object A is in any of the layers that object B scans, or object B is in any layer scanned by object A.
*/
func (o *PhysicsBody2D) SetCollisionLayer(layer int64) {
	log.Println("Calling PhysicsBody2D.SetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the physics layer this area is in.
*/
func (o *PhysicsBody2D) GetCollisionLayer() int64 {
	log.Println("Calling PhysicsBody2D.GetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the physics layers this area can scan for collisions.
*/
func (o *PhysicsBody2D) SetCollisionMask(mask int64) {
	log.Println("Calling PhysicsBody2D.SetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the physics layers this area can scan for collisions.
*/
func (o *PhysicsBody2D) GetCollisionMask() int64 {
	log.Println("Calling PhysicsBody2D.GetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set/clear individual bits on the collision mask. This makes selecting the areas scanned easier.
*/
func (o *PhysicsBody2D) SetCollisionMaskBit(bit int64, value bool) {
	log.Println("Calling PhysicsBody2D.SetCollisionMaskBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(bit)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_mask_bit", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return an individual bit on the collision mask.
*/
func (o *PhysicsBody2D) GetCollisionMaskBit(bit int64) bool {
	log.Println("Calling PhysicsBody2D.GetCollisionMaskBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bit)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_mask_bit", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set/clear individual bits on the layer mask. This makes getting a body in/out of only one layer easier.
*/
func (o *PhysicsBody2D) SetCollisionLayerBit(bit int64, value bool) {
	log.Println("Calling PhysicsBody2D.SetCollisionLayerBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(bit)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer_bit", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return an individual bit on the collision mask.
*/
func (o *PhysicsBody2D) GetCollisionLayerBit(bit int64) bool {
	log.Println("Calling PhysicsBody2D.GetCollisionLayerBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bit)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer_bit", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *PhysicsBody2D) X_SetLayers(mask int64) {
	log.Println("Calling PhysicsBody2D.X_SetLayers()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_layers", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *PhysicsBody2D) X_GetLayers() int64 {
	log.Println("Calling PhysicsBody2D.X_GetLayers()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_layers", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Adds a body to the list of bodies that this body can't collide with.
*/
func (o *PhysicsBody2D) AddCollisionExceptionWith(body *Object) {
	log.Println("Calling PhysicsBody2D.AddCollisionExceptionWith()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_collision_exception_with", goArguments, "")

	log.Println("Got return value!")

}

/*
   Removes a body from the list of bodies that this body can't collide with.
*/
func (o *PhysicsBody2D) RemoveCollisionExceptionWith(body *Object) {
	log.Println("Calling PhysicsBody2D.RemoveCollisionExceptionWith()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_collision_exception_with", goArguments, "")

	log.Println("Got return value!")

}

/*
   PhysicsBody2DImplementer is an interface for PhysicsBody2D objects.
*/
type PhysicsBody2DImplementer interface {
	Class
}

/*
   Static body for 2D Physics. A StaticBody2D is a body that is not intended to move. It is ideal for implementing objects in the environment, such as walls or platforms. Additionally, a constant linear or angular velocity can be set for the static body, which will affect colliding bodies as if it were moving (for example, a conveyor belt).
*/
type StaticBody2D struct {
	PhysicsBody2D
}

func (o *StaticBody2D) baseClass() string {
	return "StaticBody2D"
}

/*
   Set a constant linear velocity for the body. This does not move the body, but affects other bodies touching it, as if it was moving.
*/
func (o *StaticBody2D) SetConstantLinearVelocity(vel *Vector2) {
	log.Println("Calling StaticBody2D.SetConstantLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_constant_linear_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set a constant angular velocity for the body. This does not rotate the body, but affects other bodies touching it, as if it was rotating.
*/
func (o *StaticBody2D) SetConstantAngularVelocity(vel float64) {
	log.Println("Calling StaticBody2D.SetConstantAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_constant_angular_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the constant linear velocity for the body.
*/
func (o *StaticBody2D) GetConstantLinearVelocity() *Vector2 {
	log.Println("Calling StaticBody2D.GetConstantLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_constant_linear_velocity", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the constant angular velocity for the body.
*/
func (o *StaticBody2D) GetConstantAngularVelocity() float64 {
	log.Println("Calling StaticBody2D.GetConstantAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_constant_angular_velocity", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the body friction, from 0 (frictionless) to 1 (full friction).
*/
func (o *StaticBody2D) SetFriction(friction float64) {
	log.Println("Calling StaticBody2D.SetFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(friction)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_friction", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the body friction.
*/
func (o *StaticBody2D) GetFriction() float64 {
	log.Println("Calling StaticBody2D.GetFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_friction", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the body bounciness, from 0 (not bouncy) to 1 (bouncy).
*/
func (o *StaticBody2D) SetBounce(bounce float64) {
	log.Println("Calling StaticBody2D.SetBounce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bounce)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bounce", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the body bounciness.
*/
func (o *StaticBody2D) GetBounce() float64 {
	log.Println("Calling StaticBody2D.GetBounce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bounce", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   StaticBody2DImplementer is an interface for StaticBody2D objects.
*/
type StaticBody2DImplementer interface {
	Class
}

/*
   This is the node that implements full 2D physics. This means that you do not control a RigidBody2D directly. Instead you can apply forces to it (gravity, impulses, etc.), and the physics simulation will calculate the resulting movement, collision, bouncing, rotating, etc. This node can use custom force integration, for writing complex physics motion behavior per node. This node can shift state between regular Rigid body, Kinematic, Character or Static. Character mode forbids this node from being rotated. As a warning, don't change RigidBody2D's position every frame or very often. Sporadic changes work fine, but physics runs at a different granularity (fixed hz) than usual rendering (process callback) and maybe even in a separate thread, so changing this from a process loop will yield strange behavior.
*/
type RigidBody2D struct {
	PhysicsBody2D
}

func (o *RigidBody2D) baseClass() string {
	return "RigidBody2D"
}

/*
   Called during physics processing, allowing you to read and safely modify the simulation state for the object. By default it works in addition to the usual physics behavior, but [method set_use_custom_integrator] allows you to disable the default behavior and do fully custom force integration for a body.
*/
func (o *RigidBody2D) X_IntegrateForces(state *Physics2DDirectBodyState) {
	log.Println("Calling RigidBody2D.X_IntegrateForces()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(state)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_integrate_forces", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the body mode, from the MODE_* enum. This allows to change to a static body or a character body.
*/
func (o *RigidBody2D) SetMode(mode int64) {
	log.Println("Calling RigidBody2D.SetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current body mode, see [method set_mode].
*/
func (o *RigidBody2D) GetMode() int64 {
	log.Println("Calling RigidBody2D.GetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the body mass.
*/
func (o *RigidBody2D) SetMass(mass float64) {
	log.Println("Calling RigidBody2D.SetMass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mass)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mass", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the body mass.
*/
func (o *RigidBody2D) GetMass() float64 {
	log.Println("Calling RigidBody2D.GetMass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mass", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the body's moment of inertia. This is usually automatically computed from the mass and the shapes. Note that this doesn't seem to work in a [code]_ready[/code] function: it apparently has not been auto-computed yet.
*/
func (o *RigidBody2D) GetInertia() float64 {
	log.Println("Calling RigidBody2D.GetInertia()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_inertia", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the body's moment of inertia. This is like mass, but for rotation: it determines how much torque it takes to rotate the body. The moment of inertia is usually computed automatically from the mass and the shapes, but this function allows you to set a custom value. Set 0 (or negative) inertia to return to automatically computing it.
*/
func (o *RigidBody2D) SetInertia(inertia float64) {
	log.Println("Calling RigidBody2D.SetInertia()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(inertia)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_inertia", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the body weight given standard earth-weight (gravity 9.8). Not really useful for 2D since most measures for this node are in pixels.
*/
func (o *RigidBody2D) SetWeight(weight float64) {
	log.Println("Calling RigidBody2D.SetWeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(weight)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_weight", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the body weight given standard earth-weight (gravity 9.8).
*/
func (o *RigidBody2D) GetWeight() float64 {
	log.Println("Calling RigidBody2D.GetWeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_weight", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the body friction, from 0 (frictionless) to 1 (full friction).
*/
func (o *RigidBody2D) SetFriction(friction float64) {
	log.Println("Calling RigidBody2D.SetFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(friction)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_friction", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the body friction.
*/
func (o *RigidBody2D) GetFriction() float64 {
	log.Println("Calling RigidBody2D.GetFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_friction", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the body bounciness, from 0 (no bounce) to 1 (full bounce).
*/
func (o *RigidBody2D) SetBounce(bounce float64) {
	log.Println("Calling RigidBody2D.SetBounce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bounce)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bounce", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the body bounciness.
*/
func (o *RigidBody2D) GetBounce() float64 {
	log.Println("Calling RigidBody2D.GetBounce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bounce", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the gravity factor. This factor multiplies gravity intensity just for this body.
*/
func (o *RigidBody2D) SetGravityScale(gravityScale float64) {
	log.Println("Calling RigidBody2D.SetGravityScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(gravityScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the gravity factor.
*/
func (o *RigidBody2D) GetGravityScale() float64 {
	log.Println("Calling RigidBody2D.GetGravityScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gravity_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the linear damp for this body. If this value is different from -1, any linear damp derived from the world or areas will be overridden.
*/
func (o *RigidBody2D) SetLinearDamp(linearDamp float64) {
	log.Println("Calling RigidBody2D.SetLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(linearDamp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_linear_damp", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the linear damp for this body.
*/
func (o *RigidBody2D) GetLinearDamp() float64 {
	log.Println("Calling RigidBody2D.GetLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_linear_damp", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the angular damp for this body. If this value is different from -1, any angular damp derived from the world or areas will be overridden.
*/
func (o *RigidBody2D) SetAngularDamp(angularDamp float64) {
	log.Println("Calling RigidBody2D.SetAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(angularDamp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_angular_damp", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the angular damp for this body.
*/
func (o *RigidBody2D) GetAngularDamp() float64 {
	log.Println("Calling RigidBody2D.GetAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_angular_damp", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the body linear velocity. Can be used sporadically, but [b]DON'T SET THIS IN EVERY FRAME[/b], because physics may be running in another thread and definitely runs at a different granularity. Use [method _integrate_forces] as your process loop if you want to have precise control of the body state.
*/
func (o *RigidBody2D) SetLinearVelocity(linearVelocity *Vector2) {
	log.Println("Calling RigidBody2D.SetLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(linearVelocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_linear_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the body linear velocity. This changes by physics granularity. See [method set_linear_velocity].
*/
func (o *RigidBody2D) GetLinearVelocity() *Vector2 {
	log.Println("Calling RigidBody2D.GetLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_linear_velocity", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set the body angular velocity. Can be used sporadically, but [b]DON'T SET THIS IN EVERY FRAME[/b], because physics may be running in another thread and definitely runs at a different granularity. Use [method _integrate_forces] as your process loop if you want to have precise control of the body state.
*/
func (o *RigidBody2D) SetAngularVelocity(angularVelocity float64) {
	log.Println("Calling RigidBody2D.SetAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(angularVelocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_angular_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the body angular velocity. This changes by physics granularity. See [method set_angular_velocity].
*/
func (o *RigidBody2D) GetAngularVelocity() float64 {
	log.Println("Calling RigidBody2D.GetAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_angular_velocity", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the maximum contacts to report. Bodies can keep a log of the contacts with other bodies, this is enabled by setting the maximum amount of contacts reported to a number greater than 0.
*/
func (o *RigidBody2D) SetMaxContactsReported(amount int64) {
	log.Println("Calling RigidBody2D.SetMaxContactsReported()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_contacts_reported", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the maximum contacts that can be reported. See [method set_max_contacts_reported].
*/
func (o *RigidBody2D) GetMaxContactsReported() int64 {
	log.Println("Calling RigidBody2D.GetMaxContactsReported()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_max_contacts_reported", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Pass true to disable the internal force integration (like gravity or air friction) for this body. Other than collision response, the body will only move as determined by the [method _integrate_forces] function, if defined.
*/
func (o *RigidBody2D) SetUseCustomIntegrator(enable bool) {
	log.Println("Calling RigidBody2D.SetUseCustomIntegrator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_custom_integrator", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if the body is not doing any built-in force integration.
*/
func (o *RigidBody2D) IsUsingCustomIntegrator() bool {
	log.Println("Calling RigidBody2D.IsUsingCustomIntegrator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_using_custom_integrator", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Enable contact monitoring. This allows the body to emit signals when it collides with another.
*/
func (o *RigidBody2D) SetContactMonitor(enabled bool) {
	log.Println("Calling RigidBody2D.SetContactMonitor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_contact_monitor", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether contact monitoring is enabled.
*/
func (o *RigidBody2D) IsContactMonitorEnabled() bool {
	log.Println("Calling RigidBody2D.IsContactMonitorEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_contact_monitor_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the continuous collision detection mode from the enum CCD_MODE_*. Continuous collision detection tries to predict where a moving body will collide, instead of moving it and correcting its movement if it collided. The first is more precise, and misses less impacts by small, fast-moving objects. The second is faster to compute, but can miss small, fast-moving objects.
*/
func (o *RigidBody2D) SetContinuousCollisionDetectionMode(mode int64) {
	log.Println("Calling RigidBody2D.SetContinuousCollisionDetectionMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_continuous_collision_detection_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether this body is using continuous collision detection.
*/
func (o *RigidBody2D) GetContinuousCollisionDetectionMode() int64 {
	log.Println("Calling RigidBody2D.GetContinuousCollisionDetectionMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_continuous_collision_detection_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set an axis velocity. The velocity in the given vector axis will be set as the given vector length. This is useful for jumping behavior.
*/
func (o *RigidBody2D) SetAxisVelocity(axisVelocity *Vector2) {
	log.Println("Calling RigidBody2D.SetAxisVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(axisVelocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_axis_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Apply a positioned impulse (which will be affected by the body mass and shape). This is the equivalent of hitting a billiard ball with a cue: a force that is applied once, and only once. Both the impulse and the offset from the body origin are in global coordinates.
*/
func (o *RigidBody2D) ApplyImpulse(offset *Vector2, impulse *Vector2) {
	log.Println("Calling RigidBody2D.ApplyImpulse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(offset)
	goArguments[1] = reflect.ValueOf(impulse)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "apply_impulse", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the applied force vector. This is the equivalent of pushing a box over the ground: the force applied is applied constantly.
*/
func (o *RigidBody2D) SetAppliedForce(force *Vector2) {
	log.Println("Calling RigidBody2D.SetAppliedForce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(force)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_applied_force", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the applied force vector.
*/
func (o *RigidBody2D) GetAppliedForce() *Vector2 {
	log.Println("Calling RigidBody2D.GetAppliedForce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_applied_force", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set a constant torque which will be applied to this body.
*/
func (o *RigidBody2D) SetAppliedTorque(torque float64) {
	log.Println("Calling RigidBody2D.SetAppliedTorque()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(torque)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_applied_torque", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the torque which is being applied to this body.
*/
func (o *RigidBody2D) GetAppliedTorque() float64 {
	log.Println("Calling RigidBody2D.GetAppliedTorque()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_applied_torque", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Add a positioned force to the applied force and torque. As with [method apply_impulse], both the force and the offset from the body origin are in global coordinates.
*/
func (o *RigidBody2D) AddForce(offset *Vector2, force *Vector2) {
	log.Println("Calling RigidBody2D.AddForce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(offset)
	goArguments[1] = reflect.ValueOf(force)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_force", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether a body is sleeping or not. Sleeping bodies are not affected by forces until a collision or an [method apply_impulse] / [method set_applied_force] wakes them up. Until then, they behave like a static body.
*/
func (o *RigidBody2D) SetSleeping(sleeping bool) {
	log.Println("Calling RigidBody2D.SetSleeping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sleeping)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sleeping", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether the body is sleeping.
*/
func (o *RigidBody2D) IsSleeping() bool {
	log.Println("Calling RigidBody2D.IsSleeping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_sleeping", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the body ability to fall asleep when not moving. This saves an enormous amount of processor time when there are plenty of rigid bodies (non static) in a scene. Sleeping bodies are not affected by forces until a collision or an [method apply_impulse] / [method set_applied_force] wakes them up. Until then, they behave like a static body.
*/
func (o *RigidBody2D) SetCanSleep(ableToSleep bool) {
	log.Println("Calling RigidBody2D.SetCanSleep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ableToSleep)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_can_sleep", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if the body has the ability to fall asleep when not moving. See [method set_can_sleep].
*/
func (o *RigidBody2D) IsAbleToSleep() bool {
	log.Println("Calling RigidBody2D.IsAbleToSleep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_able_to_sleep", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return whether the body would collide, if it tried to move in the given vector. This method allows two extra parameters: A margin, which increases slightly the size of the shapes involved in the collision detection, and an object of type [Physics2DTestMotionResult], which will store additional information about the collision (should there be one).
*/
func (o *RigidBody2D) TestMotion(motion *Vector2, margin float64, result *Physics2DTestMotionResult) bool {
	log.Println("Calling RigidBody2D.TestMotion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(motion)
	goArguments[1] = reflect.ValueOf(margin)
	goArguments[2] = reflect.ValueOf(result)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "test_motion", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody2D) X_DirectStateChanged(arg0 *Object) {
	log.Println("Calling RigidBody2D.X_DirectStateChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_direct_state_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *RigidBody2D) X_BodyEnterTree(arg0 int64) {
	log.Println("Calling RigidBody2D.X_BodyEnterTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_body_enter_tree", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *RigidBody2D) X_BodyExitTree(arg0 int64) {
	log.Println("Calling RigidBody2D.X_BodyExitTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_body_exit_tree", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return a list of the bodies colliding with this one. By default, number of max contacts reported is at 0 , see [method set_max_contacts_reported] to increase it. You must also enable contact monitor, see [method set_contact_monitor]
*/
func (o *RigidBody2D) GetCollidingBodies() *Array {
	log.Println("Calling RigidBody2D.GetCollidingBodies()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_colliding_bodies", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   RigidBody2DImplementer is an interface for RigidBody2D objects.
*/
type RigidBody2DImplementer interface {
	Class
}

/*
   Kinematic bodies are special types of bodies that are meant to be user-controlled. They are not affected by physics at all (to other types of bodies, such a character or a rigid body, these are the same as a static body). They have however, two main uses: Simulated Motion: When these bodies are moved manually, either from code or from an AnimationPlayer (with process mode set to fixed), the physics will automatically compute an estimate of their linear and angular velocity. This makes them very useful for moving platforms or other AnimationPlayer-controlled objects (like a door, a bridge that opens, etc). Kinematic Characters: KinematicBody2D also has an api for moving objects (the [method move] method) while performing collision tests. This makes them really useful to implement characters that collide against a world, but that don't require advanced physics.
*/
type KinematicBody2D struct {
	PhysicsBody2D
}

func (o *KinematicBody2D) baseClass() string {
	return "KinematicBody2D"
}

/*
   Moves the body along the given vector. The body will stop if it collides. Returns a [KinematicCollision2D], which contains information about the colliding body.
*/
func (o *KinematicBody2D) MoveAndCollide(relVec *Vector2) *KinematicCollision2D {
	log.Println("Calling KinematicBody2D.MoveAndCollide()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(relVec)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "move_and_collide", goArguments, "*KinematicCollision2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*KinematicCollision2D)

	return returnValue

}

/*

 */
func (o *KinematicBody2D) MoveAndSlide(linearVelocity *Vector2, floorNormal *Vector2, slopeStopMinVelocity float64, maxBounces int64, floorMaxAngle float64) *Vector2 {
	log.Println("Calling KinematicBody2D.MoveAndSlide()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(linearVelocity)
	goArguments[1] = reflect.ValueOf(floorNormal)
	goArguments[2] = reflect.ValueOf(slopeStopMinVelocity)
	goArguments[3] = reflect.ValueOf(maxBounces)
	goArguments[4] = reflect.ValueOf(floorMaxAngle)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "move_and_slide", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Returns true if there would be a collision if the body moved from the given point in the given direction.
*/
func (o *KinematicBody2D) TestMove(from *Transform2D, relVec *Vector2) bool {
	log.Println("Calling KinematicBody2D.TestMove()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(relVec)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "test_move", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *KinematicBody2D) IsOnFloor() bool {
	log.Println("Calling KinematicBody2D.IsOnFloor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_on_floor", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *KinematicBody2D) IsOnCeiling() bool {
	log.Println("Calling KinematicBody2D.IsOnCeiling()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_on_ceiling", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *KinematicBody2D) IsOnWall() bool {
	log.Println("Calling KinematicBody2D.IsOnWall()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_on_wall", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *KinematicBody2D) GetFloorVelocity() *Vector2 {
	log.Println("Calling KinematicBody2D.GetFloorVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_floor_velocity", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *KinematicBody2D) SetSafeMargin(pixels float64) {
	log.Println("Calling KinematicBody2D.SetSafeMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pixels)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_safe_margin", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *KinematicBody2D) GetSafeMargin() float64 {
	log.Println("Calling KinematicBody2D.GetSafeMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_safe_margin", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *KinematicBody2D) GetSlideCount() int64 {
	log.Println("Calling KinematicBody2D.GetSlideCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_slide_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *KinematicBody2D) GetSlideCollision(slideIdx int64) *KinematicCollision2D {
	log.Println("Calling KinematicBody2D.GetSlideCollision()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(slideIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_slide_collision", goArguments, "*KinematicCollision2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*KinematicCollision2D)

	return returnValue

}

/*
   KinematicBody2DImplementer is an interface for KinematicBody2D objects.
*/
type KinematicBody2DImplementer interface {
	Class
}

/*
   Contains collision data for KinematicBody2D collisions. When a [KinematicBody2D] is moved using [method KinematicBody2D.move_and_collide], it stops if it detects a collision with another body. If a collision is detected, a KinematicCollision2D object is returned. This object contains information about the collision, including the colliding object, the remaining motion, and the collision position. This information can be used to calculate a collision response.
*/
type KinematicCollision2D struct {
	Reference
}

func (o *KinematicCollision2D) baseClass() string {
	return "KinematicCollision2D"
}

/*

 */
func (o *KinematicCollision2D) GetPosition() *Vector2 {
	log.Println("Calling KinematicCollision2D.GetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *KinematicCollision2D) GetNormal() *Vector2 {
	log.Println("Calling KinematicCollision2D.GetNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_normal", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *KinematicCollision2D) GetTravel() *Vector2 {
	log.Println("Calling KinematicCollision2D.GetTravel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_travel", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *KinematicCollision2D) GetRemainder() *Vector2 {
	log.Println("Calling KinematicCollision2D.GetRemainder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_remainder", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *KinematicCollision2D) GetLocalShape() *Object {
	log.Println("Calling KinematicCollision2D.GetLocalShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_local_shape", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*

 */
func (o *KinematicCollision2D) GetCollider() *Object {
	log.Println("Calling KinematicCollision2D.GetCollider()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*

 */
func (o *KinematicCollision2D) GetColliderId() int64 {
	log.Println("Calling KinematicCollision2D.GetColliderId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *KinematicCollision2D) GetColliderShape() *Object {
	log.Println("Calling KinematicCollision2D.GetColliderShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider_shape", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*

 */
func (o *KinematicCollision2D) GetColliderShapeIndex() int64 {
	log.Println("Calling KinematicCollision2D.GetColliderShapeIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider_shape_index", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *KinematicCollision2D) GetColliderVelocity() *Vector2 {
	log.Println("Calling KinematicCollision2D.GetColliderVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider_velocity", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *KinematicCollision2D) GetColliderMetadata() *Variant {
	log.Println("Calling KinematicCollision2D.GetColliderMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider_metadata", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   KinematicCollision2DImplementer is an interface for KinematicCollision2D objects.
*/
type KinematicCollision2DImplementer interface {
	Class
}

/*
   2D area that detects [CollisionObject2D] nodes overlapping, entering, or exiting. Can also alter or override local physics parameters (gravity, damping).
*/
type Area2D struct {
	CollisionObject2D
}

func (o *Area2D) baseClass() string {
	return "Area2D"
}

/*
   Undocumented
*/
func (o *Area2D) X_BodyEnterTree(id int64) {
	log.Println("Calling Area2D.X_BodyEnterTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_body_enter_tree", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Area2D) X_BodyExitTree(id int64) {
	log.Println("Calling Area2D.X_BodyExitTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_body_exit_tree", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Area2D) X_AreaEnterTree(id int64) {
	log.Println("Calling Area2D.X_AreaEnterTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_area_enter_tree", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Area2D) X_AreaExitTree(id int64) {
	log.Println("Calling Area2D.X_AreaExitTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_area_exit_tree", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the space override mode. This mode controls how an area affects gravity and damp. AREA_SPACE_OVERRIDE_DISABLED: This area does not affect gravity/damp. These are generally areas that exist only to detect collisions, and objects entering or exiting them. AREA_SPACE_OVERRIDE_COMBINE: This area adds its gravity/damp values to whatever has been calculated so far. This way, many overlapping areas can combine their physics to make interesting effects. AREA_SPACE_OVERRIDE_COMBINE_REPLACE: This area adds its gravity/damp values to whatever has been calculated so far. Then stops taking into account the rest of the areas, even the default one. AREA_SPACE_OVERRIDE_REPLACE: This area replaces any gravity/damp, even the default one, and stops taking into account the rest of the areas. AREA_SPACE_OVERRIDE_REPLACE_COMBINE: This area replaces any gravity/damp calculated so far, but keeps calculating the rest of the areas, down to the default one.
*/
func (o *Area2D) SetSpaceOverrideMode(spaceOverrideMode int64) {
	log.Println("Calling Area2D.SetSpaceOverrideMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(spaceOverrideMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_space_override_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the space override mode.
*/
func (o *Area2D) GetSpaceOverrideMode() int64 {
	log.Println("Calling Area2D.GetSpaceOverrideMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_space_override_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   When overriding space parameters, this method sets whether this area has a center of gravity. To set/get the location of the center of gravity, use [method set_gravity_vector]/[method get_gravity_vector].
*/
func (o *Area2D) SetGravityIsPoint(enable bool) {
	log.Println("Calling Area2D.SetGravityIsPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity_is_point", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether gravity is a point. A point gravity will attract objects towards it, as opposed to a gravity vector, which moves them in a given direction.
*/
func (o *Area2D) IsGravityAPoint() bool {
	log.Println("Calling Area2D.IsGravityAPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_gravity_a_point", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the falloff factor for point gravity. The greater this value is, the faster the strength of gravity decreases with the square of distance.
*/
func (o *Area2D) SetGravityDistanceScale(distanceScale float64) {
	log.Println("Calling Area2D.SetGravityDistanceScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(distanceScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity_distance_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the falloff factor for point gravity.
*/
func (o *Area2D) GetGravityDistanceScale() float64 {
	log.Println("Calling Area2D.GetGravityDistanceScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gravity_distance_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the gravity vector. This vector does not have to be normalized. If gravity is a point (see [method is_gravity_a_point]), this will be the attraction center.
*/
func (o *Area2D) SetGravityVector(vector *Vector2) {
	log.Println("Calling Area2D.SetGravityVector()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vector)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity_vector", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the gravity vector. If gravity is a point (see [method is_gravity_a_point]), this will be the attraction center.
*/
func (o *Area2D) GetGravityVector() *Vector2 {
	log.Println("Calling Area2D.GetGravityVector()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gravity_vector", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set the gravity intensity. This is useful to alter the force of gravity without altering its direction. This value multiplies the gravity vector, whether it is the given vector ([method set_gravity_vector]), or a calculated one (when using a center of gravity).
*/
func (o *Area2D) SetGravity(gravity float64) {
	log.Println("Calling Area2D.SetGravity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(gravity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the gravity intensity.
*/
func (o *Area2D) GetGravity() float64 {
	log.Println("Calling Area2D.GetGravity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gravity", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the rate at which objects stop moving in this area, if there are not any other forces moving it. The value is a fraction of its current speed, lost per second. Thus, a value of 1.0 should mean stopping immediately, and 0.0 means the object never stops. In practice, as the fraction of speed lost gets smaller with each frame, a value of 1.0 does not mean the object will stop in exactly one second. Only when the physics calculations are done at 1 frame per second, it does stop in a second.
*/
func (o *Area2D) SetLinearDamp(linearDamp float64) {
	log.Println("Calling Area2D.SetLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(linearDamp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_linear_damp", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the linear damp rate.
*/
func (o *Area2D) GetLinearDamp() float64 {
	log.Println("Calling Area2D.GetLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_linear_damp", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the rate at which objects stop spinning in this area, if there are not any other forces making it spin. The value is a fraction of its current speed, lost per second. Thus, a value of 1.0 should mean stopping immediately, and 0.0 means the object never stops. In practice, as the fraction of speed lost gets smaller with each frame, a value of 1.0 does not mean the object will stop in exactly one second. Only when the physics calculations are done at 1 frame per second, it does stop in a second.
*/
func (o *Area2D) SetAngularDamp(angularDamp float64) {
	log.Println("Calling Area2D.SetAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(angularDamp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_angular_damp", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the angular damp rate.
*/
func (o *Area2D) GetAngularDamp() float64 {
	log.Println("Calling Area2D.GetAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_angular_damp", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the order in which the area is processed. Greater values mean the area gets processed first. This is useful for areas which have a space override different from AREA_SPACE_OVERRIDE_DISABLED or AREA_SPACE_OVERRIDE_COMBINE, as they replace values, and are thus order-dependent. Areas with the same priority value get evaluated in an unpredictable order, and should be differentiated if evaluation order is to be important.
*/
func (o *Area2D) SetPriority(priority float64) {
	log.Println("Calling Area2D.SetPriority()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(priority)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_priority", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the processing order of this area.
*/
func (o *Area2D) GetPriority() float64 {
	log.Println("Calling Area2D.GetPriority()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_priority", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the physics layers this area can scan for collisions.
*/
func (o *Area2D) SetCollisionMask(collisionMask int64) {
	log.Println("Calling Area2D.SetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collisionMask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the physics layers this area will scan to determine collisions.
*/
func (o *Area2D) GetCollisionMask() int64 {
	log.Println("Calling Area2D.GetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the physics layers this area is in. Collidable objects can exist in any of 32 different layers. These layers are not visual, but more of a tagging system instead. A collidable can use these layers/tags to select with which objects it can collide, using [method set_collision_mask]. A contact is detected if object A is in any of the layers that object B scans, or object B is in any layer scanned by object A.
*/
func (o *Area2D) SetCollisionLayer(collisionLayer int64) {
	log.Println("Calling Area2D.SetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collisionLayer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the physics layer this area is in.
*/
func (o *Area2D) GetCollisionLayer() int64 {
	log.Println("Calling Area2D.GetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set/clear individual bits on the collision mask. This makes selecting the areas scanned easier.
*/
func (o *Area2D) SetCollisionMaskBit(bit int64, value bool) {
	log.Println("Calling Area2D.SetCollisionMaskBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(bit)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_mask_bit", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return an individual bit on the collision mask. Describes whether this area will collide with others on the given layer.
*/
func (o *Area2D) GetCollisionMaskBit(bit int64) bool {
	log.Println("Calling Area2D.GetCollisionMaskBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bit)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_mask_bit", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set/clear individual bits on the layer mask. This makes getting an area in/out of only one layer easier.
*/
func (o *Area2D) SetCollisionLayerBit(bit int64, value bool) {
	log.Println("Calling Area2D.SetCollisionLayerBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(bit)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer_bit", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return an individual bit on the layer mask. Describes whether other areas will collide with this one on the given layer.
*/
func (o *Area2D) GetCollisionLayerBit(bit int64) bool {
	log.Println("Calling Area2D.GetCollisionLayerBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bit)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer_bit", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set whether this area can detect bodies/areas entering/exiting it.
*/
func (o *Area2D) SetMonitoring(enable bool) {
	log.Println("Calling Area2D.SetMonitoring()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_monitoring", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether this area detects bodies/areas entering/exiting it.
*/
func (o *Area2D) IsMonitoring() bool {
	log.Println("Calling Area2D.IsMonitoring()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_monitoring", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set whether this area can be detected by other, monitoring, areas. Only areas need to be marked as monitorable. Bodies are always so.
*/
func (o *Area2D) SetMonitorable(enable bool) {
	log.Println("Calling Area2D.SetMonitorable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_monitorable", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether this area can be detected by other, monitoring, areas.
*/
func (o *Area2D) IsMonitorable() bool {
	log.Println("Calling Area2D.IsMonitorable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_monitorable", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns a list of intersecting [PhysicsBody2D]\ s.
*/
func (o *Area2D) GetOverlappingBodies() *Array {
	log.Println("Calling Area2D.GetOverlappingBodies()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_overlapping_bodies", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Returns a list of intersecting [Area2D]\ s.
*/
func (o *Area2D) GetOverlappingAreas() *Array {
	log.Println("Calling Area2D.GetOverlappingAreas()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_overlapping_areas", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   If [code]true[/code] the given body overlaps the Area2D.
*/
func (o *Area2D) OverlapsBody(body *Object) bool {
	log.Println("Calling Area2D.OverlapsBody()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "overlaps_body", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   If [code]true[/code] the given area overlaps the Area2D.
*/
func (o *Area2D) OverlapsArea(area *Object) bool {
	log.Println("Calling Area2D.OverlapsArea()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "overlaps_area", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Area2D) SetAudioBusName(name string) {
	log.Println("Calling Area2D.SetAudioBusName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_audio_bus_name", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Area2D) GetAudioBusName() string {
	log.Println("Calling Area2D.GetAudioBusName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_audio_bus_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *Area2D) SetAudioBusOverride(enable bool) {
	log.Println("Calling Area2D.SetAudioBusOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_audio_bus_override", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Area2D) IsOverridingAudioBus() bool {
	log.Println("Calling Area2D.IsOverridingAudioBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_overriding_audio_bus", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area2D) X_BodyInout(arg0 int64, arg1 *RID, arg2 int64, arg3 int64, arg4 int64) {
	log.Println("Calling Area2D.X_BodyInout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(arg0)
	goArguments[1] = reflect.ValueOf(arg1)
	goArguments[2] = reflect.ValueOf(arg2)
	goArguments[3] = reflect.ValueOf(arg3)
	goArguments[4] = reflect.ValueOf(arg4)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_body_inout", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Area2D) X_AreaInout(arg0 int64, arg1 *RID, arg2 int64, arg3 int64, arg4 int64) {
	log.Println("Calling Area2D.X_AreaInout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(arg0)
	goArguments[1] = reflect.ValueOf(arg1)
	goArguments[2] = reflect.ValueOf(arg2)
	goArguments[3] = reflect.ValueOf(arg3)
	goArguments[4] = reflect.ValueOf(arg4)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_area_inout", goArguments, "")

	log.Println("Got return value!")

}

/*
   Area2DImplementer is an interface for Area2D objects.
*/
type Area2DImplementer interface {
	Class
}

/*
   Editor facility for creating and editing collision shapes in 2D space. You can use this node to represent all sorts of collision shapes, for example, add this to an [Area2D] to give it a detection shape, or add it to a [PhysicsBody2D] to give create solid object. [b]IMPORTANT[/b]: this is an Editor-only helper to create shapes, use [method get_shape] to get the actual shape.
*/
type CollisionShape2D struct {
	Node2D
}

func (o *CollisionShape2D) baseClass() string {
	return "CollisionShape2D"
}

/*

 */
func (o *CollisionShape2D) SetShape(shape *Shape2D) {
	log.Println("Calling CollisionShape2D.SetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionShape2D) GetShape() *Shape2D {
	log.Println("Calling CollisionShape2D.GetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shape", goArguments, "*Shape2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Shape2D)

	return returnValue

}

/*

 */
func (o *CollisionShape2D) SetDisabled(disabled bool) {
	log.Println("Calling CollisionShape2D.SetDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(disabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionShape2D) IsDisabled() bool {
	log.Println("Calling CollisionShape2D.IsDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_disabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *CollisionShape2D) SetOneWayCollision(enabled bool) {
	log.Println("Calling CollisionShape2D.SetOneWayCollision()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_one_way_collision", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionShape2D) IsOneWayCollisionEnabled() bool {
	log.Println("Calling CollisionShape2D.IsOneWayCollisionEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_one_way_collision_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *CollisionShape2D) X_ShapeChanged() {
	log.Println("Calling CollisionShape2D.X_ShapeChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_shape_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   CollisionShape2DImplementer is an interface for CollisionShape2D objects.
*/
type CollisionShape2DImplementer interface {
	Class
}

/*
   Base class for all 2D Shapes. All 2D shape types inherit from this.
*/
type Shape2D struct {
	Resource
}

func (o *Shape2D) baseClass() string {
	return "Shape2D"
}

/*
   Use a custom solver bias. No need to change this unless you really know what you are doing. The solver bias is a factor controlling how much two objects "rebound" off each other, when colliding, to avoid them getting into each other because of numerical imprecision.
*/
func (o *Shape2D) SetCustomSolverBias(bias float64) {
	log.Println("Calling Shape2D.SetCustomSolverBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bias)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_solver_bias", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the custom solver bias.
*/
func (o *Shape2D) GetCustomSolverBias() float64 {
	log.Println("Calling Shape2D.GetCustomSolverBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_custom_solver_bias", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return whether this shape is colliding with another. This method needs the transformation matrix for this shape ([code]local_xform[/code]), the shape to check collisions with ([code]with_shape[/code]), and the transformation matrix of that shape ([code]shape_xform[/code]).
*/
func (o *Shape2D) Collide(localXform *Transform2D, withShape *Shape2D, shapeXform *Transform2D) bool {
	log.Println("Calling Shape2D.Collide()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(localXform)
	goArguments[1] = reflect.ValueOf(withShape)
	goArguments[2] = reflect.ValueOf(shapeXform)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "collide", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return whether this shape would collide with another, if a given movement was applied. This method needs the transformation matrix for this shape ([code]local_xform[/code]), the movement to test on this shape ([code]local_motion[/code]), the shape to check collisions with ([code]with_shape[/code]), the transformation matrix of that shape ([code]shape_xform[/code]), and the movement to test onto the other object ([code]shape_motion[/code]).
*/
func (o *Shape2D) CollideWithMotion(localXform *Transform2D, localMotion *Vector2, withShape *Shape2D, shapeXform *Transform2D, shapeMotion *Vector2) bool {
	log.Println("Calling Shape2D.CollideWithMotion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(localXform)
	goArguments[1] = reflect.ValueOf(localMotion)
	goArguments[2] = reflect.ValueOf(withShape)
	goArguments[3] = reflect.ValueOf(shapeXform)
	goArguments[4] = reflect.ValueOf(shapeMotion)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "collide_with_motion", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return a list of the points where this shape touches another. If there are no collisions, the list is empty. This method needs the transformation matrix for this shape ([code]local_xform[/code]), the shape to check collisions with ([code]with_shape[/code]), and the transformation matrix of that shape ([code]shape_xform[/code]).
*/
func (o *Shape2D) CollideAndGetContacts(localXform *Transform2D, withShape *Shape2D, shapeXform *Transform2D) *Variant {
	log.Println("Calling Shape2D.CollideAndGetContacts()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(localXform)
	goArguments[1] = reflect.ValueOf(withShape)
	goArguments[2] = reflect.ValueOf(shapeXform)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "collide_and_get_contacts", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Return a list of the points where this shape would touch another, if a given movement was applied. If there are no collisions, the list is empty. This method needs the transformation matrix for this shape ([code]local_xform[/code]), the movement to test on this shape ([code]local_motion[/code]), the shape to check collisions with ([code]with_shape[/code]), the transformation matrix of that shape ([code]shape_xform[/code]), and the movement to test onto the other object ([code]shape_motion[/code]).
*/
func (o *Shape2D) CollideWithMotionAndGetContacts(localXform *Transform2D, localMotion *Vector2, withShape *Shape2D, shapeXform *Transform2D, shapeMotion *Vector2) *Variant {
	log.Println("Calling Shape2D.CollideWithMotionAndGetContacts()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(localXform)
	goArguments[1] = reflect.ValueOf(localMotion)
	goArguments[2] = reflect.ValueOf(withShape)
	goArguments[3] = reflect.ValueOf(shapeXform)
	goArguments[4] = reflect.ValueOf(shapeMotion)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "collide_with_motion_and_get_contacts", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Shape2DImplementer is an interface for Shape2D objects.
*/
type Shape2DImplementer interface {
	Class
}

/*
   Allows editing a collision polygon's vertices. This class is only available in the editor. It will not appear in the scene tree at runtime. Creates a [Shape2D] for gameplay. Properties modified during gameplay will have no effect.
*/
type CollisionPolygon2D struct {
	Node2D
}

func (o *CollisionPolygon2D) baseClass() string {
	return "CollisionPolygon2D"
}

/*
   Set the array of points forming the polygon. When editing the point list via the editor, depending on [method get_build_mode], it has to be a list of points (for [code]build_mode==0[/code]), or a list of lines (for [code]build_mode==1[/code]). In the second case, the even elements of the array define the start point of the line, and the odd elements the end point.
*/
func (o *CollisionPolygon2D) SetPolygon(polygon *PoolVector2Array) {
	log.Println("Calling CollisionPolygon2D.SetPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(polygon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_polygon", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the list of points that define the polygon.
*/
func (o *CollisionPolygon2D) GetPolygon() *PoolVector2Array {
	log.Println("Calling CollisionPolygon2D.GetPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_polygon", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*
   Set whether the polygon is to be a [ConvexPolygonShape2D] ([code]build_mode==0[/code]), or a [ConcavePolygonShape2D] ([code]build_mode==1[/code]).
*/
func (o *CollisionPolygon2D) SetBuildMode(buildMode int64) {
	log.Println("Calling CollisionPolygon2D.SetBuildMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(buildMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_build_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether the polygon is a [ConvexPolygonShape2D] ([code]build_mode==0[/code]), or a [ConcavePolygonShape2D] ([code]build_mode==1[/code]).
*/
func (o *CollisionPolygon2D) GetBuildMode() int64 {
	log.Println("Calling CollisionPolygon2D.GetBuildMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_build_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CollisionPolygon2D) SetDisabled(disabled bool) {
	log.Println("Calling CollisionPolygon2D.SetDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(disabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionPolygon2D) IsDisabled() bool {
	log.Println("Calling CollisionPolygon2D.IsDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_disabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *CollisionPolygon2D) SetOneWayCollision(enabled bool) {
	log.Println("Calling CollisionPolygon2D.SetOneWayCollision()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_one_way_collision", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionPolygon2D) IsOneWayCollisionEnabled() bool {
	log.Println("Calling CollisionPolygon2D.IsOneWayCollisionEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_one_way_collision_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   CollisionPolygon2DImplementer is an interface for CollisionPolygon2D objects.
*/
type CollisionPolygon2DImplementer interface {
	Class
}

/*
   A RayCast represents a line from its origin to its destination position, [code]cast_to[/code]. It is used to query the 2D space in order to find the closest object along the path of the ray. RayCast2D can ignore some objects by adding them to the exception list via [code]add_exception[/code], by setting proper filtering with collision layers, or by filtering object types with type masks. Only enabled raycasts will be able to query the space and report collisions. RayCast2D calculates intersection every fixed frame (see [Node]), and the result is cached so it can be used later until the next frame. If multiple queries are required between fixed frames (or during the same frame) use [method force_raycast_update] after adjusting the raycast.
*/
type RayCast2D struct {
	Node2D
}

func (o *RayCast2D) baseClass() string {
	return "RayCast2D"
}

/*
   Enables the RayCast2D. Only enabled raycasts will be able to query the space and report collisions.
*/
func (o *RayCast2D) SetEnabled(enabled bool) {
	log.Println("Calling RayCast2D.SetEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether this raycast is enabled or not.
*/
func (o *RayCast2D) IsEnabled() bool {
	log.Println("Calling RayCast2D.IsEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Sets the ray destination point, so that the ray will test from the ray's origin to [code]local_point[/code]
*/
func (o *RayCast2D) SetCastTo(localPoint *Vector2) {
	log.Println("Calling RayCast2D.SetCastTo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(localPoint)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cast_to", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the destination point of this ray object.
*/
func (o *RayCast2D) GetCastTo() *Vector2 {
	log.Println("Calling RayCast2D.GetCastTo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cast_to", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return whether the closest object the ray is pointing to is colliding with the vector (considering the vector length).
*/
func (o *RayCast2D) IsColliding() bool {
	log.Println("Calling RayCast2D.IsColliding()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_colliding", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Updates the collision information for the ray. Use this method to update the collision information immediately instead of waiting for the next [code]_fixed_process[/code] call, for example if the ray or its parent has changed state. Note: [code]enabled == true[/code] is not required for this to work.
*/
func (o *RayCast2D) ForceRaycastUpdate() {
	log.Println("Calling RayCast2D.ForceRaycastUpdate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "force_raycast_update", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the closest object the ray is pointing to. Note that this does not consider the length of the ray, so you must also use [method is_colliding] to check if the object returned is actually colliding with the ray. Example: [codeblock] if RayCast2D.is_colliding(): var collider = RayCast2D.get_collider() [/codeblock]
*/
func (o *RayCast2D) GetCollider() *Object {
	log.Println("Calling RayCast2D.GetCollider()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*
   Returns the collision shape of the closest object the ray is pointing to. Note that this does not consider the length of the ray, so you must also use [method is_colliding] to check if the object returned is actually colliding with the ray. Example: [codeblock] if RayCast2D.is_colliding(): var shape = RayCast2D.get_collider_shape() [/codeblock]
*/
func (o *RayCast2D) GetColliderShape() int64 {
	log.Println("Calling RayCast2D.GetColliderShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider_shape", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the collision point at which the ray intersects the closest object. Note: this point is in the [b]global[/b] coordinate system.
*/
func (o *RayCast2D) GetCollisionPoint() *Vector2 {
	log.Println("Calling RayCast2D.GetCollisionPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_point", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Returns the normal of the intersecting object's shape at the collision point.
*/
func (o *RayCast2D) GetCollisionNormal() *Vector2 {
	log.Println("Calling RayCast2D.GetCollisionNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_normal", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Adds a collision exception so the ray does not report collisions with the specified [RID].
*/
func (o *RayCast2D) AddExceptionRid(rid *RID) {
	log.Println("Calling RayCast2D.AddExceptionRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rid)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_exception_rid", goArguments, "")

	log.Println("Got return value!")

}

/*
   Adds a collision exception so the ray does not report collisions with the specified node.
*/
func (o *RayCast2D) AddException(node *Object) {
	log.Println("Calling RayCast2D.AddException()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_exception", goArguments, "")

	log.Println("Got return value!")

}

/*
   Removes a collision exception so the ray does report collisions with the specified [RID].
*/
func (o *RayCast2D) RemoveExceptionRid(rid *RID) {
	log.Println("Calling RayCast2D.RemoveExceptionRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rid)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_exception_rid", goArguments, "")

	log.Println("Got return value!")

}

/*
   Removes a collision exception so the ray does report collisions with the specified node.
*/
func (o *RayCast2D) RemoveException(node *Object) {
	log.Println("Calling RayCast2D.RemoveException()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_exception", goArguments, "")

	log.Println("Got return value!")

}

/*
   Removes all collision exceptions for this ray.
*/
func (o *RayCast2D) ClearExceptions() {
	log.Println("Calling RayCast2D.ClearExceptions()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_exceptions", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the mask to filter objects. Only objects with at least the same mask element set will be detected.
*/
func (o *RayCast2D) SetCollisionLayer(layer int64) {
	log.Println("Calling RayCast2D.SetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the collision layer for this ray.
*/
func (o *RayCast2D) GetCollisionLayer() int64 {
	log.Println("Calling RayCast2D.GetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the types of objects to detect. For [code]mask[/code] use a logic sum (OR operation) of constants defined in [Physics2DDirectSpaceState], eg. [code]Physics2DDirectSpaceState.TYPE_MASK_STATIC_BODY | Physics2DDirectSpaceState.TYPE_MASK_KINEMATIC_BODY[/code] to detect only those two types.
*/
func (o *RayCast2D) SetTypeMask(mask int64) {
	log.Println("Calling RayCast2D.SetTypeMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_type_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the type mask (types of objects to detect) for this ray. The value is a sum (bitwise OR'd) of constants available for [Physics2DDirectSpaceState].
*/
func (o *RayCast2D) GetTypeMask() int64 {
	log.Println("Calling RayCast2D.GetTypeMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_type_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Toggle whether this ray should hit your parent node, if it's a body.
*/
func (o *RayCast2D) SetExcludeParentBody(mask bool) {
	log.Println("Calling RayCast2D.SetExcludeParentBody()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_exclude_parent_body", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether this ray should hit your parent node, if it's a body.
*/
func (o *RayCast2D) GetExcludeParentBody() bool {
	log.Println("Calling RayCast2D.GetExcludeParentBody()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_exclude_parent_body", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   RayCast2DImplementer is an interface for RayCast2D objects.
*/
type RayCast2DImplementer interface {
	Class
}

/*
   The VisibilityNotifier2D detects when it is visible on the screen. It also notifies when its bounding rectangle enters or exits the screen or a viewport.
*/
type VisibilityNotifier2D struct {
	Node2D
}

func (o *VisibilityNotifier2D) baseClass() string {
	return "VisibilityNotifier2D"
}

/*
   Set the visibility bounding rectangle of the VisibilityNotifier2D.
*/
func (o *VisibilityNotifier2D) SetRect(rect *Rect2) {
	log.Println("Calling VisibilityNotifier2D.SetRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rect)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rect", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the bounding rectangle of the VisibilityNotifier2D.
*/
func (o *VisibilityNotifier2D) GetRect() *Rect2 {
	log.Println("Calling VisibilityNotifier2D.GetRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   If [code]true[/code] the bounding rectangle is on the screen.
*/
func (o *VisibilityNotifier2D) IsOnScreen() bool {
	log.Println("Calling VisibilityNotifier2D.IsOnScreen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_on_screen", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   VisibilityNotifier2DImplementer is an interface for VisibilityNotifier2D objects.
*/
type VisibilityNotifier2DImplementer interface {
	Class
}

/*
   The VisibilityEnabler2D will disable [RigidBody2D], [AnimationPlayer], and other nodes when they are not visible. It will only affect other nodes within the same scene as the VisibilityEnabler2D itself.
*/
type VisibilityEnabler2D struct {
	VisibilityNotifier2D
}

func (o *VisibilityEnabler2D) baseClass() string {
	return "VisibilityEnabler2D"
}

/*
   Set an enabler to true for all nodes of its type to be disabled when the VisibilityEnabler2D is not in view. See the constants for enablers and what they affect.
*/
func (o *VisibilityEnabler2D) SetEnabler(enabler int64, enabled bool) {
	log.Println("Calling VisibilityEnabler2D.SetEnabler()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(enabler)
	goArguments[1] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enabler", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether the specified enabler was set to true or not.
*/
func (o *VisibilityEnabler2D) IsEnablerEnabled(enabler int64) bool {
	log.Println("Calling VisibilityEnabler2D.IsEnablerEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabler)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_enabler_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisibilityEnabler2D) X_NodeRemoved(arg0 *Object) {
	log.Println("Calling VisibilityEnabler2D.X_NodeRemoved()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_node_removed", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisibilityEnabler2DImplementer is an interface for VisibilityEnabler2D objects.
*/
type VisibilityEnabler2DImplementer interface {
	Class
}

/*
   A Polygon2D is defined by a set of n vertices connected together by line segments, meaning that the vertex 1 will be connected with vertex 2, vertex 2 with vertex 3 ..., vertex n-1 with vertex n and vertex n with vertex 1 in order to close the loop and define a polygon.
*/
type Polygon2D struct {
	Node2D
}

func (o *Polygon2D) baseClass() string {
	return "Polygon2D"
}

/*
   Define the set of vertices that will represent the polygon.
*/
func (o *Polygon2D) SetPolygon(polygon *PoolVector2Array) {
	log.Println("Calling Polygon2D.SetPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(polygon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_polygon", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the set of vertices that defines this polygon.
*/
func (o *Polygon2D) GetPolygon() *PoolVector2Array {
	log.Println("Calling Polygon2D.GetPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_polygon", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*
   Set the texture coordinates for every vertex of the polygon. There should be one uv vertex for every vertex in the polygon. If there are less, the undefined ones will be assumed to be (0,0). Extra uv vertices are ignored.
*/
func (o *Polygon2D) SetUv(uv *PoolVector2Array) {
	log.Println("Calling Polygon2D.SetUv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(uv)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_uv", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the texture coordinates associated with every vertex of the polygon.
*/
func (o *Polygon2D) GetUv() *PoolVector2Array {
	log.Println("Calling Polygon2D.GetUv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_uv", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*
   Set the polygon fill color. If the polygon has a texture defined, the defined texture will be multiplied by the polygon fill color. This, also, is the default color for those vertices that are not defined by [method get_vertex_colors].
*/
func (o *Polygon2D) SetColor(color *Color) {
	log.Println("Calling Polygon2D.SetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_color", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the polygon fill color.
*/
func (o *Polygon2D) GetColor() *Color {
	log.Println("Calling Polygon2D.GetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Set the color for each vertex of the polygon. There should be one color for every vertex in the polygon. If there are less, the undefined ones will be assumed to be [method get_color]. Extra color entries are ignored. Colors are interpolated between vertices, resulting in smooth gradients when they differ.
*/
func (o *Polygon2D) SetVertexColors(vertexColors *PoolColorArray) {
	log.Println("Calling Polygon2D.SetVertexColors()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vertexColors)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vertex_colors", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the list of vertex colors.
*/
func (o *Polygon2D) GetVertexColors() *PoolColorArray {
	log.Println("Calling Polygon2D.GetVertexColors()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertex_colors", goArguments, "*PoolColorArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolColorArray)

	return returnValue

}

/*

 */
func (o *Polygon2D) SetTexture(texture *Texture) {
	log.Println("Calling Polygon2D.SetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the polygon texture
*/
func (o *Polygon2D) GetTexture() *Texture {
	log.Println("Calling Polygon2D.GetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   Set the offset of the polygon texture. Initially the texture will appear anchored to the polygon position, the offset is used to move the texture location away from that point (notice that the texture origin is set to its top left corner, so when offset is 0,0 the top left corner of the texture is at the polygon position), for example setting the offset to 10, 10 will move the texture 10 units to the left and 10 units to the top.
*/
func (o *Polygon2D) SetTextureOffset(textureOffset *Vector2) {
	log.Println("Calling Polygon2D.SetTextureOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(textureOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the polygon texture offset.
*/
func (o *Polygon2D) GetTextureOffset() *Vector2 {
	log.Println("Calling Polygon2D.GetTextureOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set the amount of rotation of the polygon texture, [code]texture_rotation[/code] is specified in radians and clockwise rotation.
*/
func (o *Polygon2D) SetTextureRotation(textureRotation float64) {
	log.Println("Calling Polygon2D.SetTextureRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(textureRotation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture_rotation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the rotation in radians of the texture polygon.
*/
func (o *Polygon2D) GetTextureRotation() float64 {
	log.Println("Calling Polygon2D.GetTextureRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture_rotation", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Undocumented
*/
func (o *Polygon2D) X_SetTextureRotationd(textureRotation float64) {
	log.Println("Calling Polygon2D.X_SetTextureRotationd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(textureRotation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_texture_rotationd", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Polygon2D) X_GetTextureRotationd() float64 {
	log.Println("Calling Polygon2D.X_GetTextureRotationd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_texture_rotationd", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the value that will multiply the uv coordinates ([method get_uv]) when applying the texture. Larger values make the texture smaller, and vice versa.
*/
func (o *Polygon2D) SetTextureScale(textureScale *Vector2) {
	log.Println("Calling Polygon2D.SetTextureScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(textureScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the uv coordinate multiplier.
*/
func (o *Polygon2D) GetTextureScale() *Vector2 {
	log.Println("Calling Polygon2D.GetTextureScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture_scale", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set the polygon as the defined polygon bounding box minus the defined polygon (the defined polygon will appear as a hole on the square that contains the defined polygon).
*/
func (o *Polygon2D) SetInvert(invert bool) {
	log.Println("Calling Polygon2D.SetInvert()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(invert)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_invert", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether this polygon is inverted or not.
*/
func (o *Polygon2D) GetInvert() bool {
	log.Println("Calling Polygon2D.GetInvert()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_invert", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Polygon2D) SetAntialiased(antialiased bool) {
	log.Println("Calling Polygon2D.SetAntialiased()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(antialiased)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_antialiased", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Polygon2D) GetAntialiased() bool {
	log.Println("Calling Polygon2D.GetAntialiased()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_antialiased", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Add extra padding around the bounding box, making it bigger. Too small a value can make the polygon triangulate strangely, due to numerical imprecision.
*/
func (o *Polygon2D) SetInvertBorder(invertBorder float64) {
	log.Println("Calling Polygon2D.SetInvertBorder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(invertBorder)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_invert_border", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the added padding around the bounding box.
*/
func (o *Polygon2D) GetInvertBorder() float64 {
	log.Println("Calling Polygon2D.GetInvertBorder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_invert_border", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the an offset that will be added to the vertices' position. E.g. if the offset is set to (10,10) then all the polygon points will move 10 units to the right and 10 units to the bottom.
*/
func (o *Polygon2D) SetOffset(offset *Vector2) {
	log.Println("Calling Polygon2D.SetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the offset for the polygon vertices.
*/
func (o *Polygon2D) GetOffset() *Vector2 {
	log.Println("Calling Polygon2D.GetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Polygon2DImplementer is an interface for Polygon2D objects.
*/
type Polygon2DImplementer interface {
	Class
}

/*
   Node that casts light in a 2D environment. Light is defined by a (usually grayscale) texture, a color, an energy value, a mode (see constants), and various other parameters (range and shadows-related). Note that Light2D can be used as a mask.
*/
type Light2D struct {
	Node2D
}

func (o *Light2D) baseClass() string {
	return "Light2D"
}

/*
   Switches the Light2D on or off, depending on the 'enabled' parameter.
*/
func (o *Light2D) SetEnabled(enabled bool) {
	log.Println("Calling Light2D.SetEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if the Light2D is enabled, false if it is not.
*/
func (o *Light2D) IsEnabled() bool {
	log.Println("Calling Light2D.IsEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Light2D) SetEditorOnly(editorOnly bool) {
	log.Println("Calling Light2D.SetEditorOnly()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(editorOnly)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_editor_only", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Light2D) IsEditorOnly() bool {
	log.Println("Calling Light2D.IsEditorOnly()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_editor_only", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the texture of the Light2D.
*/
func (o *Light2D) SetTexture(texture *Texture) {
	log.Println("Calling Light2D.SetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the texture of the Light2D.
*/
func (o *Light2D) GetTexture() *Texture {
	log.Println("Calling Light2D.GetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   Set the offset of the light texture.
*/
func (o *Light2D) SetTextureOffset(textureOffset *Vector2) {
	log.Println("Calling Light2D.SetTextureOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(textureOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the offset of the light texture.
*/
func (o *Light2D) GetTextureOffset() *Vector2 {
	log.Println("Calling Light2D.GetTextureOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set the color of the Light2D.
*/
func (o *Light2D) SetColor(color *Color) {
	log.Println("Calling Light2D.SetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_color", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the color of the Light2D.
*/
func (o *Light2D) GetColor() *Color {
	log.Println("Calling Light2D.GetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Set the height of the Light2D. Used with 2D normalmapping.
*/
func (o *Light2D) SetHeight(height float64) {
	log.Println("Calling Light2D.SetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(height)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_height", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the height of the Light2D. Used with 2D normalmapping.
*/
func (o *Light2D) GetHeight() float64 {
	log.Println("Calling Light2D.GetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_height", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the energy value of the Light2D. The bigger the value, the stronger the light.
*/
func (o *Light2D) SetEnergy(energy float64) {
	log.Println("Calling Light2D.SetEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(energy)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_energy", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the energy value of the Light2D.
*/
func (o *Light2D) GetEnergy() float64 {
	log.Println("Calling Light2D.GetEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_energy", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the scale value of the light texture.
*/
func (o *Light2D) SetTextureScale(textureScale float64) {
	log.Println("Calling Light2D.SetTextureScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(textureScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the scale value of the light texture.
*/
func (o *Light2D) GetTextureScale() float64 {
	log.Println("Calling Light2D.GetTextureScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the minimum Z value that objects of the scene have to be in order to be affected by the Light2D.
*/
func (o *Light2D) SetZRangeMin(z int64) {
	log.Println("Calling Light2D.SetZRangeMin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(z)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_z_range_min", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the minimum Z value that objects of the scene have to be in order to be affected by the Light2D.
*/
func (o *Light2D) GetZRangeMin() int64 {
	log.Println("Calling Light2D.GetZRangeMin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_z_range_min", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the maximum Z value that objects of the scene can be in order to be affected by the Light2D.
*/
func (o *Light2D) SetZRangeMax(z int64) {
	log.Println("Calling Light2D.SetZRangeMax()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(z)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_z_range_max", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the maximum Z value that objects of the scene can be in order to be affected by the Light2D.
*/
func (o *Light2D) GetZRangeMax() int64 {
	log.Println("Calling Light2D.GetZRangeMax()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_z_range_max", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the minimum layer value of objects of the scene that are affected by the Light2D.
*/
func (o *Light2D) SetLayerRangeMin(layer int64) {
	log.Println("Calling Light2D.SetLayerRangeMin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_layer_range_min", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the minimum layer value of objects of the scene that are affected by the Light2D.
*/
func (o *Light2D) GetLayerRangeMin() int64 {
	log.Println("Calling Light2D.GetLayerRangeMin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_layer_range_min", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the maximum layer value of objects of the scene that are affected by the Light2D.
*/
func (o *Light2D) SetLayerRangeMax(layer int64) {
	log.Println("Calling Light2D.SetLayerRangeMax()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_layer_range_max", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the maximum layer value of objects of the scene that are affected by the Light2D.
*/
func (o *Light2D) GetLayerRangeMax() int64 {
	log.Println("Calling Light2D.GetLayerRangeMax()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_layer_range_max", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the item mask of the Light2D to 'item_mask' value.
*/
func (o *Light2D) SetItemCullMask(itemCullMask int64) {
	log.Println("Calling Light2D.SetItemCullMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(itemCullMask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_cull_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Light2D) GetItemCullMask() int64 {
	log.Println("Calling Light2D.GetItemCullMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_cull_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the item shadow mask to 'item_shadow_mask' value.
*/
func (o *Light2D) SetItemShadowCullMask(itemShadowCullMask int64) {
	log.Println("Calling Light2D.SetItemShadowCullMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(itemShadowCullMask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_shadow_cull_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Light2D) GetItemShadowCullMask() int64 {
	log.Println("Calling Light2D.GetItemShadowCullMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_shadow_cull_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the behaviour mode of the Light2D. Use constants defined in the constants section.
*/
func (o *Light2D) SetMode(mode int64) {
	log.Println("Calling Light2D.SetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current mode set to the Light2D.
*/
func (o *Light2D) GetMode() int64 {
	log.Println("Calling Light2D.GetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Enable or disable shadows casting from this Light2D according to the 'enabled' parameter.
*/
func (o *Light2D) SetShadowEnabled(enabled bool) {
	log.Println("Calling Light2D.SetShadowEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if shadow casting is enabled for this Light2D, else return false.
*/
func (o *Light2D) IsShadowEnabled() bool {
	log.Println("Calling Light2D.IsShadowEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_shadow_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the shadow buffer size.
*/
func (o *Light2D) SetShadowBufferSize(size int64) {
	log.Println("Calling Light2D.SetShadowBufferSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_buffer_size", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the shadow buffer size.
*/
func (o *Light2D) GetShadowBufferSize() int64 {
	log.Println("Calling Light2D.GetShadowBufferSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_buffer_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Light2D) SetShadowSmooth(smooth float64) {
	log.Println("Calling Light2D.SetShadowSmooth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(smooth)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_smooth", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Light2D) GetShadowSmooth() float64 {
	log.Println("Calling Light2D.GetShadowSmooth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_smooth", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Light2D) SetShadowGradientLength(multiplier float64) {
	log.Println("Calling Light2D.SetShadowGradientLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(multiplier)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_gradient_length", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Light2D) GetShadowGradientLength() float64 {
	log.Println("Calling Light2D.GetShadowGradientLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_gradient_length", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Light2D) SetShadowFilter(filter int64) {
	log.Println("Calling Light2D.SetShadowFilter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(filter)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_filter", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Light2D) GetShadowFilter() int64 {
	log.Println("Calling Light2D.GetShadowFilter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_filter", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the color of casted shadows for this Light2D.
*/
func (o *Light2D) SetShadowColor(shadowColor *Color) {
	log.Println("Calling Light2D.SetShadowColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shadowColor)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_color", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the color of casted shadows for this Light2D.
*/
func (o *Light2D) GetShadowColor() *Color {
	log.Println("Calling Light2D.GetShadowColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Light2DImplementer is an interface for Light2D objects.
*/
type Light2DImplementer interface {
	Class
}

/*
   Occludes light cast by a Light2D, casting shadows. The LightOccluder2D must be provided with an [OccluderPolygon2D] in order for the shadow to be computed.
*/
type LightOccluder2D struct {
	Node2D
}

func (o *LightOccluder2D) baseClass() string {
	return "LightOccluder2D"
}

/*
   Set the OccluderPolygon2D that defines the LightOccluder2D.
*/
func (o *LightOccluder2D) SetOccluderPolygon(polygon *OccluderPolygon2D) {
	log.Println("Calling LightOccluder2D.SetOccluderPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(polygon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_occluder_polygon", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the OccluderPolygon2D that defines the LightOccluder2D.
*/
func (o *LightOccluder2D) GetOccluderPolygon() *OccluderPolygon2D {
	log.Println("Calling LightOccluder2D.GetOccluderPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_occluder_polygon", goArguments, "*OccluderPolygon2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*OccluderPolygon2D)

	return returnValue

}

/*
   Set the LightOccluder2D light mask. The LightOccluder2D will cast shadows only from Light2Ds that belong to the same light mask(s).
*/
func (o *LightOccluder2D) SetOccluderLightMask(mask int64) {
	log.Println("Calling LightOccluder2D.SetOccluderLightMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_occluder_light_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the light mask of the LightOccluder2D.
*/
func (o *LightOccluder2D) GetOccluderLightMask() int64 {
	log.Println("Calling LightOccluder2D.GetOccluderLightMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_occluder_light_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *LightOccluder2D) X_PolyChanged() {
	log.Println("Calling LightOccluder2D.X_PolyChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_poly_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   LightOccluder2DImplementer is an interface for LightOccluder2D objects.
*/
type LightOccluder2DImplementer interface {
	Class
}

/*

 */
type OccluderPolygon2D struct {
	Resource
}

func (o *OccluderPolygon2D) baseClass() string {
	return "OccluderPolygon2D"
}

/*

 */
func (o *OccluderPolygon2D) SetClosed(closed bool) {
	log.Println("Calling OccluderPolygon2D.SetClosed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(closed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_closed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *OccluderPolygon2D) IsClosed() bool {
	log.Println("Calling OccluderPolygon2D.IsClosed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_closed", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *OccluderPolygon2D) SetCullMode(cullMode int64) {
	log.Println("Calling OccluderPolygon2D.SetCullMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(cullMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cull_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *OccluderPolygon2D) GetCullMode() int64 {
	log.Println("Calling OccluderPolygon2D.GetCullMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cull_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *OccluderPolygon2D) SetPolygon(polygon *PoolVector2Array) {
	log.Println("Calling OccluderPolygon2D.SetPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(polygon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_polygon", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *OccluderPolygon2D) GetPolygon() *PoolVector2Array {
	log.Println("Calling OccluderPolygon2D.GetPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_polygon", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*
   OccluderPolygon2DImplementer is an interface for OccluderPolygon2D objects.
*/
type OccluderPolygon2DImplementer interface {
	Class
}

/*
   Sort all child nodes based on their Y positions. The child node must inherit from [CanvasItem] for it to be sorted. Nodes that have a higher Y position will be drawn later, so they will appear on top of nodes that have a lower Y position.
*/
type YSort struct {
	Node2D
}

func (o *YSort) baseClass() string {
	return "YSort"
}

/*
   Set whether the children nodes are sorted or not. (default true)
*/
func (o *YSort) SetSortEnabled(enabled bool) {
	log.Println("Calling YSort.SetSortEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sort_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns true if the children nodes are being sorted.
*/
func (o *YSort) IsSortEnabled() bool {
	log.Println("Calling YSort.IsSortEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_sort_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   YSortImplementer is an interface for YSort objects.
*/
type YSortImplementer interface {
	Class
}

/*
   Node for back-buffering the currently displayed screen. The region defined in the BackBufferCopy node is bufferized with the content of the screen it covers, or the entire screen according to the copy mode set. Accessing this buffer is done with the texscreen() shader instruction.
*/
type BackBufferCopy struct {
	Node2D
}

func (o *BackBufferCopy) baseClass() string {
	return "BackBufferCopy"
}

/*
   Defines the area covered by the BackBufferCopy.
*/
func (o *BackBufferCopy) SetRect(rect *Rect2) {
	log.Println("Calling BackBufferCopy.SetRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rect)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rect", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the area covered by the BackBufferCopy.
*/
func (o *BackBufferCopy) GetRect() *Rect2 {
	log.Println("Calling BackBufferCopy.GetRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Set the copy mode of the BackBufferCopy (refer to constants section).
*/
func (o *BackBufferCopy) SetCopyMode(copyMode int64) {
	log.Println("Calling BackBufferCopy.SetCopyMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(copyMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_copy_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the copy mode currently applied to the BackBufferCopy (refer to constants section).
*/
func (o *BackBufferCopy) GetCopyMode() int64 {
	log.Println("Calling BackBufferCopy.GetCopyMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_copy_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   BackBufferCopyImplementer is an interface for BackBufferCopy objects.
*/
type BackBufferCopyImplementer interface {
	Class
}

/*
   Camera node for 2D scenes. It forces the screen (current layer) to scroll following this node. This makes it easier (and faster) to program scrollable scenes than manually changing the position of [CanvasItem] based nodes. This node is intended to be a simple helper get get things going quickly and it may happen often that more functionality is desired to change how the camera works. To make your own custom camera node, simply inherit from [Node2D] and change the transform of the canvas by calling get_viewport().set_canvas_transform(m) in [Viewport].
*/
type Camera2D struct {
	Node2D
}

func (o *Camera2D) baseClass() string {
	return "Camera2D"
}

/*
   Set the scroll offset. Useful for looking around or camera shake animations.
*/
func (o *Camera2D) SetOffset(offset *Vector2) {
	log.Println("Calling Camera2D.SetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the scroll offset.
*/
func (o *Camera2D) GetOffset() *Vector2 {
	log.Println("Calling Camera2D.GetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Camera2D) SetAnchorMode(anchorMode int64) {
	log.Println("Calling Camera2D.SetAnchorMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anchorMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_anchor_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) GetAnchorMode() int64 {
	log.Println("Calling Camera2D.GetAnchorMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_anchor_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Camera2D) SetRotating(rotating bool) {
	log.Println("Calling Camera2D.SetRotating()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rotating)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rotating", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) IsRotating() bool {
	log.Println("Calling Camera2D.IsRotating()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_rotating", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Make this the current 2D camera for the scene (viewport and layer), in case there's many cameras in the scene.
*/
func (o *Camera2D) MakeCurrent() {
	log.Println("Calling Camera2D.MakeCurrent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "make_current", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) ClearCurrent() {
	log.Println("Calling Camera2D.ClearCurrent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_current", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Camera2D) X_MakeCurrent(arg0 *Object) {
	log.Println("Calling Camera2D.X_MakeCurrent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_make_current", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Camera2D) X_UpdateScroll() {
	log.Println("Calling Camera2D.X_UpdateScroll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_update_scroll", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Camera2D) X_SetCurrent(current bool) {
	log.Println("Calling Camera2D.X_SetCurrent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(current)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_current", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true of this is the current camera (see [method make_current]).
*/
func (o *Camera2D) IsCurrent() bool {
	log.Println("Calling Camera2D.IsCurrent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_current", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the scrolling limit in pixels.
*/
func (o *Camera2D) SetLimit(margin int64, limit int64) {
	log.Println("Calling Camera2D.SetLimit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(limit)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_limit", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the scrolling limit in pixels.
*/
func (o *Camera2D) GetLimit(margin int64) int64 {
	log.Println("Calling Camera2D.GetLimit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_limit", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Smooth camera when reaching camera limits. This requires camera smoothing being enabled to have a noticeable effect.
*/
func (o *Camera2D) SetLimitSmoothingEnabled(limitSmoothingEnabled bool) {
	log.Println("Calling Camera2D.SetLimitSmoothingEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(limitSmoothingEnabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_limit_smoothing_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) IsLimitSmoothingEnabled() bool {
	log.Println("Calling Camera2D.IsLimitSmoothingEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_limit_smoothing_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Camera2D) SetVDragEnabled(enabled bool) {
	log.Println("Calling Camera2D.SetVDragEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_v_drag_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) IsVDragEnabled() bool {
	log.Println("Calling Camera2D.IsVDragEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_v_drag_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Camera2D) SetHDragEnabled(enabled bool) {
	log.Println("Calling Camera2D.SetHDragEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_h_drag_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) IsHDragEnabled() bool {
	log.Println("Calling Camera2D.IsHDragEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_h_drag_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Camera2D) SetVOffset(ofs float64) {
	log.Println("Calling Camera2D.SetVOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ofs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_v_offset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) GetVOffset() float64 {
	log.Println("Calling Camera2D.GetVOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_v_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Camera2D) SetHOffset(ofs float64) {
	log.Println("Calling Camera2D.SetHOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ofs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_h_offset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) GetHOffset() float64 {
	log.Println("Calling Camera2D.GetHOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_h_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the margins needed to drag the camera (relative to the screen size). Margin uses the MARGIN_* enum. Drag margins of 0,0,0,0 will keep the camera at the center of the screen, while drag margins of 1,1,1,1 will only move when the camera is at the edges.
*/
func (o *Camera2D) SetDragMargin(margin int64, dragMargin float64) {
	log.Println("Calling Camera2D.SetDragMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(dragMargin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_drag_margin", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the margins needed to drag the camera (see [method set_drag_margin]).
*/
func (o *Camera2D) GetDragMargin(margin int64) float64 {
	log.Println("Calling Camera2D.GetDragMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_drag_margin", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the camera position.
*/
func (o *Camera2D) GetCameraPosition() *Vector2 {
	log.Println("Calling Camera2D.GetCameraPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_camera_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Camera2D) GetCameraScreenCenter() *Vector2 {
	log.Println("Calling Camera2D.GetCameraScreenCenter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_camera_screen_center", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Camera2D) SetZoom(zoom *Vector2) {
	log.Println("Calling Camera2D.SetZoom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(zoom)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_zoom", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) GetZoom() *Vector2 {
	log.Println("Calling Camera2D.GetZoom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_zoom", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Camera2D) SetCustomViewport(viewport *Object) {
	log.Println("Calling Camera2D.SetCustomViewport()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(viewport)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_viewport", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) GetCustomViewport() *Node {
	log.Println("Calling Camera2D.GetCustomViewport()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_custom_viewport", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*

 */
func (o *Camera2D) SetFollowSmoothing(followSmoothing float64) {
	log.Println("Calling Camera2D.SetFollowSmoothing()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(followSmoothing)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_follow_smoothing", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) GetFollowSmoothing() float64 {
	log.Println("Calling Camera2D.GetFollowSmoothing()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_follow_smoothing", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Camera2D) SetEnableFollowSmoothing(followSmoothing bool) {
	log.Println("Calling Camera2D.SetEnableFollowSmoothing()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(followSmoothing)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enable_follow_smoothing", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) IsFollowSmoothingEnabled() bool {
	log.Println("Calling Camera2D.IsFollowSmoothingEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_follow_smoothing_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Force the camera to update scroll immediately.
*/
func (o *Camera2D) ForceUpdateScroll() {
	log.Println("Calling Camera2D.ForceUpdateScroll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "force_update_scroll", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the camera's position immediately to its current smoothing destination. This has no effect if smoothing is disabled.
*/
func (o *Camera2D) ResetSmoothing() {
	log.Println("Calling Camera2D.ResetSmoothing()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "reset_smoothing", goArguments, "")

	log.Println("Got return value!")

}

/*
   Align the camera to the tracked node
*/
func (o *Camera2D) Align() {
	log.Println("Calling Camera2D.Align()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "align", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Camera2D) X_SetOldSmoothing(followSmoothing float64) {
	log.Println("Calling Camera2D.X_SetOldSmoothing()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(followSmoothing)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_old_smoothing", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) SetScreenDrawingEnabled(screenDrawingEnabled bool) {
	log.Println("Calling Camera2D.SetScreenDrawingEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(screenDrawingEnabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_screen_drawing_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) IsScreenDrawingEnabled() bool {
	log.Println("Calling Camera2D.IsScreenDrawingEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_screen_drawing_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Camera2D) SetLimitDrawingEnabled(limitDrawingEnabled bool) {
	log.Println("Calling Camera2D.SetLimitDrawingEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(limitDrawingEnabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_limit_drawing_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) IsLimitDrawingEnabled() bool {
	log.Println("Calling Camera2D.IsLimitDrawingEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_limit_drawing_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Camera2D) SetMarginDrawingEnabled(marginDrawingEnabled bool) {
	log.Println("Calling Camera2D.SetMarginDrawingEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(marginDrawingEnabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_margin_drawing_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) IsMarginDrawingEnabled() bool {
	log.Println("Calling Camera2D.IsMarginDrawingEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_margin_drawing_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Camera2DImplementer is an interface for Camera2D objects.
*/
type Camera2DImplementer interface {
	Class
}

/*
   Base node for all joint constraints in 2D physics. Joints take 2 bodies and apply a custom constraint.
*/
type Joint2D struct {
	Node2D
}

func (o *Joint2D) baseClass() string {
	return "Joint2D"
}

/*
   Set the path to the A node for the joint. Must be of type [PhysicsBody2D].
*/
func (o *Joint2D) SetNodeA(node *NodePath) {
	log.Println("Calling Joint2D.SetNodeA()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_node_a", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the path to the A node for the joint.
*/
func (o *Joint2D) GetNodeA() *NodePath {
	log.Println("Calling Joint2D.GetNodeA()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_a", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*
   Set the path to the B node for the joint. Must be of type [PhysicsBody2D].
*/
func (o *Joint2D) SetNodeB(node *NodePath) {
	log.Println("Calling Joint2D.SetNodeB()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_node_b", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the path to the B node for the joint.
*/
func (o *Joint2D) GetNodeB() *NodePath {
	log.Println("Calling Joint2D.GetNodeB()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_b", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *Joint2D) SetBias(bias float64) {
	log.Println("Calling Joint2D.SetBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bias)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bias", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Joint2D) GetBias() float64 {
	log.Println("Calling Joint2D.GetBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bias", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Joint2D) SetExcludeNodesFromCollision(enable bool) {
	log.Println("Calling Joint2D.SetExcludeNodesFromCollision()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_exclude_nodes_from_collision", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Joint2D) GetExcludeNodesFromCollision() bool {
	log.Println("Calling Joint2D.GetExcludeNodesFromCollision()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_exclude_nodes_from_collision", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Joint2DImplementer is an interface for Joint2D objects.
*/
type Joint2DImplementer interface {
	Class
}

/*
   Pin Joint for 2D Rigid Bodies. It pins 2 bodies (rigid or static) together, or a single body to a fixed position in space.
*/
type PinJoint2D struct {
	Joint2D
}

func (o *PinJoint2D) baseClass() string {
	return "PinJoint2D"
}

/*

 */
func (o *PinJoint2D) SetSoftness(softness float64) {
	log.Println("Calling PinJoint2D.SetSoftness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(softness)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_softness", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PinJoint2D) GetSoftness() float64 {
	log.Println("Calling PinJoint2D.GetSoftness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_softness", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   PinJoint2DImplementer is an interface for PinJoint2D objects.
*/
type PinJoint2DImplementer interface {
	Class
}

/*
   Groove constraint for 2D physics. This is useful for making a body "slide" through a segment placed in another.
*/
type GrooveJoint2D struct {
	Joint2D
}

func (o *GrooveJoint2D) baseClass() string {
	return "GrooveJoint2D"
}

/*
   Set the length of the groove.
*/
func (o *GrooveJoint2D) SetLength(length float64) {
	log.Println("Calling GrooveJoint2D.SetLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(length)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_length", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the length of the groove.
*/
func (o *GrooveJoint2D) GetLength() float64 {
	log.Println("Calling GrooveJoint2D.GetLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_length", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the initial offset of the groove on body A.
*/
func (o *GrooveJoint2D) SetInitialOffset(offset float64) {
	log.Println("Calling GrooveJoint2D.SetInitialOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_initial_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the final offset of the groove on body A.
*/
func (o *GrooveJoint2D) GetInitialOffset() float64 {
	log.Println("Calling GrooveJoint2D.GetInitialOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_initial_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   GrooveJoint2DImplementer is an interface for GrooveJoint2D objects.
*/
type GrooveJoint2DImplementer interface {
	Class
}

/*
   Damped spring constraint for 2D physics. This resembles a spring joint that always wants to go back to a given length.
*/
type DampedSpringJoint2D struct {
	Joint2D
}

func (o *DampedSpringJoint2D) baseClass() string {
	return "DampedSpringJoint2D"
}

/*
   Set the maximum length of the spring joint.
*/
func (o *DampedSpringJoint2D) SetLength(length float64) {
	log.Println("Calling DampedSpringJoint2D.SetLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(length)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_length", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the maximum length of the spring joint.
*/
func (o *DampedSpringJoint2D) GetLength() float64 {
	log.Println("Calling DampedSpringJoint2D.GetLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_length", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the resting length of the spring joint. The joint will always try to go to back this length when pulled apart.
*/
func (o *DampedSpringJoint2D) SetRestLength(restLength float64) {
	log.Println("Calling DampedSpringJoint2D.SetRestLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(restLength)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rest_length", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the resting length of the spring joint. The joint will always try to go to back this length when pulled apart.
*/
func (o *DampedSpringJoint2D) GetRestLength() float64 {
	log.Println("Calling DampedSpringJoint2D.GetRestLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rest_length", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the stiffness of the spring joint. The joint applies a force equal to the stiffness times the distance from its resting length.
*/
func (o *DampedSpringJoint2D) SetStiffness(stiffness float64) {
	log.Println("Calling DampedSpringJoint2D.SetStiffness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(stiffness)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_stiffness", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the stiffness of the spring joint. The joint applies a force equal to the stiffness times the distance from its resting length.
*/
func (o *DampedSpringJoint2D) GetStiffness() float64 {
	log.Println("Calling DampedSpringJoint2D.GetStiffness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stiffness", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the damping ratio of the spring joint. A value of 0 indicates an undamped spring, while 1 causes the system to reach equilibrium as fast as possible (critical damping).
*/
func (o *DampedSpringJoint2D) SetDamping(damping float64) {
	log.Println("Calling DampedSpringJoint2D.SetDamping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(damping)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_damping", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the damping ratio of the spring joint. A value of 0 indicates an undamped spring, while 1 causes the system to reach equilibrium as fast as possible (critical damping).
*/
func (o *DampedSpringJoint2D) GetDamping() float64 {
	log.Println("Calling DampedSpringJoint2D.GetDamping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_damping", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   DampedSpringJoint2DImplementer is an interface for DampedSpringJoint2D objects.
*/
type DampedSpringJoint2DImplementer interface {
	Class
}

/*
   A TileSet is a library of tiles for a [TileMap]. It contains a list of tiles, each consisting of a sprite and optional collision shapes. Tiles are referenced by a unique integer ID.
*/
type TileSet struct {
	Resource
}

func (o *TileSet) baseClass() string {
	return "TileSet"
}

/*
   Create a new tile which will be referenced by the given ID.
*/
func (o *TileSet) CreateTile(id int64) {
	log.Println("Calling TileSet.CreateTile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create_tile", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the name of the tile, for descriptive purposes.
*/
func (o *TileSet) TileSetName(id int64, name string) {
	log.Println("Calling TileSet.TileSetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_name", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the name of the tile.
*/
func (o *TileSet) TileGetName(id int64) string {
	log.Println("Calling TileSet.TileGetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Set the texture of the tile.
*/
func (o *TileSet) TileSetTexture(id int64, texture *Texture) {
	log.Println("Calling TileSet.TileSetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_texture", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the texture of the tile.
*/
func (o *TileSet) TileGetTexture(id int64) *Texture {
	log.Println("Calling TileSet.TileGetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TileSet) TileSetNormalMap(id int64, normalMap *Texture) {
	log.Println("Calling TileSet.TileSetNormalMap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(normalMap)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_normal_map", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TileSet) TileGetNormalMap(id int64) *Texture {
	log.Println("Calling TileSet.TileGetNormalMap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_normal_map", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   Set the material of the tile.
*/
func (o *TileSet) TileSetMaterial(id int64, material *ShaderMaterial) {
	log.Println("Calling TileSet.TileSetMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(material)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_material", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the material of the tile.
*/
func (o *TileSet) TileGetMaterial(id int64) *ShaderMaterial {
	log.Println("Calling TileSet.TileGetMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_material", goArguments, "*ShaderMaterial")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*ShaderMaterial)

	return returnValue

}

/*
   Set the texture offset of the tile.
*/
func (o *TileSet) TileSetTextureOffset(id int64, textureOffset *Vector2) {
	log.Println("Calling TileSet.TileSetTextureOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(textureOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_texture_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the texture offset of the tile.
*/
func (o *TileSet) TileGetTextureOffset(id int64) *Vector2 {
	log.Println("Calling TileSet.TileGetTextureOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_texture_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set the tile sub-region in the texture. This is common in texture atlases.
*/
func (o *TileSet) TileSetRegion(id int64, region *Rect2) {
	log.Println("Calling TileSet.TileSetRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(region)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_region", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the tile sub-region in the texture.
*/
func (o *TileSet) TileGetRegion(id int64) *Rect2 {
	log.Println("Calling TileSet.TileGetRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_region", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*

 */
func (o *TileSet) TileSetShape(id int64, shapeId int64, shape *Shape2D) {
	log.Println("Calling TileSet.TileSetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(shapeId)
	goArguments[2] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TileSet) TileGetShape(id int64, shapeId int64) *Shape2D {
	log.Println("Calling TileSet.TileGetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(shapeId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_shape", goArguments, "*Shape2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Shape2D)

	return returnValue

}

/*

 */
func (o *TileSet) TileSetShapeTransform(id int64, shapeId int64, shapeTransform *Transform2D) {
	log.Println("Calling TileSet.TileSetShapeTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(shapeId)
	goArguments[2] = reflect.ValueOf(shapeTransform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_shape_transform", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TileSet) TileGetShapeTransform(id int64, shapeId int64) *Transform2D {
	log.Println("Calling TileSet.TileGetShapeTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(shapeId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_shape_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*

 */
func (o *TileSet) TileSetShapeOneWay(id int64, shapeId int64, oneWay bool) {
	log.Println("Calling TileSet.TileSetShapeOneWay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(shapeId)
	goArguments[2] = reflect.ValueOf(oneWay)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_shape_one_way", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TileSet) TileGetShapeOneWay(id int64, shapeId int64) bool {
	log.Println("Calling TileSet.TileGetShapeOneWay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(shapeId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_shape_one_way", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *TileSet) TileAddShape(id int64, shape *Shape2D, shapeTransform *Transform2D, oneWay bool) {
	log.Println("Calling TileSet.TileAddShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(shape)
	goArguments[2] = reflect.ValueOf(shapeTransform)
	goArguments[3] = reflect.ValueOf(oneWay)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_add_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TileSet) TileGetShapeCount(id int64) int64 {
	log.Println("Calling TileSet.TileGetShapeCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_shape_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set an array of shapes for the tile, enabling physics to collide with it.
*/
func (o *TileSet) TileSetShapes(id int64, shapes *Array) {
	log.Println("Calling TileSet.TileSetShapes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(shapes)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_shapes", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the array of shapes of the tile.
*/
func (o *TileSet) TileGetShapes(id int64) *Array {
	log.Println("Calling TileSet.TileGetShapes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_shapes", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Set a navigation polygon for the tile.
*/
func (o *TileSet) TileSetNavigationPolygon(id int64, navigationPolygon *NavigationPolygon) {
	log.Println("Calling TileSet.TileSetNavigationPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(navigationPolygon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_navigation_polygon", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the navigation polygon of the tile.
*/
func (o *TileSet) TileGetNavigationPolygon(id int64) *NavigationPolygon {
	log.Println("Calling TileSet.TileGetNavigationPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_navigation_polygon", goArguments, "*NavigationPolygon")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NavigationPolygon)

	return returnValue

}

/*
   Set an offset for the tile's navigation polygon.
*/
func (o *TileSet) TileSetNavigationPolygonOffset(id int64, navigationPolygonOffset *Vector2) {
	log.Println("Calling TileSet.TileSetNavigationPolygonOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(navigationPolygonOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_navigation_polygon_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the offset of the tile's navigation polygon.
*/
func (o *TileSet) TileGetNavigationPolygonOffset(id int64) *Vector2 {
	log.Println("Calling TileSet.TileGetNavigationPolygonOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_navigation_polygon_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set a light occluder for the tile.
*/
func (o *TileSet) TileSetLightOccluder(id int64, lightOccluder *OccluderPolygon2D) {
	log.Println("Calling TileSet.TileSetLightOccluder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(lightOccluder)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_light_occluder", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the light occluder of the tile.
*/
func (o *TileSet) TileGetLightOccluder(id int64) *OccluderPolygon2D {
	log.Println("Calling TileSet.TileGetLightOccluder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_light_occluder", goArguments, "*OccluderPolygon2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*OccluderPolygon2D)

	return returnValue

}

/*
   Set an offset for the tile's light occluder.
*/
func (o *TileSet) TileSetOccluderOffset(id int64, occluderOffset *Vector2) {
	log.Println("Calling TileSet.TileSetOccluderOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(occluderOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_occluder_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the offset of the tile's light occluder.
*/
func (o *TileSet) TileGetOccluderOffset(id int64) *Vector2 {
	log.Println("Calling TileSet.TileGetOccluderOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_occluder_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Remove the tile referenced by the given ID.
*/
func (o *TileSet) RemoveTile(id int64) {
	log.Println("Calling TileSet.RemoveTile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_tile", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear all tiles.
*/
func (o *TileSet) Clear() {
	log.Println("Calling TileSet.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the ID following the last currently used ID, useful when creating a new tile.
*/
func (o *TileSet) GetLastUnusedTileId() int64 {
	log.Println("Calling TileSet.GetLastUnusedTileId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_last_unused_tile_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Find the first tile matching the given name.
*/
func (o *TileSet) FindTileByName(name string) int64 {
	log.Println("Calling TileSet.FindTileByName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "find_tile_by_name", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return an array of all currently used tile IDs.
*/
func (o *TileSet) GetTilesIds() *Array {
	log.Println("Calling TileSet.GetTilesIds()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tiles_ids", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   TileSetImplementer is an interface for TileSet objects.
*/
type TileSetImplementer interface {
	Class
}

/*
   Node for 2D tile-based maps. Tilemaps use a [TileSet] which contain a list of tiles (textures plus optional collision, navigation, and/or occluder shapes) which are used to create grid-based maps.
*/
type TileMap struct {
	Node2D
}

func (o *TileMap) baseClass() string {
	return "TileMap"
}

/*
   Set the current tileset.
*/
func (o *TileMap) SetTileset(tileset *TileSet) {
	log.Println("Calling TileMap.SetTileset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tileset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tileset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current tileset.
*/
func (o *TileMap) GetTileset() *TileSet {
	log.Println("Calling TileMap.GetTileset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tileset", goArguments, "*TileSet")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TileSet)

	return returnValue

}

/*
   Set the orientation mode as square, isometric or custom (use MODE_* constants as argument).
*/
func (o *TileMap) SetMode(mode int64) {
	log.Println("Calling TileMap.SetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the orientation mode.
*/
func (o *TileMap) GetMode() int64 {
	log.Println("Calling TileMap.GetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set a half offset on the X coordinate, Y coordinate, or none (use HALF_OFFSET_* constants as argument). Half offset sets every other tile off by a half tile size in the specified direction.
*/
func (o *TileMap) SetHalfOffset(halfOffset int64) {
	log.Println("Calling TileMap.SetHalfOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(halfOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_half_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current half offset configuration.
*/
func (o *TileMap) GetHalfOffset() int64 {
	log.Println("Calling TileMap.GetHalfOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_half_offset", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set custom transform matrix, to use in combination with the custom orientation mode.
*/
func (o *TileMap) SetCustomTransform(customTransform *Transform2D) {
	log.Println("Calling TileMap.SetCustomTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(customTransform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the custom transform matrix.
*/
func (o *TileMap) GetCustomTransform() *Transform2D {
	log.Println("Calling TileMap.GetCustomTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_custom_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Set the cell size.
*/
func (o *TileMap) SetCellSize(size *Vector2) {
	log.Println("Calling TileMap.SetCellSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cell_size", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the cell size.
*/
func (o *TileMap) GetCellSize() *Vector2 {
	log.Println("Calling TileMap.GetCellSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cell_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Undocumented
*/
func (o *TileMap) X_SetOldCellSize(size int64) {
	log.Println("Calling TileMap.X_SetOldCellSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_old_cell_size", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *TileMap) X_GetOldCellSize() int64 {
	log.Println("Calling TileMap.X_GetOldCellSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_old_cell_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the quadrant size, this optimizes drawing by batching chunks of map at draw/cull time. Allowed values are integers ranging from 1 to 128.
*/
func (o *TileMap) SetQuadrantSize(size int64) {
	log.Println("Calling TileMap.SetQuadrantSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_quadrant_size", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the quadrant size.
*/
func (o *TileMap) GetQuadrantSize() int64 {
	log.Println("Calling TileMap.GetQuadrantSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_quadrant_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the tile origin to the tile center or its top-left corner (use TILE_ORIGIN_* constants as argument).
*/
func (o *TileMap) SetTileOrigin(origin int64) {
	log.Println("Calling TileMap.SetTileOrigin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(origin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tile_origin", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the tile origin configuration.
*/
func (o *TileMap) GetTileOrigin() int64 {
	log.Println("Calling TileMap.GetTileOrigin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tile_origin", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set tiles to be centered in x coordinate. (by default this is false and they are drawn from upper left cell corner).
*/
func (o *TileMap) SetCenterX(enable bool) {
	log.Println("Calling TileMap.SetCenterX()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_center_x", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if tiles are to be centered in x coordinate (by default this is false and they are drawn from upper left cell corner).
*/
func (o *TileMap) GetCenterX() bool {
	log.Println("Calling TileMap.GetCenterX()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_center_x", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set tiles to be centered in y coordinate. (by default this is false and they are drawn from upper left cell corner).
*/
func (o *TileMap) SetCenterY(enable bool) {
	log.Println("Calling TileMap.SetCenterY()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_center_y", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if tiles are to be centered in y coordinate (by default this is false and they are drawn from upper left cell corner).
*/
func (o *TileMap) GetCenterY() bool {
	log.Println("Calling TileMap.GetCenterY()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_center_y", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the Y sort mode. Enabled Y sort mode means that children of the tilemap will be drawn in the order defined by their Y coordinate. A tile with a higher Y coordinate will therefore be drawn later, potentially covering up the tile(s) above it if its sprite is higher than its cell size.
*/
func (o *TileMap) SetYSortMode(enable bool) {
	log.Println("Calling TileMap.SetYSortMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_y_sort_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the Y sort mode.
*/
func (o *TileMap) IsYSortModeEnabled() bool {
	log.Println("Calling TileMap.IsYSortModeEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_y_sort_mode_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the tilemap to handle collisions as a kinematic body (enabled) or a static body (disabled).
*/
func (o *TileMap) SetCollisionUseKinematic(useKinematic bool) {
	log.Println("Calling TileMap.SetCollisionUseKinematic()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(useKinematic)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_use_kinematic", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether the tilemap handles collisions as a kinematic body.
*/
func (o *TileMap) GetCollisionUseKinematic() bool {
	log.Println("Calling TileMap.GetCollisionUseKinematic()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_use_kinematic", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the collision layer. Layers are referenced by binary indexes, so allowable values to describe the 20 available layers range from 0 to 2^20-1.
*/
func (o *TileMap) SetCollisionLayer(layer int64) {
	log.Println("Calling TileMap.SetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the collision layer.
*/
func (o *TileMap) GetCollisionLayer() int64 {
	log.Println("Calling TileMap.GetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the collision masks. Masks are referenced by binary indexes, so allowable values to describe the 20 available masks range from 0 to 2^20-1.
*/
func (o *TileMap) SetCollisionMask(mask int64) {
	log.Println("Calling TileMap.SetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the collision mask.
*/
func (o *TileMap) GetCollisionMask() int64 {
	log.Println("Calling TileMap.GetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *TileMap) SetCollisionLayerBit(bit int64, value bool) {
	log.Println("Calling TileMap.SetCollisionLayerBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(bit)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer_bit", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TileMap) GetCollisionLayerBit(bit int64) bool {
	log.Println("Calling TileMap.GetCollisionLayerBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bit)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer_bit", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *TileMap) SetCollisionMaskBit(bit int64, value bool) {
	log.Println("Calling TileMap.SetCollisionMaskBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(bit)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_mask_bit", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TileMap) GetCollisionMaskBit(bit int64) bool {
	log.Println("Calling TileMap.GetCollisionMaskBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bit)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_mask_bit", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the collision friction parameter. Allowable values range from 0 to 1.
*/
func (o *TileMap) SetCollisionFriction(value float64) {
	log.Println("Calling TileMap.SetCollisionFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_friction", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the collision friction parameter.
*/
func (o *TileMap) GetCollisionFriction() float64 {
	log.Println("Calling TileMap.GetCollisionFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_friction", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the collision bounce parameter. Allowable values range from 0 to 1.
*/
func (o *TileMap) SetCollisionBounce(value float64) {
	log.Println("Calling TileMap.SetCollisionBounce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_bounce", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the collision bounce parameter.
*/
func (o *TileMap) GetCollisionBounce() float64 {
	log.Println("Calling TileMap.GetCollisionBounce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_bounce", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *TileMap) SetOccluderLightMask(mask int64) {
	log.Println("Calling TileMap.SetOccluderLightMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_occluder_light_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TileMap) GetOccluderLightMask() int64 {
	log.Println("Calling TileMap.GetOccluderLightMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_occluder_light_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the tile index for the cell referenced by its grid-based X and Y coordinates. A tile index of -1 clears the cell. Optionally, the tile can also be flipped over the X and Y coordinates or transposed.
*/
func (o *TileMap) SetCell(x int64, y int64, tile int64, flipX bool, flipY bool, transpose bool) {
	log.Println("Calling TileMap.SetCell()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 6, 6)
	goArguments[0] = reflect.ValueOf(x)
	goArguments[1] = reflect.ValueOf(y)
	goArguments[2] = reflect.ValueOf(tile)
	goArguments[3] = reflect.ValueOf(flipX)
	goArguments[4] = reflect.ValueOf(flipY)
	goArguments[5] = reflect.ValueOf(transpose)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cell", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the tile index for the cell referenced by a Vector2 of grid-based coordinates. A tile index of -1 clears the cell. Optionally, the tile can also be flipped over the X and Y axes or transposed.
*/
func (o *TileMap) SetCellv(position *Vector2, tile int64, flipX bool, flipY bool, transpose bool) {
	log.Println("Calling TileMap.SetCellv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(position)
	goArguments[1] = reflect.ValueOf(tile)
	goArguments[2] = reflect.ValueOf(flipX)
	goArguments[3] = reflect.ValueOf(flipY)
	goArguments[4] = reflect.ValueOf(transpose)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cellv", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the tile index of the referenced cell.
*/
func (o *TileMap) GetCell(x int64, y int64) int64 {
	log.Println("Calling TileMap.GetCell()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(x)
	goArguments[1] = reflect.ValueOf(y)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cell", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the tile index of the cell referenced by a Vector2.
*/
func (o *TileMap) GetCellv(position *Vector2) int64 {
	log.Println("Calling TileMap.GetCellv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cellv", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return whether the referenced cell is flipped over the X axis.
*/
func (o *TileMap) IsCellXFlipped(x int64, y int64) bool {
	log.Println("Calling TileMap.IsCellXFlipped()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(x)
	goArguments[1] = reflect.ValueOf(y)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_cell_x_flipped", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return whether the referenced cell is flipped over the Y axis.
*/
func (o *TileMap) IsCellYFlipped(x int64, y int64) bool {
	log.Println("Calling TileMap.IsCellYFlipped()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(x)
	goArguments[1] = reflect.ValueOf(y)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_cell_y_flipped", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return whether the referenced cell is transposed, i.e. the X and Y axes are swapped (mirroring with regard to the (1,1) vector).
*/
func (o *TileMap) IsCellTransposed(x int64, y int64) bool {
	log.Println("Calling TileMap.IsCellTransposed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(x)
	goArguments[1] = reflect.ValueOf(y)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_cell_transposed", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Clear all cells.
*/
func (o *TileMap) Clear() {
	log.Println("Calling TileMap.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return an array of all cells containing a tile from the tileset (i.e. a tile index different from -1).
*/
func (o *TileMap) GetUsedCells() *Array {
	log.Println("Calling TileMap.GetUsedCells()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_used_cells", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *TileMap) GetUsedCellsById(id int64) *Array {
	log.Println("Calling TileMap.GetUsedCellsById()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_used_cells_by_id", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *TileMap) GetUsedRect() *Rect2 {
	log.Println("Calling TileMap.GetUsedRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_used_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Return the absolute world position corresponding to the tilemap (grid-based) coordinates given as an argument. Optionally, the tilemap's potential half offset can be ignored.
*/
func (o *TileMap) MapToWorld(mapPosition *Vector2, ignoreHalfOfs bool) *Vector2 {
	log.Println("Calling TileMap.MapToWorld()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(mapPosition)
	goArguments[1] = reflect.ValueOf(ignoreHalfOfs)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "map_to_world", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the tilemap (grid-based) coordinates corresponding to the absolute world position given as an argument.
*/
func (o *TileMap) WorldToMap(worldPosition *Vector2) *Vector2 {
	log.Println("Calling TileMap.WorldToMap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(worldPosition)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "world_to_map", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Undocumented
*/
func (o *TileMap) X_ClearQuadrants() {
	log.Println("Calling TileMap.X_ClearQuadrants()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_clear_quadrants", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *TileMap) X_RecreateQuadrants() {
	log.Println("Calling TileMap.X_RecreateQuadrants()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_recreate_quadrants", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *TileMap) X_UpdateDirtyQuadrants() {
	log.Println("Calling TileMap.X_UpdateDirtyQuadrants()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_update_dirty_quadrants", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *TileMap) X_SetTileData(arg0 *PoolIntArray) {
	log.Println("Calling TileMap.X_SetTileData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_tile_data", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *TileMap) X_GetTileData() *PoolIntArray {
	log.Println("Calling TileMap.X_GetTileData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_tile_data", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*
   TileMapImplementer is an interface for TileMap objects.
*/
type TileMapImplementer interface {
	Class
}

/*
   A ParallaxBackground will use one or more [ParallaxLayer] nodes to create a parallax scrolling background. Each [ParallaxLayer] can be set to move at different speeds relative to the camera movement, this can be used to create an illusion of depth in a 2D game.
*/
type ParallaxBackground struct {
	CanvasLayer
}

func (o *ParallaxBackground) baseClass() string {
	return "ParallaxBackground"
}

/*
   Undocumented
*/
func (o *ParallaxBackground) X_CameraMoved(arg0 *Transform2D) {
	log.Println("Calling ParallaxBackground.X_CameraMoved()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_camera_moved", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParallaxBackground) SetScrollOffset(ofs *Vector2) {
	log.Println("Calling ParallaxBackground.SetScrollOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ofs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scroll_offset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParallaxBackground) GetScrollOffset() *Vector2 {
	log.Println("Calling ParallaxBackground.GetScrollOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scroll_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set the base offset in pixels of all children [ParallaxLayer] nodes.
*/
func (o *ParallaxBackground) SetScrollBaseOffset(ofs *Vector2) {
	log.Println("Calling ParallaxBackground.SetScrollBaseOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ofs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scroll_base_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the base offset.
*/
func (o *ParallaxBackground) GetScrollBaseOffset() *Vector2 {
	log.Println("Calling ParallaxBackground.GetScrollBaseOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scroll_base_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set the base motion scale of all children [ParallaxLayer] nodes.
*/
func (o *ParallaxBackground) SetScrollBaseScale(scale *Vector2) {
	log.Println("Calling ParallaxBackground.SetScrollBaseScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scroll_base_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the base motion scale.
*/
func (o *ParallaxBackground) GetScrollBaseScale() *Vector2 {
	log.Println("Calling ParallaxBackground.GetScrollBaseScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scroll_base_scale", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set the left and top limits in pixels for scrolling to begin. If the camera is outside of this limit the background will not continue to scroll. If an axis is greater than or equal to the corresponding axis of limit_end, then it will not limit scrolling for that axis.
*/
func (o *ParallaxBackground) SetLimitBegin(ofs *Vector2) {
	log.Println("Calling ParallaxBackground.SetLimitBegin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ofs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_limit_begin", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the beginning limit.
*/
func (o *ParallaxBackground) GetLimitBegin() *Vector2 {
	log.Println("Calling ParallaxBackground.GetLimitBegin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_limit_begin", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set the right and bottom limits in pixels for scrolling to end. If the camera is outside of this limit the background will not continue to scroll. If an axis is less than or equal to the corresponding axis of limit_begin, then it will not limit scrolling for that axis.
*/
func (o *ParallaxBackground) SetLimitEnd(ofs *Vector2) {
	log.Println("Calling ParallaxBackground.SetLimitEnd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ofs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_limit_end", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the ending limit.
*/
func (o *ParallaxBackground) GetLimitEnd() *Vector2 {
	log.Println("Calling ParallaxBackground.GetLimitEnd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_limit_end", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set to true for all child [ParallaxLayer] nodes to not be affected by the zoom level of the camera.
*/
func (o *ParallaxBackground) SetIgnoreCameraZoom(ignore bool) {
	log.Println("Calling ParallaxBackground.SetIgnoreCameraZoom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ignore)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ignore_camera_zoom", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return ignoring camera zoom.
*/
func (o *ParallaxBackground) IsIgnoreCameraZoom() bool {
	log.Println("Calling ParallaxBackground.IsIgnoreCameraZoom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_ignore_camera_zoom", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   ParallaxBackgroundImplementer is an interface for ParallaxBackground objects.
*/
type ParallaxBackgroundImplementer interface {
	Class
}

/*
   A ParallaxLayer must be the child of a [ParallaxBackground] node. All child nodes will be affected by the parallax scrolling of this layer.
*/
type ParallaxLayer struct {
	Node2D
}

func (o *ParallaxLayer) baseClass() string {
	return "ParallaxLayer"
}

/*
   Set the motion scale of the ParallaxLayer. If an axis is set to 0 then it will not move at all, it will stick with the camera.
*/
func (o *ParallaxLayer) SetMotionScale(scale *Vector2) {
	log.Println("Calling ParallaxLayer.SetMotionScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_motion_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the motion scale of the ParallaxLayer.
*/
func (o *ParallaxLayer) GetMotionScale() *Vector2 {
	log.Println("Calling ParallaxLayer.GetMotionScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_motion_scale", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *ParallaxLayer) SetMotionOffset(offset *Vector2) {
	log.Println("Calling ParallaxLayer.SetMotionOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_motion_offset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParallaxLayer) GetMotionOffset() *Vector2 {
	log.Println("Calling ParallaxLayer.GetMotionOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_motion_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set the mirroring of the ParallaxLayer. If an axis is set to 0 then that axis will have no mirroring.
*/
func (o *ParallaxLayer) SetMirroring(mirror *Vector2) {
	log.Println("Calling ParallaxLayer.SetMirroring()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mirror)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mirroring", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the mirroring of the ParallaxLayer.
*/
func (o *ParallaxLayer) GetMirroring() *Vector2 {
	log.Println("Calling ParallaxLayer.GetMirroring()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mirroring", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   ParallaxLayerImplementer is an interface for ParallaxLayer objects.
*/
type ParallaxLayerImplementer interface {
	Class
}

/*

 */
type TouchScreenButton struct {
	Node2D
}

func (o *TouchScreenButton) baseClass() string {
	return "TouchScreenButton"
}

/*

 */
func (o *TouchScreenButton) SetTexture(texture *Texture) {
	log.Println("Calling TouchScreenButton.SetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TouchScreenButton) GetTexture() *Texture {
	log.Println("Calling TouchScreenButton.GetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TouchScreenButton) SetTexturePressed(texturePressed *Texture) {
	log.Println("Calling TouchScreenButton.SetTexturePressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texturePressed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture_pressed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TouchScreenButton) GetTexturePressed() *Texture {
	log.Println("Calling TouchScreenButton.GetTexturePressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture_pressed", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TouchScreenButton) SetBitmask(bitmask *BitMap) {
	log.Println("Calling TouchScreenButton.SetBitmask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bitmask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bitmask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TouchScreenButton) GetBitmask() *BitMap {
	log.Println("Calling TouchScreenButton.GetBitmask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bitmask", goArguments, "*BitMap")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*BitMap)

	return returnValue

}

/*

 */
func (o *TouchScreenButton) SetShape(shape *Shape2D) {
	log.Println("Calling TouchScreenButton.SetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TouchScreenButton) GetShape() *Shape2D {
	log.Println("Calling TouchScreenButton.GetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shape", goArguments, "*Shape2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Shape2D)

	return returnValue

}

/*

 */
func (o *TouchScreenButton) SetShapeCentered(bool bool) {
	log.Println("Calling TouchScreenButton.SetShapeCentered()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bool)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shape_centered", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TouchScreenButton) IsShapeCentered() bool {
	log.Println("Calling TouchScreenButton.IsShapeCentered()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_shape_centered", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *TouchScreenButton) SetShapeVisible(bool bool) {
	log.Println("Calling TouchScreenButton.SetShapeVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bool)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shape_visible", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TouchScreenButton) IsShapeVisible() bool {
	log.Println("Calling TouchScreenButton.IsShapeVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_shape_visible", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *TouchScreenButton) SetAction(action string) {
	log.Println("Calling TouchScreenButton.SetAction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_action", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TouchScreenButton) GetAction() string {
	log.Println("Calling TouchScreenButton.GetAction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_action", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *TouchScreenButton) SetVisibilityMode(mode int64) {
	log.Println("Calling TouchScreenButton.SetVisibilityMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_visibility_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TouchScreenButton) GetVisibilityMode() int64 {
	log.Println("Calling TouchScreenButton.GetVisibilityMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_visibility_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *TouchScreenButton) SetPassbyPress(enabled bool) {
	log.Println("Calling TouchScreenButton.SetPassbyPress()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_passby_press", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TouchScreenButton) IsPassbyPressEnabled() bool {
	log.Println("Calling TouchScreenButton.IsPassbyPressEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_passby_press_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *TouchScreenButton) IsPressed() bool {
	log.Println("Calling TouchScreenButton.IsPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_pressed", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *TouchScreenButton) X_Input(arg0 *InputEvent) {
	log.Println("Calling TouchScreenButton.X_Input()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   TouchScreenButtonImplementer is an interface for TouchScreenButton objects.
*/
type TouchScreenButtonImplementer interface {
	Class
}

/*

 */
type RemoteTransform2D struct {
	Node2D
}

func (o *RemoteTransform2D) baseClass() string {
	return "RemoteTransform2D"
}

/*

 */
func (o *RemoteTransform2D) SetRemoteNode(path *NodePath) {
	log.Println("Calling RemoteTransform2D.SetRemoteNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_remote_node", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RemoteTransform2D) GetRemoteNode() *NodePath {
	log.Println("Calling RemoteTransform2D.GetRemoteNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_remote_node", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *RemoteTransform2D) SetUseGlobalCoordinates(useGlobalCoordinates bool) {
	log.Println("Calling RemoteTransform2D.SetUseGlobalCoordinates()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(useGlobalCoordinates)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_global_coordinates", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RemoteTransform2D) GetUseGlobalCoordinates() bool {
	log.Println("Calling RemoteTransform2D.GetUseGlobalCoordinates()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_use_global_coordinates", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *RemoteTransform2D) SetUpdatePosition(updateRemotePosition bool) {
	log.Println("Calling RemoteTransform2D.SetUpdatePosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(updateRemotePosition)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_update_position", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RemoteTransform2D) GetUpdatePosition() bool {
	log.Println("Calling RemoteTransform2D.GetUpdatePosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_update_position", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *RemoteTransform2D) SetUpdateRotation(updateRemoteRotation bool) {
	log.Println("Calling RemoteTransform2D.SetUpdateRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(updateRemoteRotation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_update_rotation", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RemoteTransform2D) GetUpdateRotation() bool {
	log.Println("Calling RemoteTransform2D.GetUpdateRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_update_rotation", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *RemoteTransform2D) SetUpdateScale(updateRemoteScale bool) {
	log.Println("Calling RemoteTransform2D.SetUpdateScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(updateRemoteScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_update_scale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RemoteTransform2D) GetUpdateScale() bool {
	log.Println("Calling RemoteTransform2D.GetUpdateScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_update_scale", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   RemoteTransform2DImplementer is an interface for RemoteTransform2D objects.
*/
type RemoteTransform2DImplementer interface {
	Class
}

/*

 */
type ArrayMesh struct {
	Mesh
}

func (o *ArrayMesh) baseClass() string {
	return "ArrayMesh"
}

/*

 */
func (o *ArrayMesh) AddBlendShape(name string) {
	log.Println("Calling ArrayMesh.AddBlendShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_blend_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ArrayMesh) GetBlendShapeCount() int64 {
	log.Println("Calling ArrayMesh.GetBlendShapeCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_blend_shape_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ArrayMesh) GetBlendShapeName(index int64) string {
	log.Println("Calling ArrayMesh.GetBlendShapeName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_blend_shape_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *ArrayMesh) ClearBlendShapes() {
	log.Println("Calling ArrayMesh.ClearBlendShapes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_blend_shapes", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ArrayMesh) SetBlendShapeMode(mode int64) {
	log.Println("Calling ArrayMesh.SetBlendShapeMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_blend_shape_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ArrayMesh) GetBlendShapeMode() int64 {
	log.Println("Calling ArrayMesh.GetBlendShapeMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_blend_shape_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Create a new surface ([method get_surface_count] that will become surf_idx for this. Surfaces are created to be rendered using a "primitive", which may be PRIMITIVE_POINTS, PRIMITIVE_LINES, PRIMITIVE_LINE_STRIP, PRIMITIVE_LINE_LOOP, PRIMITIVE_TRIANGLES, PRIMITIVE_TRIANGLE_STRIP, PRIMITIVE_TRIANGLE_FAN. (As a note, when using indices, it is recommended to only use just points, lines or triangles).
*/
func (o *ArrayMesh) AddSurfaceFromArrays(primitive int64, arrays *Array, blendShapes *Array, compressFlags int64) {
	log.Println("Calling ArrayMesh.AddSurfaceFromArrays()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(primitive)
	goArguments[1] = reflect.ValueOf(arrays)
	goArguments[2] = reflect.ValueOf(blendShapes)
	goArguments[3] = reflect.ValueOf(compressFlags)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_surface_from_arrays", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the amount of surfaces that the [ArrayMesh] holds.
*/
func (o *ArrayMesh) GetSurfaceCount() int64 {
	log.Println("Calling ArrayMesh.GetSurfaceCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_surface_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Remove a surface at position surf_idx, shifting greater surfaces one surf_idx slot down.
*/
func (o *ArrayMesh) SurfaceRemove(surfIdx int64) {
	log.Println("Calling ArrayMesh.SurfaceRemove()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(surfIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "surface_remove", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the length in vertices of the vertex array in the requested surface (see [method add_surface]).
*/
func (o *ArrayMesh) SurfaceGetArrayLen(surfIdx int64) int64 {
	log.Println("Calling ArrayMesh.SurfaceGetArrayLen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(surfIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "surface_get_array_len", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the length in indices of the index array in the requested surface (see [method add_surface]).
*/
func (o *ArrayMesh) SurfaceGetArrayIndexLen(surfIdx int64) int64 {
	log.Println("Calling ArrayMesh.SurfaceGetArrayIndexLen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(surfIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "surface_get_array_index_len", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the format mask of the requested surface (see [method add_surface]).
*/
func (o *ArrayMesh) SurfaceGetFormat(surfIdx int64) int64 {
	log.Println("Calling ArrayMesh.SurfaceGetFormat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(surfIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "surface_get_format", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the primitive type of the requested surface (see [method add_surface]).
*/
func (o *ArrayMesh) SurfaceGetPrimitiveType(surfIdx int64) int64 {
	log.Println("Calling ArrayMesh.SurfaceGetPrimitiveType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(surfIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "surface_get_primitive_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ArrayMesh) SurfaceSetMaterial(surfIdx int64, material *Material) {
	log.Println("Calling ArrayMesh.SurfaceSetMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(surfIdx)
	goArguments[1] = reflect.ValueOf(material)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "surface_set_material", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return a [Material] in a given surface. Surface is rendered using this material.
*/
func (o *ArrayMesh) SurfaceGetMaterial(surfIdx int64) *Material {
	log.Println("Calling ArrayMesh.SurfaceGetMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(surfIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "surface_get_material", goArguments, "*Material")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Material)

	return returnValue

}

/*
   Set a [Material] for a given surface. Surface will be rendered using this material.
*/
func (o *ArrayMesh) SurfaceSetName(surfIdx int64, name string) {
	log.Println("Calling ArrayMesh.SurfaceSetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(surfIdx)
	goArguments[1] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "surface_set_name", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ArrayMesh) SurfaceGetName(surfIdx int64) string {
	log.Println("Calling ArrayMesh.SurfaceGetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(surfIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "surface_get_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *ArrayMesh) SurfaceGetArrays(surfIdx int64) *Array {
	log.Println("Calling ArrayMesh.SurfaceGetArrays()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(surfIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "surface_get_arrays", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *ArrayMesh) SurfaceGetBlendShapeArrays(surfIdx int64) *Array {
	log.Println("Calling ArrayMesh.SurfaceGetBlendShapeArrays()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(surfIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "surface_get_blend_shape_arrays", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *ArrayMesh) CenterGeometry() {
	log.Println("Calling ArrayMesh.CenterGeometry()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "center_geometry", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ArrayMesh) RegenNormalmaps() {
	log.Println("Calling ArrayMesh.RegenNormalmaps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "regen_normalmaps", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ArrayMesh) SetCustomAabb(aabb *Rect3) {
	log.Println("Calling ArrayMesh.SetCustomAabb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aabb)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_aabb", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ArrayMesh) GetCustomAabb() *Rect3 {
	log.Println("Calling ArrayMesh.GetCustomAabb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_custom_aabb", goArguments, "*Rect3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect3)

	return returnValue

}

/*
   ArrayMeshImplementer is an interface for ArrayMesh objects.
*/
type ArrayMeshImplementer interface {
	Class
}

/*
   Base class for all primitive meshes. Handles applying a [Material] to a primitive mesh.
*/
type PrimitiveMesh struct {
	Mesh
}

func (o *PrimitiveMesh) baseClass() string {
	return "PrimitiveMesh"
}

/*
   Undocumented
*/
func (o *PrimitiveMesh) X_Update() {
	log.Println("Calling PrimitiveMesh.X_Update()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_update", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PrimitiveMesh) SetMaterial(material *Material) {
	log.Println("Calling PrimitiveMesh.SetMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(material)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_material", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PrimitiveMesh) GetMaterial() *Material {
	log.Println("Calling PrimitiveMesh.GetMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_material", goArguments, "*Material")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Material)

	return returnValue

}

/*

 */
func (o *PrimitiveMesh) GetMeshArrays() *Array {
	log.Println("Calling PrimitiveMesh.GetMeshArrays()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mesh_arrays", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   PrimitiveMeshImplementer is an interface for PrimitiveMesh objects.
*/
type PrimitiveMeshImplementer interface {
	Class
}

/*
   Class representing a capsule-shaped [PrimitiveMesh].
*/
type CapsuleMesh struct {
	PrimitiveMesh
}

func (o *CapsuleMesh) baseClass() string {
	return "CapsuleMesh"
}

/*

 */
func (o *CapsuleMesh) SetRadius(radius float64) {
	log.Println("Calling CapsuleMesh.SetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_radius", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CapsuleMesh) GetRadius() float64 {
	log.Println("Calling CapsuleMesh.GetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_radius", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *CapsuleMesh) SetMidHeight(midHeight float64) {
	log.Println("Calling CapsuleMesh.SetMidHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(midHeight)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mid_height", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CapsuleMesh) GetMidHeight() float64 {
	log.Println("Calling CapsuleMesh.GetMidHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mid_height", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *CapsuleMesh) SetRadialSegments(segments int64) {
	log.Println("Calling CapsuleMesh.SetRadialSegments()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(segments)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_radial_segments", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CapsuleMesh) GetRadialSegments() int64 {
	log.Println("Calling CapsuleMesh.GetRadialSegments()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_radial_segments", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CapsuleMesh) SetRings(rings int64) {
	log.Println("Calling CapsuleMesh.SetRings()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rings)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rings", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CapsuleMesh) GetRings() int64 {
	log.Println("Calling CapsuleMesh.GetRings()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rings", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   CapsuleMeshImplementer is an interface for CapsuleMesh objects.
*/
type CapsuleMeshImplementer interface {
	Class
}

/*
   Generate an axis-aligned cuboid [PrimitiveMesh].
*/
type CubeMesh struct {
	PrimitiveMesh
}

func (o *CubeMesh) baseClass() string {
	return "CubeMesh"
}

/*

 */
func (o *CubeMesh) SetSize(size *Vector3) {
	log.Println("Calling CubeMesh.SetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CubeMesh) GetSize() *Vector3 {
	log.Println("Calling CubeMesh.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *CubeMesh) SetSubdivideWidth(subdivide int64) {
	log.Println("Calling CubeMesh.SetSubdivideWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(subdivide)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_subdivide_width", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CubeMesh) GetSubdivideWidth() int64 {
	log.Println("Calling CubeMesh.GetSubdivideWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_subdivide_width", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CubeMesh) SetSubdivideHeight(divisions int64) {
	log.Println("Calling CubeMesh.SetSubdivideHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(divisions)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_subdivide_height", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CubeMesh) GetSubdivideHeight() int64 {
	log.Println("Calling CubeMesh.GetSubdivideHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_subdivide_height", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CubeMesh) SetSubdivideDepth(divisions int64) {
	log.Println("Calling CubeMesh.SetSubdivideDepth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(divisions)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_subdivide_depth", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CubeMesh) GetSubdivideDepth() int64 {
	log.Println("Calling CubeMesh.GetSubdivideDepth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_subdivide_depth", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   CubeMeshImplementer is an interface for CubeMesh objects.
*/
type CubeMeshImplementer interface {
	Class
}

/*
   Class representing a cylindrical [PrimitiveMesh].
*/
type CylinderMesh struct {
	PrimitiveMesh
}

func (o *CylinderMesh) baseClass() string {
	return "CylinderMesh"
}

/*

 */
func (o *CylinderMesh) SetTopRadius(radius float64) {
	log.Println("Calling CylinderMesh.SetTopRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_top_radius", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CylinderMesh) GetTopRadius() float64 {
	log.Println("Calling CylinderMesh.GetTopRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_top_radius", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *CylinderMesh) SetBottomRadius(radius float64) {
	log.Println("Calling CylinderMesh.SetBottomRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bottom_radius", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CylinderMesh) GetBottomRadius() float64 {
	log.Println("Calling CylinderMesh.GetBottomRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bottom_radius", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *CylinderMesh) SetHeight(height float64) {
	log.Println("Calling CylinderMesh.SetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(height)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_height", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CylinderMesh) GetHeight() float64 {
	log.Println("Calling CylinderMesh.GetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_height", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *CylinderMesh) SetRadialSegments(segments int64) {
	log.Println("Calling CylinderMesh.SetRadialSegments()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(segments)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_radial_segments", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CylinderMesh) GetRadialSegments() int64 {
	log.Println("Calling CylinderMesh.GetRadialSegments()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_radial_segments", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CylinderMesh) SetRings(rings int64) {
	log.Println("Calling CylinderMesh.SetRings()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rings)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rings", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CylinderMesh) GetRings() int64 {
	log.Println("Calling CylinderMesh.GetRings()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rings", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   CylinderMeshImplementer is an interface for CylinderMesh objects.
*/
type CylinderMeshImplementer interface {
	Class
}

/*
   Class representing a planar [PrimitiveMesh]. This flat mesh does not have a thickness.
*/
type PlaneMesh struct {
	PrimitiveMesh
}

func (o *PlaneMesh) baseClass() string {
	return "PlaneMesh"
}

/*

 */
func (o *PlaneMesh) SetSize(size *Vector2) {
	log.Println("Calling PlaneMesh.SetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PlaneMesh) GetSize() *Vector2 {
	log.Println("Calling PlaneMesh.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *PlaneMesh) SetSubdivideWidth(subdivide int64) {
	log.Println("Calling PlaneMesh.SetSubdivideWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(subdivide)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_subdivide_width", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PlaneMesh) GetSubdivideWidth() int64 {
	log.Println("Calling PlaneMesh.GetSubdivideWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_subdivide_width", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PlaneMesh) SetSubdivideDepth(subdivide int64) {
	log.Println("Calling PlaneMesh.SetSubdivideDepth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(subdivide)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_subdivide_depth", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PlaneMesh) GetSubdivideDepth() int64 {
	log.Println("Calling PlaneMesh.GetSubdivideDepth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_subdivide_depth", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   PlaneMeshImplementer is an interface for PlaneMesh objects.
*/
type PlaneMeshImplementer interface {
	Class
}

/*
   Class representing a prism-shaped [PrimitiveMesh].
*/
type PrismMesh struct {
	PrimitiveMesh
}

func (o *PrismMesh) baseClass() string {
	return "PrismMesh"
}

/*

 */
func (o *PrismMesh) SetLeftToRight(leftToRight float64) {
	log.Println("Calling PrismMesh.SetLeftToRight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(leftToRight)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_left_to_right", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PrismMesh) GetLeftToRight() float64 {
	log.Println("Calling PrismMesh.GetLeftToRight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_left_to_right", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *PrismMesh) SetSize(size *Vector3) {
	log.Println("Calling PrismMesh.SetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PrismMesh) GetSize() *Vector3 {
	log.Println("Calling PrismMesh.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *PrismMesh) SetSubdivideWidth(segments int64) {
	log.Println("Calling PrismMesh.SetSubdivideWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(segments)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_subdivide_width", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PrismMesh) GetSubdivideWidth() int64 {
	log.Println("Calling PrismMesh.GetSubdivideWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_subdivide_width", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PrismMesh) SetSubdivideHeight(segments int64) {
	log.Println("Calling PrismMesh.SetSubdivideHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(segments)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_subdivide_height", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PrismMesh) GetSubdivideHeight() int64 {
	log.Println("Calling PrismMesh.GetSubdivideHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_subdivide_height", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PrismMesh) SetSubdivideDepth(segments int64) {
	log.Println("Calling PrismMesh.SetSubdivideDepth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(segments)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_subdivide_depth", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PrismMesh) GetSubdivideDepth() int64 {
	log.Println("Calling PrismMesh.GetSubdivideDepth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_subdivide_depth", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   PrismMeshImplementer is an interface for PrismMesh objects.
*/
type PrismMeshImplementer interface {
	Class
}

/*
   Class representing a square mesh with size (2,2,0). Consider using a [PlaneMesh] if you require a differently sized plane.
*/
type QuadMesh struct {
	PrimitiveMesh
}

func (o *QuadMesh) baseClass() string {
	return "QuadMesh"
}

/*
   QuadMeshImplementer is an interface for QuadMesh objects.
*/
type QuadMeshImplementer interface {
	Class
}

/*
   Class representing a spherical [PrimitiveMesh].
*/
type SphereMesh struct {
	PrimitiveMesh
}

func (o *SphereMesh) baseClass() string {
	return "SphereMesh"
}

/*

 */
func (o *SphereMesh) SetRadius(radius float64) {
	log.Println("Calling SphereMesh.SetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_radius", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SphereMesh) GetRadius() float64 {
	log.Println("Calling SphereMesh.GetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_radius", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SphereMesh) SetHeight(height float64) {
	log.Println("Calling SphereMesh.SetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(height)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_height", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SphereMesh) GetHeight() float64 {
	log.Println("Calling SphereMesh.GetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_height", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SphereMesh) SetRadialSegments(radialSegments int64) {
	log.Println("Calling SphereMesh.SetRadialSegments()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radialSegments)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_radial_segments", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SphereMesh) GetRadialSegments() int64 {
	log.Println("Calling SphereMesh.GetRadialSegments()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_radial_segments", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SphereMesh) SetRings(rings int64) {
	log.Println("Calling SphereMesh.SetRings()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rings)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rings", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SphereMesh) GetRings() int64 {
	log.Println("Calling SphereMesh.GetRings()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rings", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SphereMesh) SetIsHemisphere(isHemisphere bool) {
	log.Println("Calling SphereMesh.SetIsHemisphere()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(isHemisphere)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_is_hemisphere", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SphereMesh) GetIsHemisphere() bool {
	log.Println("Calling SphereMesh.GetIsHemisphere()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_is_hemisphere", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   SphereMeshImplementer is an interface for SphereMesh objects.
*/
type SphereMeshImplementer interface {
	Class
}

/*

 */
type SpatialMaterial struct {
	Material
}

func (o *SpatialMaterial) baseClass() string {
	return "SpatialMaterial"
}

/*

 */
func (o *SpatialMaterial) SetAlbedo(albedo *Color) {
	log.Println("Calling SpatialMaterial.SetAlbedo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(albedo)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_albedo", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetAlbedo() *Color {
	log.Println("Calling SpatialMaterial.GetAlbedo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_albedo", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetSpecular(specular float64) {
	log.Println("Calling SpatialMaterial.SetSpecular()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(specular)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_specular", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetSpecular() float64 {
	log.Println("Calling SpatialMaterial.GetSpecular()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_specular", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetMetallic(metallic float64) {
	log.Println("Calling SpatialMaterial.SetMetallic()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(metallic)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_metallic", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetMetallic() float64 {
	log.Println("Calling SpatialMaterial.GetMetallic()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_metallic", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetRoughness(roughness float64) {
	log.Println("Calling SpatialMaterial.SetRoughness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(roughness)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_roughness", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetRoughness() float64 {
	log.Println("Calling SpatialMaterial.GetRoughness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_roughness", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetEmission(emission *Color) {
	log.Println("Calling SpatialMaterial.SetEmission()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(emission)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emission", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetEmission() *Color {
	log.Println("Calling SpatialMaterial.GetEmission()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_emission", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetEmissionEnergy(emissionEnergy float64) {
	log.Println("Calling SpatialMaterial.SetEmissionEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(emissionEnergy)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emission_energy", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetEmissionEnergy() float64 {
	log.Println("Calling SpatialMaterial.GetEmissionEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_emission_energy", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetNormalScale(normalScale float64) {
	log.Println("Calling SpatialMaterial.SetNormalScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(normalScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_normal_scale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetNormalScale() float64 {
	log.Println("Calling SpatialMaterial.GetNormalScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_normal_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetRim(rim float64) {
	log.Println("Calling SpatialMaterial.SetRim()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rim)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rim", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetRim() float64 {
	log.Println("Calling SpatialMaterial.GetRim()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rim", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetRimTint(rimTint float64) {
	log.Println("Calling SpatialMaterial.SetRimTint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rimTint)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rim_tint", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetRimTint() float64 {
	log.Println("Calling SpatialMaterial.GetRimTint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rim_tint", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetClearcoat(clearcoat float64) {
	log.Println("Calling SpatialMaterial.SetClearcoat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(clearcoat)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_clearcoat", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetClearcoat() float64 {
	log.Println("Calling SpatialMaterial.GetClearcoat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_clearcoat", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetClearcoatGloss(clearcoatGloss float64) {
	log.Println("Calling SpatialMaterial.SetClearcoatGloss()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(clearcoatGloss)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_clearcoat_gloss", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetClearcoatGloss() float64 {
	log.Println("Calling SpatialMaterial.GetClearcoatGloss()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_clearcoat_gloss", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetAnisotropy(anisotropy float64) {
	log.Println("Calling SpatialMaterial.SetAnisotropy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anisotropy)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_anisotropy", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetAnisotropy() float64 {
	log.Println("Calling SpatialMaterial.GetAnisotropy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_anisotropy", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetDepthScale(depthScale float64) {
	log.Println("Calling SpatialMaterial.SetDepthScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(depthScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_depth_scale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetDepthScale() float64 {
	log.Println("Calling SpatialMaterial.GetDepthScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_depth_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetSubsurfaceScatteringStrength(strength float64) {
	log.Println("Calling SpatialMaterial.SetSubsurfaceScatteringStrength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(strength)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_subsurface_scattering_strength", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetSubsurfaceScatteringStrength() float64 {
	log.Println("Calling SpatialMaterial.GetSubsurfaceScatteringStrength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_subsurface_scattering_strength", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetTransmission(transmission *Color) {
	log.Println("Calling SpatialMaterial.SetTransmission()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(transmission)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_transmission", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetTransmission() *Color {
	log.Println("Calling SpatialMaterial.GetTransmission()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_transmission", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetRefraction(refraction float64) {
	log.Println("Calling SpatialMaterial.SetRefraction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(refraction)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_refraction", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetRefraction() float64 {
	log.Println("Calling SpatialMaterial.GetRefraction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_refraction", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetLineWidth(lineWidth float64) {
	log.Println("Calling SpatialMaterial.SetLineWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(lineWidth)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_line_width", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetLineWidth() float64 {
	log.Println("Calling SpatialMaterial.GetLineWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_line_width", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetPointSize(pointSize float64) {
	log.Println("Calling SpatialMaterial.SetPointSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pointSize)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetPointSize() float64 {
	log.Println("Calling SpatialMaterial.GetPointSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_size", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetDetailUv(detailUv int64) {
	log.Println("Calling SpatialMaterial.SetDetailUv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(detailUv)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_detail_uv", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetDetailUv() int64 {
	log.Println("Calling SpatialMaterial.GetDetailUv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_detail_uv", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetBlendMode(blendMode int64) {
	log.Println("Calling SpatialMaterial.SetBlendMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(blendMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_blend_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetBlendMode() int64 {
	log.Println("Calling SpatialMaterial.GetBlendMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_blend_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetDepthDrawMode(depthDrawMode int64) {
	log.Println("Calling SpatialMaterial.SetDepthDrawMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(depthDrawMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_depth_draw_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetDepthDrawMode() int64 {
	log.Println("Calling SpatialMaterial.GetDepthDrawMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_depth_draw_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetCullMode(cullMode int64) {
	log.Println("Calling SpatialMaterial.SetCullMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(cullMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cull_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetCullMode() int64 {
	log.Println("Calling SpatialMaterial.GetCullMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cull_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetDiffuseMode(diffuseMode int64) {
	log.Println("Calling SpatialMaterial.SetDiffuseMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(diffuseMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_diffuse_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetDiffuseMode() int64 {
	log.Println("Calling SpatialMaterial.GetDiffuseMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_diffuse_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetSpecularMode(specularMode int64) {
	log.Println("Calling SpatialMaterial.SetSpecularMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(specularMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_specular_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetSpecularMode() int64 {
	log.Println("Calling SpatialMaterial.GetSpecularMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_specular_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetFlag(flag int64, enable bool) {
	log.Println("Calling SpatialMaterial.SetFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(flag)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flag", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetFlag(flag int64) bool {
	log.Println("Calling SpatialMaterial.GetFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flag)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_flag", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetFeature(feature int64, enable bool) {
	log.Println("Calling SpatialMaterial.SetFeature()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(feature)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_feature", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetFeature(feature int64) bool {
	log.Println("Calling SpatialMaterial.GetFeature()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(feature)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_feature", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetTexture(param int64, texture *Texture) {
	log.Println("Calling SpatialMaterial.SetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetTexture(param int64) *Texture {
	log.Println("Calling SpatialMaterial.GetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetDetailBlendMode(detailBlendMode int64) {
	log.Println("Calling SpatialMaterial.SetDetailBlendMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(detailBlendMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_detail_blend_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetDetailBlendMode() int64 {
	log.Println("Calling SpatialMaterial.GetDetailBlendMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_detail_blend_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetUv1Scale(scale *Vector3) {
	log.Println("Calling SpatialMaterial.SetUv1Scale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_uv1_scale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetUv1Scale() *Vector3 {
	log.Println("Calling SpatialMaterial.GetUv1Scale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_uv1_scale", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetUv1Offset(offset *Vector3) {
	log.Println("Calling SpatialMaterial.SetUv1Offset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_uv1_offset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetUv1Offset() *Vector3 {
	log.Println("Calling SpatialMaterial.GetUv1Offset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_uv1_offset", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetUv1TriplanarBlendSharpness(sharpness float64) {
	log.Println("Calling SpatialMaterial.SetUv1TriplanarBlendSharpness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sharpness)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_uv1_triplanar_blend_sharpness", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetUv1TriplanarBlendSharpness() float64 {
	log.Println("Calling SpatialMaterial.GetUv1TriplanarBlendSharpness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_uv1_triplanar_blend_sharpness", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetUv2Scale(scale *Vector3) {
	log.Println("Calling SpatialMaterial.SetUv2Scale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_uv2_scale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetUv2Scale() *Vector3 {
	log.Println("Calling SpatialMaterial.GetUv2Scale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_uv2_scale", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetUv2Offset(offset *Vector3) {
	log.Println("Calling SpatialMaterial.SetUv2Offset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_uv2_offset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetUv2Offset() *Vector3 {
	log.Println("Calling SpatialMaterial.GetUv2Offset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_uv2_offset", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetUv2TriplanarBlendSharpness(sharpness float64) {
	log.Println("Calling SpatialMaterial.SetUv2TriplanarBlendSharpness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sharpness)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_uv2_triplanar_blend_sharpness", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetUv2TriplanarBlendSharpness() float64 {
	log.Println("Calling SpatialMaterial.GetUv2TriplanarBlendSharpness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_uv2_triplanar_blend_sharpness", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetBillboardMode(mode int64) {
	log.Println("Calling SpatialMaterial.SetBillboardMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_billboard_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetBillboardMode() int64 {
	log.Println("Calling SpatialMaterial.GetBillboardMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_billboard_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetParticlesAnimHFrames(frames int64) {
	log.Println("Calling SpatialMaterial.SetParticlesAnimHFrames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(frames)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_particles_anim_h_frames", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetParticlesAnimHFrames() int64 {
	log.Println("Calling SpatialMaterial.GetParticlesAnimHFrames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_particles_anim_h_frames", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetParticlesAnimVFrames(frames int64) {
	log.Println("Calling SpatialMaterial.SetParticlesAnimVFrames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(frames)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_particles_anim_v_frames", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetParticlesAnimVFrames() int64 {
	log.Println("Calling SpatialMaterial.GetParticlesAnimVFrames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_particles_anim_v_frames", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetParticlesAnimLoop(frames int64) {
	log.Println("Calling SpatialMaterial.SetParticlesAnimLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(frames)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_particles_anim_loop", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetParticlesAnimLoop() int64 {
	log.Println("Calling SpatialMaterial.GetParticlesAnimLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_particles_anim_loop", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetDepthDeepParallax(enable bool) {
	log.Println("Calling SpatialMaterial.SetDepthDeepParallax()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_depth_deep_parallax", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) IsDepthDeepParallaxEnabled() bool {
	log.Println("Calling SpatialMaterial.IsDepthDeepParallaxEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_depth_deep_parallax_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetDepthDeepParallaxMinLayers(layer int64) {
	log.Println("Calling SpatialMaterial.SetDepthDeepParallaxMinLayers()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_depth_deep_parallax_min_layers", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetDepthDeepParallaxMinLayers() int64 {
	log.Println("Calling SpatialMaterial.GetDepthDeepParallaxMinLayers()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_depth_deep_parallax_min_layers", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetDepthDeepParallaxMaxLayers(layer int64) {
	log.Println("Calling SpatialMaterial.SetDepthDeepParallaxMaxLayers()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_depth_deep_parallax_max_layers", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetDepthDeepParallaxMaxLayers() int64 {
	log.Println("Calling SpatialMaterial.GetDepthDeepParallaxMaxLayers()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_depth_deep_parallax_max_layers", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetGrow(amount float64) {
	log.Println("Calling SpatialMaterial.SetGrow()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_grow", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetGrow() float64 {
	log.Println("Calling SpatialMaterial.GetGrow()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_grow", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetAoLightAffect(amount float64) {
	log.Println("Calling SpatialMaterial.SetAoLightAffect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ao_light_affect", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetAoLightAffect() float64 {
	log.Println("Calling SpatialMaterial.GetAoLightAffect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ao_light_affect", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetAlphaScissorThreshold(threshold float64) {
	log.Println("Calling SpatialMaterial.SetAlphaScissorThreshold()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(threshold)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_alpha_scissor_threshold", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetAlphaScissorThreshold() float64 {
	log.Println("Calling SpatialMaterial.GetAlphaScissorThreshold()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_alpha_scissor_threshold", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetGrowEnabled(enable bool) {
	log.Println("Calling SpatialMaterial.SetGrowEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_grow_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) IsGrowEnabled() bool {
	log.Println("Calling SpatialMaterial.IsGrowEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_grow_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetMetallicTextureChannel(channel int64) {
	log.Println("Calling SpatialMaterial.SetMetallicTextureChannel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(channel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_metallic_texture_channel", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetMetallicTextureChannel() int64 {
	log.Println("Calling SpatialMaterial.GetMetallicTextureChannel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_metallic_texture_channel", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetRoughnessTextureChannel(channel int64) {
	log.Println("Calling SpatialMaterial.SetRoughnessTextureChannel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(channel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_roughness_texture_channel", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetRoughnessTextureChannel() int64 {
	log.Println("Calling SpatialMaterial.GetRoughnessTextureChannel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_roughness_texture_channel", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetAoTextureChannel(channel int64) {
	log.Println("Calling SpatialMaterial.SetAoTextureChannel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(channel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ao_texture_channel", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetAoTextureChannel() int64 {
	log.Println("Calling SpatialMaterial.GetAoTextureChannel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ao_texture_channel", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetRefractionTextureChannel(channel int64) {
	log.Println("Calling SpatialMaterial.SetRefractionTextureChannel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(channel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_refraction_texture_channel", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetRefractionTextureChannel() int64 {
	log.Println("Calling SpatialMaterial.GetRefractionTextureChannel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_refraction_texture_channel", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetProximityFade(enabled bool) {
	log.Println("Calling SpatialMaterial.SetProximityFade()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_proximity_fade", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) IsProximityFadeEnabled() bool {
	log.Println("Calling SpatialMaterial.IsProximityFadeEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_proximity_fade_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetProximityFadeDistance(distance float64) {
	log.Println("Calling SpatialMaterial.SetProximityFadeDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(distance)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_proximity_fade_distance", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetProximityFadeDistance() float64 {
	log.Println("Calling SpatialMaterial.GetProximityFadeDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_proximity_fade_distance", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetDistanceFade(enabled bool) {
	log.Println("Calling SpatialMaterial.SetDistanceFade()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_distance_fade", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) IsDistanceFadeEnabled() bool {
	log.Println("Calling SpatialMaterial.IsDistanceFadeEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_distance_fade_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetDistanceFadeMaxDistance(distance float64) {
	log.Println("Calling SpatialMaterial.SetDistanceFadeMaxDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(distance)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_distance_fade_max_distance", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetDistanceFadeMaxDistance() float64 {
	log.Println("Calling SpatialMaterial.GetDistanceFadeMaxDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_distance_fade_max_distance", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetDistanceFadeMinDistance(distance float64) {
	log.Println("Calling SpatialMaterial.SetDistanceFadeMinDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(distance)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_distance_fade_min_distance", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) GetDistanceFadeMinDistance() float64 {
	log.Println("Calling SpatialMaterial.GetDistanceFadeMinDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_distance_fade_min_distance", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   SpatialMaterialImplementer is an interface for SpatialMaterial objects.
*/
type SpatialMaterialImplementer interface {
	Class
}

/*

 */
type ParticlesMaterial struct {
	Material
}

func (o *ParticlesMaterial) baseClass() string {
	return "ParticlesMaterial"
}

/*

 */
func (o *ParticlesMaterial) SetSpread(degrees float64) {
	log.Println("Calling ParticlesMaterial.SetSpread()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_spread", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) GetSpread() float64 {
	log.Println("Calling ParticlesMaterial.GetSpread()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_spread", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) SetFlatness(amount float64) {
	log.Println("Calling ParticlesMaterial.SetFlatness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flatness", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) GetFlatness() float64 {
	log.Println("Calling ParticlesMaterial.GetFlatness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_flatness", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) SetParam(param int64, value float64) {
	log.Println("Calling ParticlesMaterial.SetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_param", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) GetParam(param int64) float64 {
	log.Println("Calling ParticlesMaterial.GetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) SetParamRandomness(param int64, randomness float64) {
	log.Println("Calling ParticlesMaterial.SetParamRandomness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(randomness)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_param_randomness", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) GetParamRandomness(param int64) float64 {
	log.Println("Calling ParticlesMaterial.GetParamRandomness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_param_randomness", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) SetParamTexture(param int64, texture *Texture) {
	log.Println("Calling ParticlesMaterial.SetParamTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_param_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) GetParamTexture(param int64) *Texture {
	log.Println("Calling ParticlesMaterial.GetParamTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_param_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) SetColor(color *Color) {
	log.Println("Calling ParticlesMaterial.SetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) GetColor() *Color {
	log.Println("Calling ParticlesMaterial.GetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) SetColorRamp(ramp *Texture) {
	log.Println("Calling ParticlesMaterial.SetColorRamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ramp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_color_ramp", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) GetColorRamp() *Texture {
	log.Println("Calling ParticlesMaterial.GetColorRamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_color_ramp", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) SetFlag(flag int64, enable bool) {
	log.Println("Calling ParticlesMaterial.SetFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(flag)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flag", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) GetFlag(flag int64) bool {
	log.Println("Calling ParticlesMaterial.GetFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flag)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_flag", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) SetEmissionShape(shape int64) {
	log.Println("Calling ParticlesMaterial.SetEmissionShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emission_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) GetEmissionShape() int64 {
	log.Println("Calling ParticlesMaterial.GetEmissionShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_emission_shape", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) SetEmissionSphereRadius(radius float64) {
	log.Println("Calling ParticlesMaterial.SetEmissionSphereRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emission_sphere_radius", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) GetEmissionSphereRadius() float64 {
	log.Println("Calling ParticlesMaterial.GetEmissionSphereRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_emission_sphere_radius", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) SetEmissionBoxExtents(extents *Vector3) {
	log.Println("Calling ParticlesMaterial.SetEmissionBoxExtents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(extents)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emission_box_extents", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) GetEmissionBoxExtents() *Vector3 {
	log.Println("Calling ParticlesMaterial.GetEmissionBoxExtents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_emission_box_extents", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) SetEmissionPointTexture(texture *Texture) {
	log.Println("Calling ParticlesMaterial.SetEmissionPointTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emission_point_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) GetEmissionPointTexture() *Texture {
	log.Println("Calling ParticlesMaterial.GetEmissionPointTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_emission_point_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) SetEmissionNormalTexture(texture *Texture) {
	log.Println("Calling ParticlesMaterial.SetEmissionNormalTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emission_normal_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) GetEmissionNormalTexture() *Texture {
	log.Println("Calling ParticlesMaterial.GetEmissionNormalTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_emission_normal_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) SetEmissionColorTexture(texture *Texture) {
	log.Println("Calling ParticlesMaterial.SetEmissionColorTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emission_color_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) GetEmissionColorTexture() *Texture {
	log.Println("Calling ParticlesMaterial.GetEmissionColorTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_emission_color_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) SetEmissionPointCount(pointCount int64) {
	log.Println("Calling ParticlesMaterial.SetEmissionPointCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pointCount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emission_point_count", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) GetEmissionPointCount() int64 {
	log.Println("Calling ParticlesMaterial.GetEmissionPointCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_emission_point_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) SetTrailDivisor(divisor int64) {
	log.Println("Calling ParticlesMaterial.SetTrailDivisor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(divisor)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_trail_divisor", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) GetTrailDivisor() int64 {
	log.Println("Calling ParticlesMaterial.GetTrailDivisor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_trail_divisor", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) SetTrailSizeModifier(texture *CurveTexture) {
	log.Println("Calling ParticlesMaterial.SetTrailSizeModifier()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_trail_size_modifier", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) GetTrailSizeModifier() *CurveTexture {
	log.Println("Calling ParticlesMaterial.GetTrailSizeModifier()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_trail_size_modifier", goArguments, "*CurveTexture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*CurveTexture)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) SetTrailColorModifier(texture *GradientTexture) {
	log.Println("Calling ParticlesMaterial.SetTrailColorModifier()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_trail_color_modifier", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) GetTrailColorModifier() *GradientTexture {
	log.Println("Calling ParticlesMaterial.GetTrailColorModifier()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_trail_color_modifier", goArguments, "*GradientTexture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*GradientTexture)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) GetGravity() *Vector3 {
	log.Println("Calling ParticlesMaterial.GetGravity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gravity", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) SetGravity(accelVec *Vector3) {
	log.Println("Calling ParticlesMaterial.SetGravity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(accelVec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity", goArguments, "")

	log.Println("Got return value!")

}

/*
   ParticlesMaterialImplementer is an interface for ParticlesMaterial objects.
*/
type ParticlesMaterialImplementer interface {
	Class
}

/*

 */
type CurveTexture struct {
	Texture
}

func (o *CurveTexture) baseClass() string {
	return "CurveTexture"
}

/*

 */
func (o *CurveTexture) SetWidth(width int64) {
	log.Println("Calling CurveTexture.SetWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(width)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_width", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CurveTexture) SetCurve(curve *Curve) {
	log.Println("Calling CurveTexture.SetCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(curve)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_curve", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CurveTexture) GetCurve() *Curve {
	log.Println("Calling CurveTexture.GetCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_curve", goArguments, "*Curve")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Curve)

	return returnValue

}

/*
   Undocumented
*/
func (o *CurveTexture) X_Update() {
	log.Println("Calling CurveTexture.X_Update()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_update", goArguments, "")

	log.Println("Got return value!")

}

/*
   CurveTextureImplementer is an interface for CurveTexture objects.
*/
type CurveTextureImplementer interface {
	Class
}

/*
   Uses a [Gradient] to fill the texture data, the gradient will be filled from left to right using colors obtained from the gradient, this means that the texture does not necessarily represent an exact copy of the gradient, but instead an interpolation of samples obtained from the gradient at fixed steps (see [method set_width]).
*/
type GradientTexture struct {
	Texture
}

func (o *GradientTexture) baseClass() string {
	return "GradientTexture"
}

/*

 */
func (o *GradientTexture) SetGradient(gradient *Gradient) {
	log.Println("Calling GradientTexture.SetGradient()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(gradient)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gradient", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GradientTexture) GetGradient() *Gradient {
	log.Println("Calling GradientTexture.GetGradient()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gradient", goArguments, "*Gradient")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Gradient)

	return returnValue

}

/*

 */
func (o *GradientTexture) SetWidth(width int64) {
	log.Println("Calling GradientTexture.SetWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(width)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_width", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *GradientTexture) X_Update() {
	log.Println("Calling GradientTexture.X_Update()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_update", goArguments, "")

	log.Println("Got return value!")

}

/*
   GradientTextureImplementer is an interface for GradientTexture objects.
*/
type GradientTextureImplementer interface {
	Class
}

/*
   Ray shape for 3D collisions, which can be set into a [PhysicsBody] or [Area]. A ray is not really a collision body, instead it tries to separate itself from whatever is touching its far endpoint. It's often useful for characters.
*/
type RayShape struct {
	Shape
}

func (o *RayShape) baseClass() string {
	return "RayShape"
}

/*

 */
func (o *RayShape) SetLength(length float64) {
	log.Println("Calling RayShape.SetLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(length)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_length", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RayShape) GetLength() float64 {
	log.Println("Calling RayShape.GetLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_length", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   RayShapeImplementer is an interface for RayShape objects.
*/
type RayShapeImplementer interface {
	Class
}

/*
   Sphere shape for 3D collisions, which can be set into a [PhysicsBody] or [Area]. This shape is useful for modeling sphere-like 3D objects.
*/
type SphereShape struct {
	Shape
}

func (o *SphereShape) baseClass() string {
	return "SphereShape"
}

/*

 */
func (o *SphereShape) SetRadius(radius float64) {
	log.Println("Calling SphereShape.SetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_radius", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SphereShape) GetRadius() float64 {
	log.Println("Calling SphereShape.GetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_radius", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   SphereShapeImplementer is an interface for SphereShape objects.
*/
type SphereShapeImplementer interface {
	Class
}

/*
   3D box shape that can be a child of a [PhysicsBody] or [Area].
*/
type BoxShape struct {
	Shape
}

func (o *BoxShape) baseClass() string {
	return "BoxShape"
}

/*
   Set the half extents for the shape.
*/
func (o *BoxShape) SetExtents(extents *Vector3) {
	log.Println("Calling BoxShape.SetExtents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(extents)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_extents", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the half extents of the shape.
*/
func (o *BoxShape) GetExtents() *Vector3 {
	log.Println("Calling BoxShape.GetExtents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_extents", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   BoxShapeImplementer is an interface for BoxShape objects.
*/
type BoxShapeImplementer interface {
	Class
}

/*
   Capsule shape for collisions.
*/
type CapsuleShape struct {
	Shape
}

func (o *CapsuleShape) baseClass() string {
	return "CapsuleShape"
}

/*
   Set the capsule radius.
*/
func (o *CapsuleShape) SetRadius(radius float64) {
	log.Println("Calling CapsuleShape.SetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_radius", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the capsule radius.
*/
func (o *CapsuleShape) GetRadius() float64 {
	log.Println("Calling CapsuleShape.GetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_radius", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the capsule height.
*/
func (o *CapsuleShape) SetHeight(height float64) {
	log.Println("Calling CapsuleShape.SetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(height)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_height", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the capsule height.
*/
func (o *CapsuleShape) GetHeight() float64 {
	log.Println("Calling CapsuleShape.GetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_height", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   CapsuleShapeImplementer is an interface for CapsuleShape objects.
*/
type CapsuleShapeImplementer interface {
	Class
}

/*

 */
type PlaneShape struct {
	Shape
}

func (o *PlaneShape) baseClass() string {
	return "PlaneShape"
}

/*

 */
func (o *PlaneShape) SetPlane(plane *Plane) {
	log.Println("Calling PlaneShape.SetPlane()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(plane)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_plane", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PlaneShape) GetPlane() *Plane {
	log.Println("Calling PlaneShape.GetPlane()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_plane", goArguments, "*Plane")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Plane)

	return returnValue

}

/*
   PlaneShapeImplementer is an interface for PlaneShape objects.
*/
type PlaneShapeImplementer interface {
	Class
}

/*
   Convex polygon shape resource, which can be set into a [PhysicsBody] or area.
*/
type ConvexPolygonShape struct {
	Shape
}

func (o *ConvexPolygonShape) baseClass() string {
	return "ConvexPolygonShape"
}

/*

 */
func (o *ConvexPolygonShape) SetPoints(points *PoolVector3Array) {
	log.Println("Calling ConvexPolygonShape.SetPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(points)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_points", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ConvexPolygonShape) GetPoints() *PoolVector3Array {
	log.Println("Calling ConvexPolygonShape.GetPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_points", goArguments, "*PoolVector3Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector3Array)

	return returnValue

}

/*
   ConvexPolygonShapeImplementer is an interface for ConvexPolygonShape objects.
*/
type ConvexPolygonShapeImplementer interface {
	Class
}

/*
   Concave polygon shape resource, which can be set into a [PhysicsBody] or area. This shape is created by feeding a list of triangles.
*/
type ConcavePolygonShape struct {
	Shape
}

func (o *ConcavePolygonShape) baseClass() string {
	return "ConcavePolygonShape"
}

/*
   Set the faces (an array of triangles).
*/
func (o *ConcavePolygonShape) SetFaces(faces *PoolVector3Array) {
	log.Println("Calling ConcavePolygonShape.SetFaces()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(faces)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_faces", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the faces (an array of triangles).
*/
func (o *ConcavePolygonShape) GetFaces() *PoolVector3Array {
	log.Println("Calling ConcavePolygonShape.GetFaces()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_faces", goArguments, "*PoolVector3Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector3Array)

	return returnValue

}

/*
   ConcavePolygonShapeImplementer is an interface for ConcavePolygonShape objects.
*/
type ConcavePolygonShapeImplementer interface {
	Class
}

/*
   The [SurfaceTool] is used to construct a [Mesh] by specifying vertex attributes individually. It can be used to construct a [Mesh] from script. All properties except index need to be added before a call to [method add_vertex]. For example adding vertex colors and UVs looks like [codeblock] var st = SurfaceTool.new() st.begin(Mesh.PRIMITIVE_TRIANGLES) st.add_color(Color(1, 0, 0)) st.add_uv(Vector2(0, 0)) st.add_vertex(Vector3(0, 0, 0)) [/codeblock] The [SurfaceTool] now contains one vertex of a triangle which has a UV coordinate and a specified [Color]. If another vertex were added without calls to [method add_uv] or [method add_color] then the last values would be used. It is very important that vertex attributes are passed [b]before[/b] the call to [method add_vertex], failure to do this will result in an error when committing the vertex information to a mesh.
*/
type SurfaceTool struct {
	Reference
}

func (o *SurfaceTool) baseClass() string {
	return "SurfaceTool"
}

/*
   Called before adding any Vertices. Takes the primitive type as an argument (e.g. Mesh.PRIMITIVE_TRIANGLES).
*/
func (o *SurfaceTool) Begin(primitive int64) {
	log.Println("Calling SurfaceTool.Begin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(primitive)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "begin", goArguments, "")

	log.Println("Got return value!")

}

/*
   Specify position of current Vertex. Should be called after specifying other vertex properties (e.g. Color, UV).
*/
func (o *SurfaceTool) AddVertex(vertex *Vector3) {
	log.Println("Calling SurfaceTool.AddVertex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vertex)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_vertex", goArguments, "")

	log.Println("Got return value!")

}

/*
   Specify a [Color] for the next Vertex to use.
*/
func (o *SurfaceTool) AddColor(color *Color) {
	log.Println("Calling SurfaceTool.AddColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_color", goArguments, "")

	log.Println("Got return value!")

}

/*
   Specify a normal for the next Vertex to use.
*/
func (o *SurfaceTool) AddNormal(normal *Vector3) {
	log.Println("Calling SurfaceTool.AddNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(normal)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_normal", goArguments, "")

	log.Println("Got return value!")

}

/*
   Specify a Tangent for the next Vertex to use.
*/
func (o *SurfaceTool) AddTangent(tangent *Plane) {
	log.Println("Calling SurfaceTool.AddTangent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tangent)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_tangent", goArguments, "")

	log.Println("Got return value!")

}

/*
   Specify UV Coordinate for next Vertex to use.
*/
func (o *SurfaceTool) AddUv(uv *Vector2) {
	log.Println("Calling SurfaceTool.AddUv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(uv)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_uv", goArguments, "")

	log.Println("Got return value!")

}

/*
   Specify an optional second set of UV coordinates for next Vertex to use.
*/
func (o *SurfaceTool) AddUv2(uv2 *Vector2) {
	log.Println("Calling SurfaceTool.AddUv2()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(uv2)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_uv2", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add an array of bones for the next Vertex to use.
*/
func (o *SurfaceTool) AddBones(bones *PoolIntArray) {
	log.Println("Calling SurfaceTool.AddBones()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bones)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_bones", goArguments, "")

	log.Println("Got return value!")

}

/*
   Specify weight value for next Vertex to use.
*/
func (o *SurfaceTool) AddWeights(weights *PoolRealArray) {
	log.Println("Calling SurfaceTool.AddWeights()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(weights)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_weights", goArguments, "")

	log.Println("Got return value!")

}

/*
   Specify whether current Vertex (if using only Vertex arrays) or current index (if also using index arrays) should utilize smooth normals for normal calculation.
*/
func (o *SurfaceTool) AddSmoothGroup(smooth bool) {
	log.Println("Calling SurfaceTool.AddSmoothGroup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(smooth)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_smooth_group", goArguments, "")

	log.Println("Got return value!")

}

/*
   Insert a triangle fan made of array data into [Mesh] being constructed.
*/
func (o *SurfaceTool) AddTriangleFan(vertexes *PoolVector3Array, uvs *PoolVector2Array, colors *PoolColorArray, uv2S *PoolVector2Array, normals *PoolVector3Array, tangents *Array) {
	log.Println("Calling SurfaceTool.AddTriangleFan()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 6, 6)
	goArguments[0] = reflect.ValueOf(vertexes)
	goArguments[1] = reflect.ValueOf(uvs)
	goArguments[2] = reflect.ValueOf(colors)
	goArguments[3] = reflect.ValueOf(uv2S)
	goArguments[4] = reflect.ValueOf(normals)
	goArguments[5] = reflect.ValueOf(tangents)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_triangle_fan", goArguments, "")

	log.Println("Got return value!")

}

/*
   Adds an index to index array if you are using indexed Vertices. Does not need to be called before adding Vertex.
*/
func (o *SurfaceTool) AddIndex(index int64) {
	log.Println("Calling SurfaceTool.AddIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_index", goArguments, "")

	log.Println("Got return value!")

}

/*
   Shrinks Vertex array by creating an index array. Avoids reusing Vertices.
*/
func (o *SurfaceTool) Index() {
	log.Println("Calling SurfaceTool.Index()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "index", goArguments, "")

	log.Println("Got return value!")

}

/*
   Removes index array by expanding Vertex array.
*/
func (o *SurfaceTool) Deindex() {
	log.Println("Calling SurfaceTool.Deindex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "deindex", goArguments, "")

	log.Println("Got return value!")

}

/*
   Generates normals from Vertices so you do not have to do it manually.
*/
func (o *SurfaceTool) GenerateNormals() {
	log.Println("Calling SurfaceTool.GenerateNormals()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "generate_normals", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SurfaceTool) GenerateTangents() {
	log.Println("Calling SurfaceTool.GenerateTangents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "generate_tangents", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SurfaceTool) AddToFormat(flags int64) {
	log.Println("Calling SurfaceTool.AddToFormat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flags)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_to_format", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets [Material] to be used by the [Mesh] you are constructing.
*/
func (o *SurfaceTool) SetMaterial(material *Material) {
	log.Println("Calling SurfaceTool.SetMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(material)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_material", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear all information passed into the surface tool so far.
*/
func (o *SurfaceTool) Clear() {
	log.Println("Calling SurfaceTool.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SurfaceTool) CreateFrom(existing *Mesh, surface int64) {
	log.Println("Calling SurfaceTool.CreateFrom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(existing)
	goArguments[1] = reflect.ValueOf(surface)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create_from", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SurfaceTool) AppendFrom(existing *Mesh, surface int64, transform *Transform) {
	log.Println("Calling SurfaceTool.AppendFrom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(existing)
	goArguments[1] = reflect.ValueOf(surface)
	goArguments[2] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "append_from", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns a constructed [ArrayMesh] from current information passed in. If an existing [ArrayMesh] is passed in as an argument, will add an extra surface to the existing [ArrayMesh].
*/
func (o *SurfaceTool) Commit(existing *ArrayMesh) *ArrayMesh {
	log.Println("Calling SurfaceTool.Commit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(existing)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "commit", goArguments, "*ArrayMesh")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*ArrayMesh)

	return returnValue

}

/*
   SurfaceToolImplementer is an interface for SurfaceTool objects.
*/
type SurfaceToolImplementer interface {
	Class
}

/*

 */
type MeshDataTool struct {
	Reference
}

func (o *MeshDataTool) baseClass() string {
	return "MeshDataTool"
}

/*

 */
func (o *MeshDataTool) Clear() {
	log.Println("Calling MeshDataTool.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshDataTool) CreateFromSurface(mesh *ArrayMesh, surface int64) int64 {
	log.Println("Calling MeshDataTool.CreateFromSurface()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(mesh)
	goArguments[1] = reflect.ValueOf(surface)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "create_from_surface", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *MeshDataTool) CommitToSurface(mesh *ArrayMesh) int64 {
	log.Println("Calling MeshDataTool.CommitToSurface()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mesh)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "commit_to_surface", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetFormat() int64 {
	log.Println("Calling MeshDataTool.GetFormat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_format", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetVertexCount() int64 {
	log.Println("Calling MeshDataTool.GetVertexCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertex_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetEdgeCount() int64 {
	log.Println("Calling MeshDataTool.GetEdgeCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_edge_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetFaceCount() int64 {
	log.Println("Calling MeshDataTool.GetFaceCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_face_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *MeshDataTool) SetVertex(idx int64, vertex *Vector3) {
	log.Println("Calling MeshDataTool.SetVertex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(vertex)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vertex", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshDataTool) GetVertex(idx int64) *Vector3 {
	log.Println("Calling MeshDataTool.GetVertex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertex", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *MeshDataTool) SetVertexNormal(idx int64, normal *Vector3) {
	log.Println("Calling MeshDataTool.SetVertexNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(normal)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vertex_normal", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshDataTool) GetVertexNormal(idx int64) *Vector3 {
	log.Println("Calling MeshDataTool.GetVertexNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertex_normal", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *MeshDataTool) SetVertexTangent(idx int64, tangent *Plane) {
	log.Println("Calling MeshDataTool.SetVertexTangent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(tangent)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vertex_tangent", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshDataTool) GetVertexTangent(idx int64) *Plane {
	log.Println("Calling MeshDataTool.GetVertexTangent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertex_tangent", goArguments, "*Plane")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Plane)

	return returnValue

}

/*

 */
func (o *MeshDataTool) SetVertexUv(idx int64, uv *Vector2) {
	log.Println("Calling MeshDataTool.SetVertexUv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(uv)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vertex_uv", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshDataTool) GetVertexUv(idx int64) *Vector2 {
	log.Println("Calling MeshDataTool.GetVertexUv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertex_uv", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *MeshDataTool) SetVertexUv2(idx int64, uv2 *Vector2) {
	log.Println("Calling MeshDataTool.SetVertexUv2()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(uv2)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vertex_uv2", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshDataTool) GetVertexUv2(idx int64) *Vector2 {
	log.Println("Calling MeshDataTool.GetVertexUv2()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertex_uv2", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *MeshDataTool) SetVertexColor(idx int64, color *Color) {
	log.Println("Calling MeshDataTool.SetVertexColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vertex_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshDataTool) GetVertexColor(idx int64) *Color {
	log.Println("Calling MeshDataTool.GetVertexColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertex_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *MeshDataTool) SetVertexBones(idx int64, bones *PoolIntArray) {
	log.Println("Calling MeshDataTool.SetVertexBones()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(bones)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vertex_bones", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshDataTool) GetVertexBones(idx int64) *PoolIntArray {
	log.Println("Calling MeshDataTool.GetVertexBones()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertex_bones", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*

 */
func (o *MeshDataTool) SetVertexWeights(idx int64, weights *PoolRealArray) {
	log.Println("Calling MeshDataTool.SetVertexWeights()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(weights)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vertex_weights", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshDataTool) GetVertexWeights(idx int64) *PoolRealArray {
	log.Println("Calling MeshDataTool.GetVertexWeights()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertex_weights", goArguments, "*PoolRealArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolRealArray)

	return returnValue

}

/*

 */
func (o *MeshDataTool) SetVertexMeta(idx int64, meta *Variant) {
	log.Println("Calling MeshDataTool.SetVertexMeta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(meta)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vertex_meta", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshDataTool) GetVertexMeta(idx int64) *Variant {
	log.Println("Calling MeshDataTool.GetVertexMeta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertex_meta", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetVertexEdges(idx int64) *PoolIntArray {
	log.Println("Calling MeshDataTool.GetVertexEdges()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertex_edges", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetVertexFaces(idx int64) *PoolIntArray {
	log.Println("Calling MeshDataTool.GetVertexFaces()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertex_faces", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetEdgeVertex(idx int64, vertex int64) int64 {
	log.Println("Calling MeshDataTool.GetEdgeVertex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(vertex)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_edge_vertex", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetEdgeFaces(idx int64) *PoolIntArray {
	log.Println("Calling MeshDataTool.GetEdgeFaces()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_edge_faces", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*

 */
func (o *MeshDataTool) SetEdgeMeta(idx int64, meta *Variant) {
	log.Println("Calling MeshDataTool.SetEdgeMeta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(meta)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_edge_meta", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshDataTool) GetEdgeMeta(idx int64) *Variant {
	log.Println("Calling MeshDataTool.GetEdgeMeta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_edge_meta", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetFaceVertex(idx int64, vertex int64) int64 {
	log.Println("Calling MeshDataTool.GetFaceVertex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(vertex)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_face_vertex", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetFaceEdge(idx int64, edge int64) int64 {
	log.Println("Calling MeshDataTool.GetFaceEdge()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(edge)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_face_edge", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *MeshDataTool) SetFaceMeta(idx int64, meta *Variant) {
	log.Println("Calling MeshDataTool.SetFaceMeta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(meta)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_face_meta", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshDataTool) GetFaceMeta(idx int64) *Variant {
	log.Println("Calling MeshDataTool.GetFaceMeta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_face_meta", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetFaceNormal(idx int64) *Vector3 {
	log.Println("Calling MeshDataTool.GetFaceNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_face_normal", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *MeshDataTool) SetMaterial(material *Material) {
	log.Println("Calling MeshDataTool.SetMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(material)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_material", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshDataTool) GetMaterial() *Material {
	log.Println("Calling MeshDataTool.GetMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_material", goArguments, "*Material")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Material)

	return returnValue

}

/*
   MeshDataToolImplementer is an interface for MeshDataTool objects.
*/
type MeshDataToolImplementer interface {
	Class
}

/*

 */
type SpatialVelocityTracker struct {
	Reference
}

func (o *SpatialVelocityTracker) baseClass() string {
	return "SpatialVelocityTracker"
}

/*

 */
func (o *SpatialVelocityTracker) SetTrackFixedStep(enable bool) {
	log.Println("Calling SpatialVelocityTracker.SetTrackFixedStep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_track_fixed_step", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialVelocityTracker) IsTrackingFixedStep() bool {
	log.Println("Calling SpatialVelocityTracker.IsTrackingFixedStep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_tracking_fixed_step", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *SpatialVelocityTracker) UpdatePosition(position *Vector3) {
	log.Println("Calling SpatialVelocityTracker.UpdatePosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "update_position", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialVelocityTracker) GetTrackedLinearVelocity() *Vector3 {
	log.Println("Calling SpatialVelocityTracker.GetTrackedLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tracked_linear_velocity", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *SpatialVelocityTracker) Reset(position *Vector3) {
	log.Println("Calling SpatialVelocityTracker.Reset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "reset", goArguments, "")

	log.Println("Got return value!")

}

/*
   SpatialVelocityTrackerImplementer is an interface for SpatialVelocityTracker objects.
*/
type SpatialVelocityTrackerImplementer interface {
	Class
}

/*

 */
type Sky struct {
	Resource
}

func (o *Sky) baseClass() string {
	return "Sky"
}

/*

 */
func (o *Sky) SetRadianceSize(size int64) {
	log.Println("Calling Sky.SetRadianceSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_radiance_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Sky) GetRadianceSize() int64 {
	log.Println("Calling Sky.GetRadianceSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_radiance_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   SkyImplementer is an interface for Sky objects.
*/
type SkyImplementer interface {
	Class
}

/*
   Class that has everything pertaining to a 2D world. A physics space, a visual scenario and a sound space. 2D nodes register their resources into the current 2D world.
*/
type World2D struct {
	Resource
}

func (o *World2D) baseClass() string {
	return "World2D"
}

/*
   Retrieve the [RID] of this world's canvas resource. Used by the [VisualServer] for 2D drawing.
*/
func (o *World2D) GetCanvas() *RID {
	log.Println("Calling World2D.GetCanvas()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_canvas", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Retrieve the [RID] of this world's physics space resource. Used by the [Physics2DServer] for 2D physics, treating it as both a space and an area.
*/
func (o *World2D) GetSpace() *RID {
	log.Println("Calling World2D.GetSpace()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_space", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Retrieve the state of this world's physics space. This allows arbitrary querying for collision.
*/
func (o *World2D) GetDirectSpaceState() *Physics2DDirectSpaceState {
	log.Println("Calling World2D.GetDirectSpaceState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_direct_space_state", goArguments, "*Physics2DDirectSpaceState")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Physics2DDirectSpaceState)

	return returnValue

}

/*
   World2DImplementer is an interface for World2D objects.
*/
type World2DImplementer interface {
	Class
}

/*

 */
type PanoramaSky struct {
	Sky
}

func (o *PanoramaSky) baseClass() string {
	return "PanoramaSky"
}

/*

 */
func (o *PanoramaSky) SetPanorama(texture *Texture) {
	log.Println("Calling PanoramaSky.SetPanorama()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_panorama", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PanoramaSky) GetPanorama() *Texture {
	log.Println("Calling PanoramaSky.GetPanorama()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_panorama", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   PanoramaSkyImplementer is an interface for PanoramaSky objects.
*/
type PanoramaSkyImplementer interface {
	Class
}

/*

 */
type ProceduralSky struct {
	Sky
}

func (o *ProceduralSky) baseClass() string {
	return "ProceduralSky"
}

/*
   Undocumented
*/
func (o *ProceduralSky) X_UpdateSky() {
	log.Println("Calling ProceduralSky.X_UpdateSky()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_update_sky", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) SetSkyTopColor(color *Color) {
	log.Println("Calling ProceduralSky.SetSkyTopColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sky_top_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) GetSkyTopColor() *Color {
	log.Println("Calling ProceduralSky.GetSkyTopColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sky_top_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *ProceduralSky) SetSkyHorizonColor(color *Color) {
	log.Println("Calling ProceduralSky.SetSkyHorizonColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sky_horizon_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) GetSkyHorizonColor() *Color {
	log.Println("Calling ProceduralSky.GetSkyHorizonColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sky_horizon_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *ProceduralSky) SetSkyCurve(curve float64) {
	log.Println("Calling ProceduralSky.SetSkyCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(curve)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sky_curve", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) GetSkyCurve() float64 {
	log.Println("Calling ProceduralSky.GetSkyCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sky_curve", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ProceduralSky) SetSkyEnergy(energy float64) {
	log.Println("Calling ProceduralSky.SetSkyEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(energy)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sky_energy", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) GetSkyEnergy() float64 {
	log.Println("Calling ProceduralSky.GetSkyEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sky_energy", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ProceduralSky) SetGroundBottomColor(color *Color) {
	log.Println("Calling ProceduralSky.SetGroundBottomColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ground_bottom_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) GetGroundBottomColor() *Color {
	log.Println("Calling ProceduralSky.GetGroundBottomColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ground_bottom_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *ProceduralSky) SetGroundHorizonColor(color *Color) {
	log.Println("Calling ProceduralSky.SetGroundHorizonColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ground_horizon_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) GetGroundHorizonColor() *Color {
	log.Println("Calling ProceduralSky.GetGroundHorizonColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ground_horizon_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *ProceduralSky) SetGroundCurve(curve float64) {
	log.Println("Calling ProceduralSky.SetGroundCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(curve)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ground_curve", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) GetGroundCurve() float64 {
	log.Println("Calling ProceduralSky.GetGroundCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ground_curve", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ProceduralSky) SetGroundEnergy(energy float64) {
	log.Println("Calling ProceduralSky.SetGroundEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(energy)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ground_energy", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) GetGroundEnergy() float64 {
	log.Println("Calling ProceduralSky.GetGroundEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ground_energy", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ProceduralSky) SetSunColor(color *Color) {
	log.Println("Calling ProceduralSky.SetSunColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sun_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) GetSunColor() *Color {
	log.Println("Calling ProceduralSky.GetSunColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sun_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *ProceduralSky) SetSunLatitude(degrees float64) {
	log.Println("Calling ProceduralSky.SetSunLatitude()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sun_latitude", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) GetSunLatitude() float64 {
	log.Println("Calling ProceduralSky.GetSunLatitude()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sun_latitude", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ProceduralSky) SetSunLongitude(degrees float64) {
	log.Println("Calling ProceduralSky.SetSunLongitude()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sun_longitude", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) GetSunLongitude() float64 {
	log.Println("Calling ProceduralSky.GetSunLongitude()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sun_longitude", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ProceduralSky) SetSunAngleMin(degrees float64) {
	log.Println("Calling ProceduralSky.SetSunAngleMin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sun_angle_min", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) GetSunAngleMin() float64 {
	log.Println("Calling ProceduralSky.GetSunAngleMin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sun_angle_min", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ProceduralSky) SetSunAngleMax(degrees float64) {
	log.Println("Calling ProceduralSky.SetSunAngleMax()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sun_angle_max", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) GetSunAngleMax() float64 {
	log.Println("Calling ProceduralSky.GetSunAngleMax()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sun_angle_max", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ProceduralSky) SetSunCurve(curve float64) {
	log.Println("Calling ProceduralSky.SetSunCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(curve)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sun_curve", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) GetSunCurve() float64 {
	log.Println("Calling ProceduralSky.GetSunCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sun_curve", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ProceduralSky) SetSunEnergy(energy float64) {
	log.Println("Calling ProceduralSky.SetSunEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(energy)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sun_energy", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) GetSunEnergy() float64 {
	log.Println("Calling ProceduralSky.GetSunEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sun_energy", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ProceduralSky) SetTextureSize(size int64) {
	log.Println("Calling ProceduralSky.SetTextureSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) GetTextureSize() int64 {
	log.Println("Calling ProceduralSky.GetTextureSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *ProceduralSky) X_ThreadDone(image *Image) {
	log.Println("Calling ProceduralSky.X_ThreadDone()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(image)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_thread_done", goArguments, "")

	log.Println("Got return value!")

}

/*
   ProceduralSkyImplementer is an interface for ProceduralSky objects.
*/
type ProceduralSkyImplementer interface {
	Class
}

/*

 */
type StreamTexture struct {
	Texture
}

func (o *StreamTexture) baseClass() string {
	return "StreamTexture"
}

/*

 */
func (o *StreamTexture) Load(path string) int64 {
	log.Println("Calling StreamTexture.Load()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "load", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *StreamTexture) GetLoadPath() string {
	log.Println("Calling StreamTexture.GetLoadPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_load_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   StreamTextureImplementer is an interface for StreamTexture objects.
*/
type StreamTextureImplementer interface {
	Class
}

/*
   [Texture] resource aimed at managing big textures files that pack multiple smaller textures. Consists of a [Texture], a margin that defines the border width, and a region that defines the actual area of the AtlasTexture.
*/
type AtlasTexture struct {
	Texture
}

func (o *AtlasTexture) baseClass() string {
	return "AtlasTexture"
}

/*

 */
func (o *AtlasTexture) SetAtlas(atlas *Texture) {
	log.Println("Calling AtlasTexture.SetAtlas()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(atlas)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_atlas", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AtlasTexture) GetAtlas() *Texture {
	log.Println("Calling AtlasTexture.GetAtlas()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_atlas", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *AtlasTexture) SetRegion(region *Rect2) {
	log.Println("Calling AtlasTexture.SetRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(region)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_region", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AtlasTexture) GetRegion() *Rect2 {
	log.Println("Calling AtlasTexture.GetRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_region", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*

 */
func (o *AtlasTexture) SetMargin(margin *Rect2) {
	log.Println("Calling AtlasTexture.SetMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_margin", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AtlasTexture) GetMargin() *Rect2 {
	log.Println("Calling AtlasTexture.GetMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_margin", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   AtlasTextureImplementer is an interface for AtlasTexture objects.
*/
type AtlasTextureImplementer interface {
	Class
}

/*
   A Texture capable of storing many smaller Textures with offsets. You can dynamically add pieces(Textures) to this fLargeTexture] using different offsets.
*/
type LargeTexture struct {
	Texture
}

func (o *LargeTexture) baseClass() string {
	return "LargeTexture"
}

/*
   Add another [Texture] to this [LargeTexture], starting on offset "ofs".
*/
func (o *LargeTexture) AddPiece(ofs *Vector2, texture *Texture) int64 {
	log.Println("Calling LargeTexture.AddPiece()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ofs)
	goArguments[1] = reflect.ValueOf(texture)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "add_piece", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the offset of the piece with index "idx" to "ofs".
*/
func (o *LargeTexture) SetPieceOffset(idx int64, ofs *Vector2) {
	log.Println("Calling LargeTexture.SetPieceOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(ofs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_piece_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the [Texture] of the piece with index "idx" to "ofs".
*/
func (o *LargeTexture) SetPieceTexture(idx int64, texture *Texture) {
	log.Println("Calling LargeTexture.SetPieceTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_piece_texture", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the size of this [LargeTexture].
*/
func (o *LargeTexture) SetSize(size *Vector2) {
	log.Println("Calling LargeTexture.SetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_size", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear the [LargeTexture].
*/
func (o *LargeTexture) Clear() {
	log.Println("Calling LargeTexture.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the number of pieces currently in this [LargeTexture].
*/
func (o *LargeTexture) GetPieceCount() int64 {
	log.Println("Calling LargeTexture.GetPieceCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_piece_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the offset of the piece with index "idx".
*/
func (o *LargeTexture) GetPieceOffset(idx int64) *Vector2 {
	log.Println("Calling LargeTexture.GetPieceOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_piece_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the [Texture] of the piece with index "idx".
*/
func (o *LargeTexture) GetPieceTexture(idx int64) *Texture {
	log.Println("Calling LargeTexture.GetPieceTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_piece_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   Undocumented
*/
func (o *LargeTexture) X_SetData(data *Array) {
	log.Println("Calling LargeTexture.X_SetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_data", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *LargeTexture) X_GetData() *Array {
	log.Println("Calling LargeTexture.X_GetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_data", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   LargeTextureImplementer is an interface for LargeTexture objects.
*/
type LargeTextureImplementer interface {
	Class
}

/*

 */
type Curve struct {
	Resource
}

func (o *Curve) baseClass() string {
	return "Curve"
}

/*

 */
func (o *Curve) AddPoint(position *Vector2, leftTangent float64, rightTangent float64, leftMode int64, rightMode int64) int64 {
	log.Println("Calling Curve.AddPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(position)
	goArguments[1] = reflect.ValueOf(leftTangent)
	goArguments[2] = reflect.ValueOf(rightTangent)
	goArguments[3] = reflect.ValueOf(leftMode)
	goArguments[4] = reflect.ValueOf(rightMode)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "add_point", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Curve) RemovePoint(index int64) {
	log.Println("Calling Curve.RemovePoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_point", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve) ClearPoints() {
	log.Println("Calling Curve.ClearPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_points", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve) GetPointPosition(index int64) *Vector2 {
	log.Println("Calling Curve.GetPointPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Curve) SetPointValue(index int64, y float64) {
	log.Println("Calling Curve.SetPointValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(index)
	goArguments[1] = reflect.ValueOf(y)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_value", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve) SetPointOffset(index int64, offset float64) {
	log.Println("Calling Curve.SetPointOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(index)
	goArguments[1] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_offset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve) Interpolate(offset float64) float64 {
	log.Println("Calling Curve.Interpolate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "interpolate", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Curve) InterpolateBaked(offset float64) float64 {
	log.Println("Calling Curve.InterpolateBaked()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "interpolate_baked", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Curve) GetPointLeftTangent(index int64) float64 {
	log.Println("Calling Curve.GetPointLeftTangent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_left_tangent", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Curve) GetPointRightTangent(index int64) float64 {
	log.Println("Calling Curve.GetPointRightTangent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_right_tangent", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Curve) GetPointLeftMode(index int64) int64 {
	log.Println("Calling Curve.GetPointLeftMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_left_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Curve) GetPointRightMode(index int64) int64 {
	log.Println("Calling Curve.GetPointRightMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_right_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Curve) SetPointLeftTangent(index int64, tangent float64) {
	log.Println("Calling Curve.SetPointLeftTangent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(index)
	goArguments[1] = reflect.ValueOf(tangent)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_left_tangent", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve) SetPointRightTangent(index int64, tangent float64) {
	log.Println("Calling Curve.SetPointRightTangent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(index)
	goArguments[1] = reflect.ValueOf(tangent)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_right_tangent", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve) SetPointLeftMode(index int64, mode int64) {
	log.Println("Calling Curve.SetPointLeftMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(index)
	goArguments[1] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_left_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve) SetPointRightMode(index int64, mode int64) {
	log.Println("Calling Curve.SetPointRightMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(index)
	goArguments[1] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_right_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve) GetMinValue() float64 {
	log.Println("Calling Curve.GetMinValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_min_value", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Curve) SetMinValue(min float64) {
	log.Println("Calling Curve.SetMinValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(min)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_min_value", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve) GetMaxValue() float64 {
	log.Println("Calling Curve.GetMaxValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_max_value", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Curve) SetMaxValue(max float64) {
	log.Println("Calling Curve.SetMaxValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(max)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_value", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve) CleanDupes() {
	log.Println("Calling Curve.CleanDupes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clean_dupes", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve) Bake() {
	log.Println("Calling Curve.Bake()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "bake", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve) GetBakeResolution() int64 {
	log.Println("Calling Curve.GetBakeResolution()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bake_resolution", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Curve) SetBakeResolution(resolution int64) {
	log.Println("Calling Curve.SetBakeResolution()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(resolution)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bake_resolution", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *Curve) X_GetData() *Array {
	log.Println("Calling Curve.X_GetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_data", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Undocumented
*/
func (o *Curve) X_SetData(data *Array) {
	log.Println("Calling Curve.X_SetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_data", goArguments, "")

	log.Println("Got return value!")

}

/*
   CurveImplementer is an interface for Curve objects.
*/
type CurveImplementer interface {
	Class
}

/*

 */
type CubeMap struct {
	Resource
}

func (o *CubeMap) baseClass() string {
	return "CubeMap"
}

/*

 */
func (o *CubeMap) GetWidth() int64 {
	log.Println("Calling CubeMap.GetWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_width", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CubeMap) GetHeight() int64 {
	log.Println("Calling CubeMap.GetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_height", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CubeMap) SetFlags(flags int64) {
	log.Println("Calling CubeMap.SetFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flags)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flags", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CubeMap) GetFlags() int64 {
	log.Println("Calling CubeMap.GetFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_flags", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CubeMap) SetSide(side int64, image *Image) {
	log.Println("Calling CubeMap.SetSide()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(side)
	goArguments[1] = reflect.ValueOf(image)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_side", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CubeMap) GetSide(side int64) *Image {
	log.Println("Calling CubeMap.GetSide()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(side)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_side", goArguments, "*Image")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Image)

	return returnValue

}

/*

 */
func (o *CubeMap) SetStorage(mode int64) {
	log.Println("Calling CubeMap.SetStorage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_storage", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CubeMap) GetStorage() int64 {
	log.Println("Calling CubeMap.GetStorage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_storage", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CubeMap) SetLossyStorageQuality(quality float64) {
	log.Println("Calling CubeMap.SetLossyStorageQuality()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(quality)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_lossy_storage_quality", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CubeMap) GetLossyStorageQuality() float64 {
	log.Println("Calling CubeMap.GetLossyStorageQuality()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_lossy_storage_quality", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   CubeMapImplementer is an interface for CubeMap objects.
*/
type CubeMapImplementer interface {
	Class
}

/*
   An Animation resource contains data used to animate everything in the engine. Animations are divided into tracks, and each track must be linked to a node. The state of that node can be changed through time, by adding timed keys (events) to the track. Animations are just data containers, and must be added to odes such as an [AnimationPlayer] or [AnimationTreePlayer] to be played back.
*/
type Animation struct {
	Resource
}

func (o *Animation) baseClass() string {
	return "Animation"
}

/*
   Add a track to the Animation. The track type must be specified as any of the values in the TYPE_* enumeration.
*/
func (o *Animation) AddTrack(aType int64, atPosition int64) int64 {
	log.Println("Calling Animation.AddTrack()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(aType)
	goArguments[1] = reflect.ValueOf(atPosition)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "add_track", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Remove a track by specifying the track index.
*/
func (o *Animation) RemoveTrack(idx int64) {
	log.Println("Calling Animation.RemoveTrack()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_track", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the amount of tracks in the animation.
*/
func (o *Animation) GetTrackCount() int64 {
	log.Println("Calling Animation.GetTrackCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_track_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the type of a track.
*/
func (o *Animation) TrackGetType(idx int64) int64 {
	log.Println("Calling Animation.TrackGetType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "track_get_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the path of a track. for more information on the path format, see [method track_set_path]
*/
func (o *Animation) TrackGetPath(idx int64) *NodePath {
	log.Println("Calling Animation.TrackGetPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "track_get_path", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*
   Set the path of a track. Paths must be valid scene-tree paths to a node, and must be specified starting from the parent node of the node that will reproduce the animation. Tracks that control properties or bones must append their name after the path, separated by ":". Example: "character/skeleton:ankle" or "character/mesh:transform/local"
*/
func (o *Animation) TrackSetPath(idx int64, path *NodePath) {
	log.Println("Calling Animation.TrackSetPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "track_set_path", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the index of the specified track. If the track is not found, return -1.
*/
func (o *Animation) FindTrack(path *NodePath) int64 {
	log.Println("Calling Animation.FindTrack()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "find_track", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Move a track up.
*/
func (o *Animation) TrackMoveUp(idx int64) {
	log.Println("Calling Animation.TrackMoveUp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "track_move_up", goArguments, "")

	log.Println("Got return value!")

}

/*
   Move a track down.
*/
func (o *Animation) TrackMoveDown(idx int64) {
	log.Println("Calling Animation.TrackMoveDown()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "track_move_down", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the given track as imported or not.
*/
func (o *Animation) TrackSetImported(idx int64, imported bool) {
	log.Println("Calling Animation.TrackSetImported()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(imported)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "track_set_imported", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if the given track is imported. Else, return false.
*/
func (o *Animation) TrackIsImported(idx int64) bool {
	log.Println("Calling Animation.TrackIsImported()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "track_is_imported", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Insert a transform key for a transform track.
*/
func (o *Animation) TransformTrackInsertKey(idx int64, time float64, location *Vector3, rotation *Quat, scale *Vector3) int64 {
	log.Println("Calling Animation.TransformTrackInsertKey()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(time)
	goArguments[2] = reflect.ValueOf(location)
	goArguments[3] = reflect.ValueOf(rotation)
	goArguments[4] = reflect.ValueOf(scale)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "transform_track_insert_key", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Insert a generic key in a given track.
*/
func (o *Animation) TrackInsertKey(idx int64, time float64, key *Variant, transition float64) {
	log.Println("Calling Animation.TrackInsertKey()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(time)
	goArguments[2] = reflect.ValueOf(key)
	goArguments[3] = reflect.ValueOf(transition)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "track_insert_key", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove a key by index in a given track.
*/
func (o *Animation) TrackRemoveKey(idx int64, keyIdx int64) {
	log.Println("Calling Animation.TrackRemoveKey()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(keyIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "track_remove_key", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove a key by position (seconds) in a given track.
*/
func (o *Animation) TrackRemoveKeyAtPosition(idx int64, position float64) {
	log.Println("Calling Animation.TrackRemoveKeyAtPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "track_remove_key_at_position", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the value of an existing key.
*/
func (o *Animation) TrackSetKeyValue(idx int64, key int64, value *Variant) {
	log.Println("Calling Animation.TrackSetKeyValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(key)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "track_set_key_value", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the transition curve (easing) for a specific key (see built-in math function "ease").
*/
func (o *Animation) TrackSetKeyTransition(idx int64, keyIdx int64, transition float64) {
	log.Println("Calling Animation.TrackSetKeyTransition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(keyIdx)
	goArguments[2] = reflect.ValueOf(transition)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "track_set_key_transition", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the transition curve (easing) for a specific key (see built-in math function "ease").
*/
func (o *Animation) TrackGetKeyTransition(idx int64, keyIdx int64) float64 {
	log.Println("Calling Animation.TrackGetKeyTransition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(keyIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "track_get_key_transition", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the amount of keys in a given track.
*/
func (o *Animation) TrackGetKeyCount(idx int64) int64 {
	log.Println("Calling Animation.TrackGetKeyCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "track_get_key_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the value of a given key in a given track.
*/
func (o *Animation) TrackGetKeyValue(idx int64, keyIdx int64) *Variant {
	log.Println("Calling Animation.TrackGetKeyValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(keyIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "track_get_key_value", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Return the time at which the key is located.
*/
func (o *Animation) TrackGetKeyTime(idx int64, keyIdx int64) float64 {
	log.Println("Calling Animation.TrackGetKeyTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(keyIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "track_get_key_time", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Find the key index by time in a given track. Optionally, only find it if the exact time is given.
*/
func (o *Animation) TrackFindKey(idx int64, time float64, exact bool) int64 {
	log.Println("Calling Animation.TrackFindKey()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(time)
	goArguments[2] = reflect.ValueOf(exact)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "track_find_key", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the interpolation type of a given track, from the INTERPOLATION_* enum.
*/
func (o *Animation) TrackSetInterpolationType(idx int64, interpolation int64) {
	log.Println("Calling Animation.TrackSetInterpolationType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(interpolation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "track_set_interpolation_type", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the interpolation type of a given track, from the INTERPOLATION_* enum.
*/
func (o *Animation) TrackGetInterpolationType(idx int64) int64 {
	log.Println("Calling Animation.TrackGetInterpolationType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "track_get_interpolation_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Animation) TrackSetInterpolationLoopWrap(idx int64, interpolation bool) {
	log.Println("Calling Animation.TrackSetInterpolationLoopWrap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(interpolation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "track_set_interpolation_loop_wrap", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Animation) TrackGetInterpolationLoopWrap(idx int64) bool {
	log.Println("Calling Animation.TrackGetInterpolationLoopWrap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "track_get_interpolation_loop_wrap", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return the interpolated value of a transform track at a given time (in seconds). An array consisting of 3 elements: position ([Vector3]), rotation ([Quat]) and scale ([Vector3]).
*/
func (o *Animation) TransformTrackInterpolate(idx int64, timeSec float64) *Array {
	log.Println("Calling Animation.TransformTrackInterpolate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(timeSec)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "transform_track_interpolate", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Set the update mode (UPDATE_*) of a value track.
*/
func (o *Animation) ValueTrackSetUpdateMode(idx int64, mode int64) {
	log.Println("Calling Animation.ValueTrackSetUpdateMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "value_track_set_update_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the update mode of a value track.
*/
func (o *Animation) ValueTrackGetUpdateMode(idx int64) int64 {
	log.Println("Calling Animation.ValueTrackGetUpdateMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "value_track_get_update_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return all the key indices of a value track, given a position and delta time.
*/
func (o *Animation) ValueTrackGetKeyIndices(idx int64, timeSec float64, delta float64) *PoolIntArray {
	log.Println("Calling Animation.ValueTrackGetKeyIndices()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(timeSec)
	goArguments[2] = reflect.ValueOf(delta)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "value_track_get_key_indices", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*
   Return all the key indices of a method track, given a position and delta time.
*/
func (o *Animation) MethodTrackGetKeyIndices(idx int64, timeSec float64, delta float64) *PoolIntArray {
	log.Println("Calling Animation.MethodTrackGetKeyIndices()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(timeSec)
	goArguments[2] = reflect.ValueOf(delta)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "method_track_get_key_indices", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*
   Return the method name of a method track.
*/
func (o *Animation) MethodTrackGetName(idx int64, keyIdx int64) string {
	log.Println("Calling Animation.MethodTrackGetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(keyIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "method_track_get_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the arguments values to be called on a method track for a given key in a given track.
*/
func (o *Animation) MethodTrackGetParams(idx int64, keyIdx int64) *Array {
	log.Println("Calling Animation.MethodTrackGetParams()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(keyIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "method_track_get_params", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Set the total length of the animation (in seconds). Note that length is not delimited by the last key, as this one may be before or after the end to ensure correct interpolation and looping.
*/
func (o *Animation) SetLength(timeSec float64) {
	log.Println("Calling Animation.SetLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(timeSec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_length", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the total length of the animation (in seconds).
*/
func (o *Animation) GetLength() float64 {
	log.Println("Calling Animation.GetLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_length", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set a flag indicating that the animation must loop. This is uses for correct interpolation of animation cycles, and for hinting the player that it must restart the animation.
*/
func (o *Animation) SetLoop(enabled bool) {
	log.Println("Calling Animation.SetLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_loop", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether the animation has the loop flag set.
*/
func (o *Animation) HasLoop() bool {
	log.Println("Calling Animation.HasLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_loop", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Set the animation step value.
*/
func (o *Animation) SetStep(sizeSec float64) {
	log.Println("Calling Animation.SetStep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sizeSec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_step", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the animation step value.
*/
func (o *Animation) GetStep() float64 {
	log.Println("Calling Animation.GetStep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_step", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Clear the animation (clear all tracks and reset all).
*/
func (o *Animation) Clear() {
	log.Println("Calling Animation.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   AnimationImplementer is an interface for Animation objects.
*/
type AnimationImplementer interface {
	Class
}

/*

 */
type DynamicFontData struct {
	Resource
}

func (o *DynamicFontData) baseClass() string {
	return "DynamicFontData"
}

/*

 */
func (o *DynamicFontData) SetFontPath(path string) {
	log.Println("Calling DynamicFontData.SetFontPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_font_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *DynamicFontData) GetFontPath() string {
	log.Println("Calling DynamicFontData.GetFontPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_font_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   DynamicFontDataImplementer is an interface for DynamicFontData objects.
*/
type DynamicFontDataImplementer interface {
	Class
}

/*

 */
type DynamicFont struct {
	Font
}

func (o *DynamicFont) baseClass() string {
	return "DynamicFont"
}

/*

 */
func (o *DynamicFont) SetFontData(data *DynamicFontData) {
	log.Println("Calling DynamicFont.SetFontData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_font_data", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *DynamicFont) GetFontData() *DynamicFontData {
	log.Println("Calling DynamicFont.GetFontData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_font_data", goArguments, "*DynamicFontData")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*DynamicFontData)

	return returnValue

}

/*

 */
func (o *DynamicFont) SetSize(data int64) {
	log.Println("Calling DynamicFont.SetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *DynamicFont) GetSize() int64 {
	log.Println("Calling DynamicFont.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *DynamicFont) SetUseMipmaps(enable bool) {
	log.Println("Calling DynamicFont.SetUseMipmaps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_mipmaps", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *DynamicFont) GetUseMipmaps() bool {
	log.Println("Calling DynamicFont.GetUseMipmaps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_use_mipmaps", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *DynamicFont) SetUseFilter(enable bool) {
	log.Println("Calling DynamicFont.SetUseFilter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_filter", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *DynamicFont) GetUseFilter() bool {
	log.Println("Calling DynamicFont.GetUseFilter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_use_filter", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *DynamicFont) SetSpacing(aType int64, value int64) {
	log.Println("Calling DynamicFont.SetSpacing()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(aType)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_spacing", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *DynamicFont) GetSpacing(aType int64) int64 {
	log.Println("Calling DynamicFont.GetSpacing()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_spacing", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *DynamicFont) AddFallback(data *DynamicFontData) {
	log.Println("Calling DynamicFont.AddFallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_fallback", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *DynamicFont) SetFallback(idx int64, data *DynamicFontData) {
	log.Println("Calling DynamicFont.SetFallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fallback", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *DynamicFont) GetFallback(idx int64) *DynamicFontData {
	log.Println("Calling DynamicFont.GetFallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fallback", goArguments, "*DynamicFontData")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*DynamicFontData)

	return returnValue

}

/*

 */
func (o *DynamicFont) RemoveFallback(idx int64) {
	log.Println("Calling DynamicFont.RemoveFallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_fallback", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *DynamicFont) GetFallbackCount() int64 {
	log.Println("Calling DynamicFont.GetFallbackCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fallback_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   DynamicFontImplementer is an interface for DynamicFont objects.
*/
type DynamicFontImplementer interface {
	Class
}

/*
   This stylebox can be used to achieve all kinds of looks without the need of a texture. Those properties are customizable: - Color - Border width (individual width for each border) - Rounded corners (individual radius for each corner) - Shadow About corner radius: Setting corner radius to high values is allowed. As soon as corners would overlap the stylebox will switch to a relative system. Example: [codeblock] height = 30 corner_radius_top_left = 50 corner_raidus_bottom_left = 100 [/codeblock] The relative system now would take the 1:2 ratio of the two left corners to calculate the actual corner width. Both corners added will [b]never[/b] be more than the height. Result: [codeblock] corner_radius_top_left: 10 corner_raidus_bottom_left: 20 [/codeblock]
*/
type StyleBoxFlat struct {
	StyleBox
}

func (o *StyleBoxFlat) baseClass() string {
	return "StyleBoxFlat"
}

/*

 */
func (o *StyleBoxFlat) SetBgColor(color *Color) {
	log.Println("Calling StyleBoxFlat.SetBgColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bg_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) GetBgColor() *Color {
	log.Println("Calling StyleBoxFlat.GetBgColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bg_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *StyleBoxFlat) SetBorderColor(color *Color) {
	log.Println("Calling StyleBoxFlat.SetBorderColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_border_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) GetBorderColor() *Color {
	log.Println("Calling StyleBoxFlat.GetBorderColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_border_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *StyleBoxFlat) SetBorderWidthAll(width int64) {
	log.Println("Calling StyleBoxFlat.SetBorderWidthAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(width)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_border_width_all", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) GetBorderWidthMin() int64 {
	log.Println("Calling StyleBoxFlat.GetBorderWidthMin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_border_width_min", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *StyleBoxFlat) SetBorderWidth(margin int64, width int64) {
	log.Println("Calling StyleBoxFlat.SetBorderWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(width)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_border_width", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) GetBorderWidth(margin int64) int64 {
	log.Println("Calling StyleBoxFlat.GetBorderWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_border_width", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *StyleBoxFlat) SetBorderBlend(blend bool) {
	log.Println("Calling StyleBoxFlat.SetBorderBlend()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(blend)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_border_blend", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) GetBorderBlend() bool {
	log.Println("Calling StyleBoxFlat.GetBorderBlend()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_border_blend", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *StyleBoxFlat) SetCornerRadiusIndividual(radiusTopLeft int64, radiusTopRight int64, radiusBottonRight int64, radiusBottomLeft int64) {
	log.Println("Calling StyleBoxFlat.SetCornerRadiusIndividual()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(radiusTopLeft)
	goArguments[1] = reflect.ValueOf(radiusTopRight)
	goArguments[2] = reflect.ValueOf(radiusBottonRight)
	goArguments[3] = reflect.ValueOf(radiusBottomLeft)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_corner_radius_individual", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) SetCornerRadiusAll(radius int64) {
	log.Println("Calling StyleBoxFlat.SetCornerRadiusAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_corner_radius_all", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) SetCornerRadius(corner int64, radius int64) {
	log.Println("Calling StyleBoxFlat.SetCornerRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(corner)
	goArguments[1] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_corner_radius", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) GetCornerRadius(corner int64) int64 {
	log.Println("Calling StyleBoxFlat.GetCornerRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(corner)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_corner_radius", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *StyleBoxFlat) SetExpandMargin(margin int64, size float64) {
	log.Println("Calling StyleBoxFlat.SetExpandMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_expand_margin", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) SetExpandMarginAll(size float64) {
	log.Println("Calling StyleBoxFlat.SetExpandMarginAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_expand_margin_all", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) SetExpandMarginIndividual(sizeLeft float64, sizeTop float64, sizeRight float64, sizeBottom float64) {
	log.Println("Calling StyleBoxFlat.SetExpandMarginIndividual()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(sizeLeft)
	goArguments[1] = reflect.ValueOf(sizeTop)
	goArguments[2] = reflect.ValueOf(sizeRight)
	goArguments[3] = reflect.ValueOf(sizeBottom)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_expand_margin_individual", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) GetExpandMargin(margin int64) float64 {
	log.Println("Calling StyleBoxFlat.GetExpandMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_expand_margin", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *StyleBoxFlat) SetDrawCenter(drawCenter bool) {
	log.Println("Calling StyleBoxFlat.SetDrawCenter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(drawCenter)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_draw_center", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) IsDrawCenterEnabled() bool {
	log.Println("Calling StyleBoxFlat.IsDrawCenterEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_draw_center_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *StyleBoxFlat) SetShadowColor(color *Color) {
	log.Println("Calling StyleBoxFlat.SetShadowColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) GetShadowColor() *Color {
	log.Println("Calling StyleBoxFlat.GetShadowColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *StyleBoxFlat) SetShadowSize(size int64) {
	log.Println("Calling StyleBoxFlat.SetShadowSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) GetShadowSize() int64 {
	log.Println("Calling StyleBoxFlat.GetShadowSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *StyleBoxFlat) SetAntiAliased(antiAliased bool) {
	log.Println("Calling StyleBoxFlat.SetAntiAliased()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(antiAliased)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_anti_aliased", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) IsAntiAliased() bool {
	log.Println("Calling StyleBoxFlat.IsAntiAliased()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_anti_aliased", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *StyleBoxFlat) SetAaSize(size int64) {
	log.Println("Calling StyleBoxFlat.SetAaSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_aa_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) GetAaSize() int64 {
	log.Println("Calling StyleBoxFlat.GetAaSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_aa_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *StyleBoxFlat) SetCornerDetail(detail int64) {
	log.Println("Calling StyleBoxFlat.SetCornerDetail()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(detail)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_corner_detail", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) GetCornerDetail() int64 {
	log.Println("Calling StyleBoxFlat.GetCornerDetail()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_corner_detail", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   StyleBoxFlatImplementer is an interface for StyleBoxFlat objects.
*/
type StyleBoxFlatImplementer interface {
	Class
}

/*

 */
type PolygonPathFinder struct {
	Resource
}

func (o *PolygonPathFinder) baseClass() string {
	return "PolygonPathFinder"
}

/*

 */
func (o *PolygonPathFinder) Setup(points *PoolVector2Array, connections *PoolIntArray) {
	log.Println("Calling PolygonPathFinder.Setup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(points)
	goArguments[1] = reflect.ValueOf(connections)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "setup", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PolygonPathFinder) FindPath(from *Vector2, to *Vector2) *PoolVector2Array {
	log.Println("Calling PolygonPathFinder.FindPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(to)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "find_path", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*

 */
func (o *PolygonPathFinder) GetIntersections(from *Vector2, to *Vector2) *PoolVector2Array {
	log.Println("Calling PolygonPathFinder.GetIntersections()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(to)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_intersections", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*

 */
func (o *PolygonPathFinder) GetClosestPoint(point *Vector2) *Vector2 {
	log.Println("Calling PolygonPathFinder.GetClosestPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(point)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_point", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *PolygonPathFinder) IsPointInside(point *Vector2) bool {
	log.Println("Calling PolygonPathFinder.IsPointInside()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(point)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_point_inside", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *PolygonPathFinder) SetPointPenalty(idx int64, penalty float64) {
	log.Println("Calling PolygonPathFinder.SetPointPenalty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(penalty)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_penalty", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PolygonPathFinder) GetPointPenalty(idx int64) float64 {
	log.Println("Calling PolygonPathFinder.GetPointPenalty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_penalty", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *PolygonPathFinder) GetBounds() *Rect2 {
	log.Println("Calling PolygonPathFinder.GetBounds()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bounds", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Undocumented
*/
func (o *PolygonPathFinder) X_SetData(arg0 *Dictionary) {
	log.Println("Calling PolygonPathFinder.X_SetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_data", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *PolygonPathFinder) X_GetData() *Dictionary {
	log.Println("Calling PolygonPathFinder.X_GetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_data", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
   PolygonPathFinderImplementer is an interface for PolygonPathFinder objects.
*/
type PolygonPathFinderImplementer interface {
	Class
}

/*
   Plays background audio.
*/
type AudioStreamPlayer struct {
	Node
}

func (o *AudioStreamPlayer) baseClass() string {
	return "AudioStreamPlayer"
}

/*

 */
func (o *AudioStreamPlayer) SetStream(stream *AudioStream) {
	log.Println("Calling AudioStreamPlayer.SetStream()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(stream)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_stream", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer) GetStream() *AudioStream {
	log.Println("Calling AudioStreamPlayer.GetStream()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stream", goArguments, "*AudioStream")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*AudioStream)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer) SetVolumeDb(volumeDb float64) {
	log.Println("Calling AudioStreamPlayer.SetVolumeDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(volumeDb)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_volume_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer) GetVolumeDb() float64 {
	log.Println("Calling AudioStreamPlayer.GetVolumeDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_volume_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Plays the audio from the given position 'from_position', in seconds.
*/
func (o *AudioStreamPlayer) Play(fromPosition float64) {
	log.Println("Calling AudioStreamPlayer.Play()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fromPosition)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "play", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the position from which audio will be played, in seconds.
*/
func (o *AudioStreamPlayer) Seek(toPosition float64) {
	log.Println("Calling AudioStreamPlayer.Seek()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toPosition)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "seek", goArguments, "")

	log.Println("Got return value!")

}

/*
   Stops the audio.
*/
func (o *AudioStreamPlayer) Stop() {
	log.Println("Calling AudioStreamPlayer.Stop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "stop", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer) IsPlaying() bool {
	log.Println("Calling AudioStreamPlayer.IsPlaying()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_playing", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer) GetPlaybackPosition() float64 {
	log.Println("Calling AudioStreamPlayer.GetPlaybackPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_playback_position", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer) SetBus(bus string) {
	log.Println("Calling AudioStreamPlayer.SetBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bus)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bus", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer) GetBus() string {
	log.Println("Calling AudioStreamPlayer.GetBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bus", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer) SetAutoplay(enable bool) {
	log.Println("Calling AudioStreamPlayer.SetAutoplay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_autoplay", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer) IsAutoplayEnabled() bool {
	log.Println("Calling AudioStreamPlayer.IsAutoplayEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_autoplay_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer) SetMixTarget(mixTarget int64) {
	log.Println("Calling AudioStreamPlayer.SetMixTarget()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mixTarget)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mix_target", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer) GetMixTarget() int64 {
	log.Println("Calling AudioStreamPlayer.GetMixTarget()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mix_target", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer) X_SetPlaying(enable bool) {
	log.Println("Calling AudioStreamPlayer.X_SetPlaying()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_playing", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer) X_IsActive() bool {
	log.Println("Calling AudioStreamPlayer.X_IsActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_is_active", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer) X_BusLayoutChanged() {
	log.Println("Calling AudioStreamPlayer.X_BusLayoutChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_bus_layout_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   AudioStreamPlayerImplementer is an interface for AudioStreamPlayer objects.
*/
type AudioStreamPlayerImplementer interface {
	Class
}

/*
   Plays audio that dampens with distance from screen center.
*/
type AudioStreamPlayer2D struct {
	Node2D
}

func (o *AudioStreamPlayer2D) baseClass() string {
	return "AudioStreamPlayer2D"
}

/*

 */
func (o *AudioStreamPlayer2D) SetStream(stream *AudioStream) {
	log.Println("Calling AudioStreamPlayer2D.SetStream()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(stream)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_stream", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer2D) GetStream() *AudioStream {
	log.Println("Calling AudioStreamPlayer2D.GetStream()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stream", goArguments, "*AudioStream")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*AudioStream)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer2D) SetVolumeDb(volumeDb float64) {
	log.Println("Calling AudioStreamPlayer2D.SetVolumeDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(volumeDb)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_volume_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer2D) GetVolumeDb() float64 {
	log.Println("Calling AudioStreamPlayer2D.GetVolumeDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_volume_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Plays the audio from the given position 'from_position', in seconds.
*/
func (o *AudioStreamPlayer2D) Play(fromPosition float64) {
	log.Println("Calling AudioStreamPlayer2D.Play()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fromPosition)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "play", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the position from which audio will be played, in seconds.
*/
func (o *AudioStreamPlayer2D) Seek(toPosition float64) {
	log.Println("Calling AudioStreamPlayer2D.Seek()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toPosition)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "seek", goArguments, "")

	log.Println("Got return value!")

}

/*
   Stops the audio.
*/
func (o *AudioStreamPlayer2D) Stop() {
	log.Println("Calling AudioStreamPlayer2D.Stop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "stop", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer2D) IsPlaying() bool {
	log.Println("Calling AudioStreamPlayer2D.IsPlaying()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_playing", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer2D) GetPlaybackPosition() float64 {
	log.Println("Calling AudioStreamPlayer2D.GetPlaybackPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_playback_position", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer2D) SetBus(bus string) {
	log.Println("Calling AudioStreamPlayer2D.SetBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bus)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bus", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer2D) GetBus() string {
	log.Println("Calling AudioStreamPlayer2D.GetBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bus", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer2D) SetAutoplay(enable bool) {
	log.Println("Calling AudioStreamPlayer2D.SetAutoplay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_autoplay", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer2D) IsAutoplayEnabled() bool {
	log.Println("Calling AudioStreamPlayer2D.IsAutoplayEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_autoplay_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer2D) X_SetPlaying(enable bool) {
	log.Println("Calling AudioStreamPlayer2D.X_SetPlaying()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_playing", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer2D) X_IsActive() bool {
	log.Println("Calling AudioStreamPlayer2D.X_IsActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_is_active", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer2D) SetMaxDistance(pixels float64) {
	log.Println("Calling AudioStreamPlayer2D.SetMaxDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pixels)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_distance", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer2D) GetMaxDistance() float64 {
	log.Println("Calling AudioStreamPlayer2D.GetMaxDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_max_distance", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer2D) SetAttenuation(curve float64) {
	log.Println("Calling AudioStreamPlayer2D.SetAttenuation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(curve)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_attenuation", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer2D) GetAttenuation() float64 {
	log.Println("Calling AudioStreamPlayer2D.GetAttenuation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_attenuation", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer2D) SetAreaMask(mask int64) {
	log.Println("Calling AudioStreamPlayer2D.SetAreaMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_area_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer2D) GetAreaMask() int64 {
	log.Println("Calling AudioStreamPlayer2D.GetAreaMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_area_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer2D) X_BusLayoutChanged() {
	log.Println("Calling AudioStreamPlayer2D.X_BusLayoutChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_bus_layout_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   AudioStreamPlayer2DImplementer is an interface for AudioStreamPlayer2D objects.
*/
type AudioStreamPlayer2DImplementer interface {
	Class
}

/*
   Plays a sound effect with directed sound effects, dampens with distance if needed, generates effect of hearable position in space.
*/
type AudioStreamPlayer3D struct {
	Spatial
}

func (o *AudioStreamPlayer3D) baseClass() string {
	return "AudioStreamPlayer3D"
}

/*

 */
func (o *AudioStreamPlayer3D) SetStream(stream *AudioStream) {
	log.Println("Calling AudioStreamPlayer3D.SetStream()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(stream)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_stream", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) GetStream() *AudioStream {
	log.Println("Calling AudioStreamPlayer3D.GetStream()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stream", goArguments, "*AudioStream")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*AudioStream)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) SetUnitDb(unitDb float64) {
	log.Println("Calling AudioStreamPlayer3D.SetUnitDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(unitDb)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_unit_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) GetUnitDb() float64 {
	log.Println("Calling AudioStreamPlayer3D.GetUnitDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_unit_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) SetUnitSize(unitSize float64) {
	log.Println("Calling AudioStreamPlayer3D.SetUnitSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(unitSize)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_unit_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) GetUnitSize() float64 {
	log.Println("Calling AudioStreamPlayer3D.GetUnitSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_unit_size", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) SetMaxDb(maxDb float64) {
	log.Println("Calling AudioStreamPlayer3D.SetMaxDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(maxDb)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) GetMaxDb() float64 {
	log.Println("Calling AudioStreamPlayer3D.GetMaxDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_max_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Plays the audio from the given position 'from_position', in seconds.
*/
func (o *AudioStreamPlayer3D) Play(fromPosition float64) {
	log.Println("Calling AudioStreamPlayer3D.Play()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fromPosition)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "play", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the position from which audio will be played, in seconds.
*/
func (o *AudioStreamPlayer3D) Seek(toPosition float64) {
	log.Println("Calling AudioStreamPlayer3D.Seek()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toPosition)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "seek", goArguments, "")

	log.Println("Got return value!")

}

/*
   Stops the audio.
*/
func (o *AudioStreamPlayer3D) Stop() {
	log.Println("Calling AudioStreamPlayer3D.Stop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "stop", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) IsPlaying() bool {
	log.Println("Calling AudioStreamPlayer3D.IsPlaying()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_playing", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) GetPlaybackPosition() float64 {
	log.Println("Calling AudioStreamPlayer3D.GetPlaybackPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_playback_position", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) SetBus(bus string) {
	log.Println("Calling AudioStreamPlayer3D.SetBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bus)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bus", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) GetBus() string {
	log.Println("Calling AudioStreamPlayer3D.GetBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bus", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) SetAutoplay(enable bool) {
	log.Println("Calling AudioStreamPlayer3D.SetAutoplay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_autoplay", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) IsAutoplayEnabled() bool {
	log.Println("Calling AudioStreamPlayer3D.IsAutoplayEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_autoplay_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) X_SetPlaying(enable bool) {
	log.Println("Calling AudioStreamPlayer3D.X_SetPlaying()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_playing", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) X_IsActive() bool {
	log.Println("Calling AudioStreamPlayer3D.X_IsActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_is_active", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) SetMaxDistance(metres float64) {
	log.Println("Calling AudioStreamPlayer3D.SetMaxDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(metres)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_distance", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) GetMaxDistance() float64 {
	log.Println("Calling AudioStreamPlayer3D.GetMaxDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_max_distance", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) SetAreaMask(mask int64) {
	log.Println("Calling AudioStreamPlayer3D.SetAreaMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_area_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) GetAreaMask() int64 {
	log.Println("Calling AudioStreamPlayer3D.GetAreaMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_area_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) SetEmissionAngle(degrees float64) {
	log.Println("Calling AudioStreamPlayer3D.SetEmissionAngle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emission_angle", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) GetEmissionAngle() float64 {
	log.Println("Calling AudioStreamPlayer3D.GetEmissionAngle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_emission_angle", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) SetEmissionAngleEnabled(enabled bool) {
	log.Println("Calling AudioStreamPlayer3D.SetEmissionAngleEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emission_angle_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) IsEmissionAngleEnabled() bool {
	log.Println("Calling AudioStreamPlayer3D.IsEmissionAngleEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_emission_angle_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) SetEmissionAngleFilterAttenuationDb(db float64) {
	log.Println("Calling AudioStreamPlayer3D.SetEmissionAngleFilterAttenuationDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(db)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emission_angle_filter_attenuation_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) GetEmissionAngleFilterAttenuationDb() float64 {
	log.Println("Calling AudioStreamPlayer3D.GetEmissionAngleFilterAttenuationDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_emission_angle_filter_attenuation_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) SetAttenuationFilterCutoffHz(degrees float64) {
	log.Println("Calling AudioStreamPlayer3D.SetAttenuationFilterCutoffHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_attenuation_filter_cutoff_hz", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) GetAttenuationFilterCutoffHz() float64 {
	log.Println("Calling AudioStreamPlayer3D.GetAttenuationFilterCutoffHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_attenuation_filter_cutoff_hz", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) SetAttenuationFilterDb(db float64) {
	log.Println("Calling AudioStreamPlayer3D.SetAttenuationFilterDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(db)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_attenuation_filter_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) GetAttenuationFilterDb() float64 {
	log.Println("Calling AudioStreamPlayer3D.GetAttenuationFilterDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_attenuation_filter_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) SetAttenuationModel(model int64) {
	log.Println("Calling AudioStreamPlayer3D.SetAttenuationModel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(model)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_attenuation_model", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) GetAttenuationModel() int64 {
	log.Println("Calling AudioStreamPlayer3D.GetAttenuationModel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_attenuation_model", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) SetOutOfRangeMode(mode int64) {
	log.Println("Calling AudioStreamPlayer3D.SetOutOfRangeMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_out_of_range_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) GetOutOfRangeMode() int64 {
	log.Println("Calling AudioStreamPlayer3D.GetOutOfRangeMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_out_of_range_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) SetDopplerTracking(mode int64) {
	log.Println("Calling AudioStreamPlayer3D.SetDopplerTracking()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_doppler_tracking", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) GetDopplerTracking() int64 {
	log.Println("Calling AudioStreamPlayer3D.GetDopplerTracking()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_doppler_tracking", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) X_BusLayoutChanged() {
	log.Println("Calling AudioStreamPlayer3D.X_BusLayoutChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_bus_layout_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   AudioStreamPlayer3DImplementer is an interface for AudioStreamPlayer3D objects.
*/
type AudioStreamPlayer3DImplementer interface {
	Class
}

/*
   Plays audio, can loop.
*/
type AudioStreamSample struct {
	AudioStream
}

func (o *AudioStreamSample) baseClass() string {
	return "AudioStreamSample"
}

/*

 */
func (o *AudioStreamSample) SetFormat(format int64) {
	log.Println("Calling AudioStreamSample.SetFormat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(format)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_format", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamSample) GetFormat() int64 {
	log.Println("Calling AudioStreamSample.GetFormat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_format", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioStreamSample) SetLoopMode(loopMode int64) {
	log.Println("Calling AudioStreamSample.SetLoopMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(loopMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_loop_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamSample) GetLoopMode() int64 {
	log.Println("Calling AudioStreamSample.GetLoopMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_loop_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioStreamSample) SetLoopBegin(loopBegin int64) {
	log.Println("Calling AudioStreamSample.SetLoopBegin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(loopBegin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_loop_begin", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamSample) GetLoopBegin() int64 {
	log.Println("Calling AudioStreamSample.GetLoopBegin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_loop_begin", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioStreamSample) SetLoopEnd(loopEnd int64) {
	log.Println("Calling AudioStreamSample.SetLoopEnd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(loopEnd)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_loop_end", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamSample) GetLoopEnd() int64 {
	log.Println("Calling AudioStreamSample.GetLoopEnd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_loop_end", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioStreamSample) SetMixRate(mixRate int64) {
	log.Println("Calling AudioStreamSample.SetMixRate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mixRate)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mix_rate", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamSample) GetMixRate() int64 {
	log.Println("Calling AudioStreamSample.GetMixRate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mix_rate", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioStreamSample) SetStereo(stereo bool) {
	log.Println("Calling AudioStreamSample.SetStereo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(stereo)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_stereo", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamSample) IsStereo() bool {
	log.Println("Calling AudioStreamSample.IsStereo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_stereo", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *AudioStreamSample) SetData(data *PoolByteArray) {
	log.Println("Calling AudioStreamSample.SetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_data", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamSample) GetData() *PoolByteArray {
	log.Println("Calling AudioStreamSample.GetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_data", goArguments, "*PoolByteArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolByteArray)

	return returnValue

}

/*
   AudioStreamSampleImplementer is an interface for AudioStreamSample objects.
*/
type AudioStreamSampleImplementer interface {
	Class
}

/*
   Line shape for 2D collisions. It works like a 2D plane and will not allow any body to go to the negative side. Not recommended for rigid bodies, and usually not recommended for static bodies either because it forces checks against it on every frame.
*/
type LineShape2D struct {
	Shape2D
}

func (o *LineShape2D) baseClass() string {
	return "LineShape2D"
}

/*
   Set the line normal.
*/
func (o *LineShape2D) SetNormal(normal *Vector2) {
	log.Println("Calling LineShape2D.SetNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(normal)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_normal", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the line normal.
*/
func (o *LineShape2D) GetNormal() *Vector2 {
	log.Println("Calling LineShape2D.GetNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_normal", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set the line distance from the origin.
*/
func (o *LineShape2D) SetD(d float64) {
	log.Println("Calling LineShape2D.SetD()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(d)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_d", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the line distance from the origin.
*/
func (o *LineShape2D) GetD() float64 {
	log.Println("Calling LineShape2D.GetD()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_d", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   LineShape2DImplementer is an interface for LineShape2D objects.
*/
type LineShape2DImplementer interface {
	Class
}

/*
   Segment shape for 2D collisions. Consists of two points, [code]a[/code] and [code]b[/code].
*/
type SegmentShape2D struct {
	Shape2D
}

func (o *SegmentShape2D) baseClass() string {
	return "SegmentShape2D"
}

/*
   Set the first point's position.
*/
func (o *SegmentShape2D) SetA(a *Vector2) {
	log.Println("Calling SegmentShape2D.SetA()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(a)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_a", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the first point's position.
*/
func (o *SegmentShape2D) GetA() *Vector2 {
	log.Println("Calling SegmentShape2D.GetA()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_a", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set the second point's position.
*/
func (o *SegmentShape2D) SetB(b *Vector2) {
	log.Println("Calling SegmentShape2D.SetB()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(b)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_b", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the second point's position.
*/
func (o *SegmentShape2D) GetB() *Vector2 {
	log.Println("Calling SegmentShape2D.GetB()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_b", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   SegmentShape2DImplementer is an interface for SegmentShape2D objects.
*/
type SegmentShape2DImplementer interface {
	Class
}

/*
   Ray shape for 2D collisions. A ray is not really a collision body, instead it tries to separate itself from whatever is touching its far endpoint. It's often useful for characters.
*/
type RayShape2D struct {
	Shape2D
}

func (o *RayShape2D) baseClass() string {
	return "RayShape2D"
}

/*
   Set the length of the ray.
*/
func (o *RayShape2D) SetLength(length float64) {
	log.Println("Calling RayShape2D.SetLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(length)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_length", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the length of the ray.
*/
func (o *RayShape2D) GetLength() float64 {
	log.Println("Calling RayShape2D.GetLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_length", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   RayShape2DImplementer is an interface for RayShape2D objects.
*/
type RayShape2DImplementer interface {
	Class
}

/*
   Circular shape for 2D collisions. This shape is useful for modeling balls or small characters and its collision detection with everything else is very fast.
*/
type CircleShape2D struct {
	Shape2D
}

func (o *CircleShape2D) baseClass() string {
	return "CircleShape2D"
}

/*
   Set the radius of the circle shape.
*/
func (o *CircleShape2D) SetRadius(radius float64) {
	log.Println("Calling CircleShape2D.SetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_radius", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the radius of the circle shape.
*/
func (o *CircleShape2D) GetRadius() float64 {
	log.Println("Calling CircleShape2D.GetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_radius", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   CircleShape2DImplementer is an interface for CircleShape2D objects.
*/
type CircleShape2DImplementer interface {
	Class
}

/*
   Rectangle shape for 2D collisions. This shape is useful for modeling box-like 2D objects.
*/
type RectangleShape2D struct {
	Shape2D
}

func (o *RectangleShape2D) baseClass() string {
	return "RectangleShape2D"
}

/*
   Set the half extents, the actual width and height of this shape is twice the half extents.
*/
func (o *RectangleShape2D) SetExtents(extents *Vector2) {
	log.Println("Calling RectangleShape2D.SetExtents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(extents)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_extents", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the half extents, the actual width and height of this shape is twice the half extents.
*/
func (o *RectangleShape2D) GetExtents() *Vector2 {
	log.Println("Calling RectangleShape2D.GetExtents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_extents", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   RectangleShape2DImplementer is an interface for RectangleShape2D objects.
*/
type RectangleShape2DImplementer interface {
	Class
}

/*
   Capsule shape for 2D collisions.
*/
type CapsuleShape2D struct {
	Shape2D
}

func (o *CapsuleShape2D) baseClass() string {
	return "CapsuleShape2D"
}

/*
   Set the radius of the [CapsuleShape2D].
*/
func (o *CapsuleShape2D) SetRadius(radius float64) {
	log.Println("Calling CapsuleShape2D.SetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_radius", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the radius of the [CapsuleShape2D].
*/
func (o *CapsuleShape2D) GetRadius() float64 {
	log.Println("Calling CapsuleShape2D.GetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_radius", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the height of the [CapsuleShape2D].
*/
func (o *CapsuleShape2D) SetHeight(height float64) {
	log.Println("Calling CapsuleShape2D.SetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(height)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_height", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the height of the [CapsuleShape2D].
*/
func (o *CapsuleShape2D) GetHeight() float64 {
	log.Println("Calling CapsuleShape2D.GetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_height", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   CapsuleShape2DImplementer is an interface for CapsuleShape2D objects.
*/
type CapsuleShape2DImplementer interface {
	Class
}

/*
   Convex Polygon Shape for 2D physics. A convex polygon, whatever its shape, is internally decomposed into as many convex polygons as needed to ensure all collision checks against it are always done on convex polygons (which are faster to check). The main difference between a [ConvexPolygonShape2D] and a [ConcavePolygonShape2D] is that a concave polygon assumes it is concave and uses a more complex method of collision detection, and a convex one forces itself to be convex in order to speed up collision detection.
*/
type ConvexPolygonShape2D struct {
	Shape2D
}

func (o *ConvexPolygonShape2D) baseClass() string {
	return "ConvexPolygonShape2D"
}

/*
   Currently, this method does nothing.
*/
func (o *ConvexPolygonShape2D) SetPointCloud(pointCloud *PoolVector2Array) {
	log.Println("Calling ConvexPolygonShape2D.SetPointCloud()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pointCloud)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_cloud", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set a list of points in either clockwise or counter clockwise order, forming a convex polygon.
*/
func (o *ConvexPolygonShape2D) SetPoints(points *PoolVector2Array) {
	log.Println("Calling ConvexPolygonShape2D.SetPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(points)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_points", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return a list of points in either clockwise or counter clockwise order, forming a convex polygon.
*/
func (o *ConvexPolygonShape2D) GetPoints() *PoolVector2Array {
	log.Println("Calling ConvexPolygonShape2D.GetPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_points", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*
   ConvexPolygonShape2DImplementer is an interface for ConvexPolygonShape2D objects.
*/
type ConvexPolygonShape2DImplementer interface {
	Class
}

/*
   Concave polygon 2D shape resource for physics. It is made out of segments and is very optimal for complex polygonal concave collisions. It is really not advised to use for [RigidBody2D] nodes. A CollisionPolygon2D in convex decomposition mode (solids) or several convex objects are advised for that instead. Otherwise, a concave polygon 2D shape is better for static collisions. The main difference between a [ConvexPolygonShape2D] and a [ConcavePolygonShape2D] is that a concave polygon assumes it is concave and uses a more complex method of collision detection, and a convex one forces itself to be convex in order to speed up collision detection.
*/
type ConcavePolygonShape2D struct {
	Shape2D
}

func (o *ConcavePolygonShape2D) baseClass() string {
	return "ConcavePolygonShape2D"
}

/*
   Set the array of segments.
*/
func (o *ConcavePolygonShape2D) SetSegments(segments *PoolVector2Array) {
	log.Println("Calling ConcavePolygonShape2D.SetSegments()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(segments)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_segments", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the array of segments.
*/
func (o *ConcavePolygonShape2D) GetSegments() *PoolVector2Array {
	log.Println("Calling ConcavePolygonShape2D.GetSegments()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_segments", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*
   ConcavePolygonShape2DImplementer is an interface for ConcavePolygonShape2D objects.
*/
type ConcavePolygonShape2DImplementer interface {
	Class
}

/*
   This class describes a Bezier curve in 2D space. It is mainly used to give a shape to a [Path2D], but can be manually sampled for other purposes. It keeps a cache of precalculated points along the curve, to speed further calculations up.
*/
type Curve2D struct {
	Resource
}

func (o *Curve2D) baseClass() string {
	return "Curve2D"
}

/*
   Returns the number of points describing the curve.
*/
func (o *Curve2D) GetPointCount() int64 {
	log.Println("Calling Curve2D.GetPointCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Adds a point to a curve, at "position", with control points "in" and "out". If "at_position" is given, the point is inserted before the point number "at_position", moving that point (and every point after) after the inserted point. If "at_position" is not given, or is an illegal value (at_position <0 or at_position >= [method get_point_count]), the point will be appended at the end of the point list.
*/
func (o *Curve2D) AddPoint(position *Vector2, in *Vector2, out *Vector2, atPosition int64) {
	log.Println("Calling Curve2D.AddPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(position)
	goArguments[1] = reflect.ValueOf(in)
	goArguments[2] = reflect.ValueOf(out)
	goArguments[3] = reflect.ValueOf(atPosition)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_point", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the position for the vertex "idx". If the index is out of bounds, the function sends an error to the console.
*/
func (o *Curve2D) SetPointPosition(idx int64, position *Vector2) {
	log.Println("Calling Curve2D.SetPointPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_position", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the position of the vertex "idx". If the index is out of bounds, the function sends an error to the console, and returns (0, 0).
*/
func (o *Curve2D) GetPointPosition(idx int64) *Vector2 {
	log.Println("Calling Curve2D.GetPointPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Sets the position of the control point leading to the vertex "idx". If the index is out of bounds, the function sends an error to the console.
*/
func (o *Curve2D) SetPointIn(idx int64, position *Vector2) {
	log.Println("Calling Curve2D.SetPointIn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_in", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the position of the control point leading to the vertex "idx". If the index is out of bounds, the function sends an error to the console, and returns (0, 0).
*/
func (o *Curve2D) GetPointIn(idx int64) *Vector2 {
	log.Println("Calling Curve2D.GetPointIn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_in", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Sets the position of the control point leading out of the vertex "idx". If the index is out of bounds, the function sends an error to the console.
*/
func (o *Curve2D) SetPointOut(idx int64, position *Vector2) {
	log.Println("Calling Curve2D.SetPointOut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_out", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the position of the control point leading out of the vertex "idx". If the index is out of bounds, the function sends an error to the console, and returns (0, 0).
*/
func (o *Curve2D) GetPointOut(idx int64) *Vector2 {
	log.Println("Calling Curve2D.GetPointOut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_out", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Deletes the point "idx" from the curve. Sends an error to the console if "idx" is out of bounds.
*/
func (o *Curve2D) RemovePoint(idx int64) {
	log.Println("Calling Curve2D.RemovePoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_point", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve2D) ClearPoints() {
	log.Println("Calling Curve2D.ClearPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_points", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the position between the vertex "idx" and the vertex "idx"+1, where "t" controls if the point is the first vertex (t = 0.0), the last vertex (t = 1.0), or in between. Values of "t" outside the range (0.0 >= t <=1) give strange, but predictable results. If "idx" is out of bounds it is truncated to the first or last vertex, and "t" is ignored. If the curve has no points, the function sends an error to the console, and returns (0, 0).
*/
func (o *Curve2D) Interpolate(idx int64, t float64) *Vector2 {
	log.Println("Calling Curve2D.Interpolate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(t)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "interpolate", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Returns the position at the vertex "fofs". It calls [method interpolate] using the integer part of fofs as "idx", and its fractional part as "t".
*/
func (o *Curve2D) Interpolatef(fofs float64) *Vector2 {
	log.Println("Calling Curve2D.Interpolatef()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fofs)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "interpolatef", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Sets the distance in pixels between two adjacent cached points. Changing it forces the cache to be recomputed the next time a xxx_baked_xxx function is called. The less distance, the more points the cache will have, and the more memory it will consume, so use with care.
*/
func (o *Curve2D) SetBakeInterval(distance float64) {
	log.Println("Calling Curve2D.SetBakeInterval()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(distance)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bake_interval", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the distance between two adjacent cached points.
*/
func (o *Curve2D) GetBakeInterval() float64 {
	log.Println("Calling Curve2D.GetBakeInterval()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bake_interval", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns the total length of the curve, based on the cached points. Given enough density (see [method set_bake_interval]), it should be approximate enough.
*/
func (o *Curve2D) GetBakedLength() float64 {
	log.Println("Calling Curve2D.GetBakedLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_baked_length", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns a point within the curve at position "offset", where "offset" is measured as a pixel distance along the curve. To do that, it finds the two cached points where the "offset" lies between, then interpolates the values. This interpolation is cubic if "cubic" is set to true, or linear if set to false. Cubic interpolation tends to follow the curves better, but linear is faster (and often, precise enough).
*/
func (o *Curve2D) InterpolateBaked(offset float64, cubic bool) *Vector2 {
	log.Println("Calling Curve2D.InterpolateBaked()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(offset)
	goArguments[1] = reflect.ValueOf(cubic)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "interpolate_baked", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Returns the cache of points as a [PoolVector2Array].
*/
func (o *Curve2D) GetBakedPoints() *PoolVector2Array {
	log.Println("Calling Curve2D.GetBakedPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_baked_points", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*
   Returns a list of points along the curve, with a curvature controlled point density. That is, the curvier parts will have more points than the straighter parts. This approximation makes straight segments between each point, then subdivides those segments until the resulting shape is similar enough. "max_stages" controls how many subdivisions a curve segment may face before it is considered approximate enough. Each subdivision splits the segment in half, so the default 5 stages may mean up to 32 subdivisions per curve segment. Increase with care! "tolerance_degrees" controls how many degrees the midpoint of a segment may deviate from the real curve, before the segment has to be subdivided.
*/
func (o *Curve2D) Tessellate(maxStages int64, toleranceDegrees float64) *PoolVector2Array {
	log.Println("Calling Curve2D.Tessellate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(maxStages)
	goArguments[1] = reflect.ValueOf(toleranceDegrees)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tessellate", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*
   Undocumented
*/
func (o *Curve2D) X_GetData() *Dictionary {
	log.Println("Calling Curve2D.X_GetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_data", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
   Undocumented
*/
func (o *Curve2D) X_SetData(arg0 *Dictionary) {
	log.Println("Calling Curve2D.X_SetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_data", goArguments, "")

	log.Println("Got return value!")

}

/*
   Curve2DImplementer is an interface for Curve2D objects.
*/
type Curve2DImplementer interface {
	Class
}

/*
   This class is a container/Node-ification of a [Curve2D], so it can have [Node2D] properties and [Node] info.
*/
type Path2D struct {
	Node2D
}

func (o *Path2D) baseClass() string {
	return "Path2D"
}

/*
   Sets the [Curve2D].
*/
func (o *Path2D) SetCurve(curve *Curve2D) {
	log.Println("Calling Path2D.SetCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(curve)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_curve", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the [Curve2D] contained.
*/
func (o *Path2D) GetCurve() *Curve2D {
	log.Println("Calling Path2D.GetCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_curve", goArguments, "*Curve2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Curve2D)

	return returnValue

}

/*
   Undocumented
*/
func (o *Path2D) X_CurveChanged() {
	log.Println("Calling Path2D.X_CurveChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_curve_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Path2DImplementer is an interface for Path2D objects.
*/
type Path2DImplementer interface {
	Class
}

/*
   This node takes its parent [Path2D], and returns the coordinates of a point within it, given a distance from the first vertex. It is useful for making other nodes follow a path, without coding the movement pattern. For that, the nodes must be descendants of this node. Then, when setting an offset in this node, the descendant nodes will move accordingly.
*/
type PathFollow2D struct {
	Node2D
}

func (o *PathFollow2D) baseClass() string {
	return "PathFollow2D"
}

/*
   Sets the distance from the first vertex, measured in pixels along the path. This sets this node's position to a point within the path.
*/
func (o *PathFollow2D) SetOffset(offset float64) {
	log.Println("Calling PathFollow2D.SetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the distance along the path in pixels.
*/
func (o *PathFollow2D) GetOffset() float64 {
	log.Println("Calling PathFollow2D.GetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Moves this node horizontally. As this node's position will be set every time its offset is set, this allows many PathFollow2D to share the same curve (and thus the same movement pattern), yet not return the same position for a given path offset. A similar effect may be achieved moving this node's descendants.
*/
func (o *PathFollow2D) SetHOffset(hOffset float64) {
	log.Println("Calling PathFollow2D.SetHOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(hOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_h_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the horizontal displacement this node has from its parent [Path2D].
*/
func (o *PathFollow2D) GetHOffset() float64 {
	log.Println("Calling PathFollow2D.GetHOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_h_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Moves the PathFollow2D vertically, for the same reasons of [method set_h_offset].
*/
func (o *PathFollow2D) SetVOffset(vOffset float64) {
	log.Println("Calling PathFollow2D.SetVOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_v_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the vertical displacement this node has from its parent [Path2D].
*/
func (o *PathFollow2D) GetVOffset() float64 {
	log.Println("Calling PathFollow2D.GetVOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_v_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Sets the distance from the first vertex, considering 0.0 as the first vertex and 1.0 as the last. This is just another way of expressing the offset within the path, as the offset supplied is multiplied internally by the path's length.
*/
func (o *PathFollow2D) SetUnitOffset(unitOffset float64) {
	log.Println("Calling PathFollow2D.SetUnitOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(unitOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_unit_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the distance along the path as a number in the range 0.0 (for the first vertex) to 1.0 (for the last).
*/
func (o *PathFollow2D) GetUnitOffset() float64 {
	log.Println("Calling PathFollow2D.GetUnitOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_unit_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   If set, this node rotates to follow the path, making its descendants rotate.
*/
func (o *PathFollow2D) SetRotate(enable bool) {
	log.Println("Calling PathFollow2D.SetRotate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rotate", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether this node rotates to follow the path.
*/
func (o *PathFollow2D) IsRotating() bool {
	log.Println("Calling PathFollow2D.IsRotating()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_rotating", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   The points along the [Curve2D] of the [Path2D] are precomputed before use, for faster calculations. The point at the requested offset is then calculated interpolating between two adjacent cached points. This may present a problem if the curve makes sharp turns, as the cached points may not follow the curve closely enough. There are two answers to this problem: Either increase the number of cached points and increase memory consumption, or make a cubic interpolation between two points at the cost of (slightly) slower calculations. This method controls whether the position between two cached points is interpolated linearly, or cubicly.
*/
func (o *PathFollow2D) SetCubicInterpolation(enable bool) {
	log.Println("Calling PathFollow2D.SetCubicInterpolation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cubic_interpolation", goArguments, "")

	log.Println("Got return value!")

}

/*
   This method returns whether the position between two cached points (see [method set_cubic_interpolation]) is interpolated linearly, or cubicly.
*/
func (o *PathFollow2D) GetCubicInterpolation() bool {
	log.Println("Calling PathFollow2D.GetCubicInterpolation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cubic_interpolation", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   If set, any offset outside the path's length (whether set by [method set_offset] or [method set_unit_offset] will wrap around, instead of stopping at the ends. Set it for cyclic paths.
*/
func (o *PathFollow2D) SetLoop(loop bool) {
	log.Println("Calling PathFollow2D.SetLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(loop)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_loop", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns whether this node wraps its offsets around, or truncates them to the path ends.
*/
func (o *PathFollow2D) HasLoop() bool {
	log.Println("Calling PathFollow2D.HasLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_loop", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   PathFollow2DImplementer is an interface for PathFollow2D objects.
*/
type PathFollow2DImplementer interface {
	Class
}

/*

 */
type Navigation2D struct {
	Node2D
}

func (o *Navigation2D) baseClass() string {
	return "Navigation2D"
}

/*

 */
func (o *Navigation2D) NavpolyCreate(mesh *NavigationPolygon, xform *Transform2D, owner *Object) int64 {
	log.Println("Calling Navigation2D.NavpolyCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(mesh)
	goArguments[1] = reflect.ValueOf(xform)
	goArguments[2] = reflect.ValueOf(owner)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "navpoly_create", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Navigation2D) NavpolySetTransform(id int64, xform *Transform2D) {
	log.Println("Calling Navigation2D.NavpolySetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(xform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "navpoly_set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Navigation2D) NavpolyRemove(id int64) {
	log.Println("Calling Navigation2D.NavpolyRemove()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "navpoly_remove", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Navigation2D) GetSimplePath(start *Vector2, end *Vector2, optimize bool) *PoolVector2Array {
	log.Println("Calling Navigation2D.GetSimplePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(start)
	goArguments[1] = reflect.ValueOf(end)
	goArguments[2] = reflect.ValueOf(optimize)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_simple_path", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*

 */
func (o *Navigation2D) GetClosestPoint(toPoint *Vector2) *Vector2 {
	log.Println("Calling Navigation2D.GetClosestPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_point", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Navigation2D) GetClosestPointOwner(toPoint *Vector2) *Object {
	log.Println("Calling Navigation2D.GetClosestPointOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_point_owner", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*
   Navigation2DImplementer is an interface for Navigation2D objects.
*/
type Navigation2DImplementer interface {
	Class
}

/*

 */
type NavigationPolygon struct {
	Resource
}

func (o *NavigationPolygon) baseClass() string {
	return "NavigationPolygon"
}

/*

 */
func (o *NavigationPolygon) SetVertices(vertices *PoolVector2Array) {
	log.Println("Calling NavigationPolygon.SetVertices()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vertices)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vertices", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationPolygon) GetVertices() *PoolVector2Array {
	log.Println("Calling NavigationPolygon.GetVertices()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertices", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*

 */
func (o *NavigationPolygon) AddPolygon(polygon *PoolIntArray) {
	log.Println("Calling NavigationPolygon.AddPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(polygon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_polygon", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationPolygon) GetPolygonCount() int64 {
	log.Println("Calling NavigationPolygon.GetPolygonCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_polygon_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *NavigationPolygon) GetPolygon(idx int64) *PoolIntArray {
	log.Println("Calling NavigationPolygon.GetPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_polygon", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*

 */
func (o *NavigationPolygon) ClearPolygons() {
	log.Println("Calling NavigationPolygon.ClearPolygons()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_polygons", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationPolygon) AddOutline(outline *PoolVector2Array) {
	log.Println("Calling NavigationPolygon.AddOutline()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(outline)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_outline", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationPolygon) AddOutlineAtIndex(outline *PoolVector2Array, index int64) {
	log.Println("Calling NavigationPolygon.AddOutlineAtIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(outline)
	goArguments[1] = reflect.ValueOf(index)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_outline_at_index", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationPolygon) GetOutlineCount() int64 {
	log.Println("Calling NavigationPolygon.GetOutlineCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_outline_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *NavigationPolygon) SetOutline(idx int64, outline *PoolVector2Array) {
	log.Println("Calling NavigationPolygon.SetOutline()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(outline)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_outline", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationPolygon) GetOutline(idx int64) *PoolVector2Array {
	log.Println("Calling NavigationPolygon.GetOutline()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_outline", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*

 */
func (o *NavigationPolygon) RemoveOutline(idx int64) {
	log.Println("Calling NavigationPolygon.RemoveOutline()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_outline", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationPolygon) ClearOutlines() {
	log.Println("Calling NavigationPolygon.ClearOutlines()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_outlines", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationPolygon) MakePolygonsFromOutlines() {
	log.Println("Calling NavigationPolygon.MakePolygonsFromOutlines()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "make_polygons_from_outlines", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *NavigationPolygon) X_SetPolygons(polygons *Array) {
	log.Println("Calling NavigationPolygon.X_SetPolygons()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(polygons)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_polygons", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *NavigationPolygon) X_GetPolygons() *Array {
	log.Println("Calling NavigationPolygon.X_GetPolygons()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_polygons", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Undocumented
*/
func (o *NavigationPolygon) X_SetOutlines(outlines *Array) {
	log.Println("Calling NavigationPolygon.X_SetOutlines()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(outlines)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_outlines", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *NavigationPolygon) X_GetOutlines() *Array {
	log.Println("Calling NavigationPolygon.X_GetOutlines()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_outlines", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   NavigationPolygonImplementer is an interface for NavigationPolygon objects.
*/
type NavigationPolygonImplementer interface {
	Class
}

/*

 */
type NavigationPolygonInstance struct {
	Node2D
}

func (o *NavigationPolygonInstance) baseClass() string {
	return "NavigationPolygonInstance"
}

/*

 */
func (o *NavigationPolygonInstance) SetNavigationPolygon(navpoly *NavigationPolygon) {
	log.Println("Calling NavigationPolygonInstance.SetNavigationPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(navpoly)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_navigation_polygon", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationPolygonInstance) GetNavigationPolygon() *NavigationPolygon {
	log.Println("Calling NavigationPolygonInstance.GetNavigationPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_navigation_polygon", goArguments, "*NavigationPolygon")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NavigationPolygon)

	return returnValue

}

/*

 */
func (o *NavigationPolygonInstance) SetEnabled(enabled bool) {
	log.Println("Calling NavigationPolygonInstance.SetEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationPolygonInstance) IsEnabled() bool {
	log.Println("Calling NavigationPolygonInstance.IsEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *NavigationPolygonInstance) X_NavpolyChanged() {
	log.Println("Calling NavigationPolygonInstance.X_NavpolyChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_navpoly_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   NavigationPolygonInstanceImplementer is an interface for NavigationPolygonInstance objects.
*/
type NavigationPolygonInstanceImplementer interface {
	Class
}

/*

 */
type SceneState struct {
	Reference
}

func (o *SceneState) baseClass() string {
	return "SceneState"
}

/*

 */
func (o *SceneState) GetNodeCount() int64 {
	log.Println("Calling SceneState.GetNodeCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SceneState) GetNodeType(idx int64) string {
	log.Println("Calling SceneState.GetNodeType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_type", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *SceneState) GetNodeName(idx int64) string {
	log.Println("Calling SceneState.GetNodeName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *SceneState) GetNodePath(idx int64, forParent bool) *NodePath {
	log.Println("Calling SceneState.GetNodePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(forParent)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_path", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *SceneState) GetNodeOwnerPath(idx int64) *NodePath {
	log.Println("Calling SceneState.GetNodeOwnerPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_owner_path", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *SceneState) IsNodeInstancePlaceholder(idx int64) bool {
	log.Println("Calling SceneState.IsNodeInstancePlaceholder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_node_instance_placeholder", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *SceneState) GetNodeInstancePlaceholder(idx int64) string {
	log.Println("Calling SceneState.GetNodeInstancePlaceholder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_instance_placeholder", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *SceneState) GetNodeInstance(idx int64) *PackedScene {
	log.Println("Calling SceneState.GetNodeInstance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_instance", goArguments, "*PackedScene")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PackedScene)

	return returnValue

}

/*

 */
func (o *SceneState) GetNodeGroups(idx int64) *PoolStringArray {
	log.Println("Calling SceneState.GetNodeGroups()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_groups", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*

 */
func (o *SceneState) GetNodePropertyCount(idx int64) int64 {
	log.Println("Calling SceneState.GetNodePropertyCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_property_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SceneState) GetNodePropertyName(idx int64, propIdx int64) string {
	log.Println("Calling SceneState.GetNodePropertyName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(propIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_property_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *SceneState) GetNodePropertyValue(idx int64, propIdx int64) *Variant {
	log.Println("Calling SceneState.GetNodePropertyValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(propIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_property_value", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *SceneState) GetConnectionCount() int64 {
	log.Println("Calling SceneState.GetConnectionCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SceneState) GetConnectionSource(idx int64) *NodePath {
	log.Println("Calling SceneState.GetConnectionSource()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_source", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *SceneState) GetConnectionSignal(idx int64) string {
	log.Println("Calling SceneState.GetConnectionSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_signal", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *SceneState) GetConnectionTarget(idx int64) *NodePath {
	log.Println("Calling SceneState.GetConnectionTarget()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_target", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *SceneState) GetConnectionMethod(idx int64) string {
	log.Println("Calling SceneState.GetConnectionMethod()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_method", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *SceneState) GetConnectionFlags(idx int64) int64 {
	log.Println("Calling SceneState.GetConnectionFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_flags", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SceneState) GetConnectionBinds(idx int64) *Array {
	log.Println("Calling SceneState.GetConnectionBinds()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_binds", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   SceneStateImplementer is an interface for SceneState objects.
*/
type SceneStateImplementer interface {
	Class
}

/*
   TODO: explain ownership, and that node does not need to own itself
*/
type PackedScene struct {
	Resource
}

func (o *PackedScene) baseClass() string {
	return "PackedScene"
}

/*
   Pack will ignore any sub-nodes not owned by given node. See [method Node.set_owner].
*/
func (o *PackedScene) Pack(path *Object) int64 {
	log.Println("Calling PackedScene.Pack()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "pack", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PackedScene) Instance(editState int64) *Node {
	log.Println("Calling PackedScene.Instance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(editState)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "instance", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*

 */
func (o *PackedScene) CanInstance() bool {
	log.Println("Calling PackedScene.CanInstance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "can_instance", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *PackedScene) X_SetBundledScene(arg0 *Dictionary) {
	log.Println("Calling PackedScene.X_SetBundledScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_bundled_scene", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *PackedScene) X_GetBundledScene() *Dictionary {
	log.Println("Calling PackedScene.X_GetBundledScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_bundled_scene", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*

 */
func (o *PackedScene) GetState() *SceneState {
	log.Println("Calling PackedScene.GetState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_state", goArguments, "*SceneState")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*SceneState)

	return returnValue

}

/*
   PackedSceneImplementer is an interface for PackedScene objects.
*/
type PackedSceneImplementer interface {
	Class
}

/*

 */
type SceneTree struct {
	MainLoop
}

func (o *SceneTree) baseClass() string {
	return "SceneTree"
}

/*

 */
func (o *SceneTree) GetRoot() *Viewport {
	log.Println("Calling SceneTree.GetRoot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_root", goArguments, "*Viewport")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Viewport)

	return returnValue

}

/*

 */
func (o *SceneTree) HasGroup(name string) bool {
	log.Println("Calling SceneTree.HasGroup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_group", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *SceneTree) SetAutoAcceptQuit(enabled bool) {
	log.Println("Calling SceneTree.SetAutoAcceptQuit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_auto_accept_quit", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) SetDebugCollisionsHint(enable bool) {
	log.Println("Calling SceneTree.SetDebugCollisionsHint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_debug_collisions_hint", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) IsDebuggingCollisionsHint() bool {
	log.Println("Calling SceneTree.IsDebuggingCollisionsHint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_debugging_collisions_hint", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *SceneTree) SetDebugNavigationHint(enable bool) {
	log.Println("Calling SceneTree.SetDebugNavigationHint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_debug_navigation_hint", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) IsDebuggingNavigationHint() bool {
	log.Println("Calling SceneTree.IsDebuggingNavigationHint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_debugging_navigation_hint", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *SceneTree) SetEditedSceneRoot(scene *Object) {
	log.Println("Calling SceneTree.SetEditedSceneRoot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scene)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_edited_scene_root", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) GetEditedSceneRoot() *Node {
	log.Println("Calling SceneTree.GetEditedSceneRoot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_edited_scene_root", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*

 */
func (o *SceneTree) SetPause(enable bool) {
	log.Println("Calling SceneTree.SetPause()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pause", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) IsPaused() bool {
	log.Println("Calling SceneTree.IsPaused()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_paused", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *SceneTree) SetInputAsHandled() {
	log.Println("Calling SceneTree.SetInputAsHandled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_input_as_handled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) IsInputHandled() bool {
	log.Println("Calling SceneTree.IsInputHandled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_input_handled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *SceneTree) CreateTimer(timeSec float64, pauseModeProcess bool) *SceneTreeTimer {
	log.Println("Calling SceneTree.CreateTimer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(timeSec)
	goArguments[1] = reflect.ValueOf(pauseModeProcess)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "create_timer", goArguments, "*SceneTreeTimer")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*SceneTreeTimer)

	return returnValue

}

/*

 */
func (o *SceneTree) GetNodeCount() int64 {
	log.Println("Calling SceneTree.GetNodeCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SceneTree) GetFrame() int64 {
	log.Println("Calling SceneTree.GetFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_frame", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SceneTree) Quit() {
	log.Println("Calling SceneTree.Quit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "quit", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) SetScreenStretch(mode int64, aspect int64, minsize *Vector2, shrink int64) {
	log.Println("Calling SceneTree.SetScreenStretch()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(mode)
	goArguments[1] = reflect.ValueOf(aspect)
	goArguments[2] = reflect.ValueOf(minsize)
	goArguments[3] = reflect.ValueOf(shrink)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_screen_stretch", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) QueueDelete(obj *Object) {
	log.Println("Calling SceneTree.QueueDelete()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(obj)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "queue_delete", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) CallGroupFlags(flags int64, group string, method string) *Variant {
	log.Println("Calling SceneTree.CallGroupFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(flags)
	goArguments[1] = reflect.ValueOf(group)
	goArguments[2] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "call_group_flags", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *SceneTree) NotifyGroupFlags(callFlags int64, group string, notification int64) {
	log.Println("Calling SceneTree.NotifyGroupFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(callFlags)
	goArguments[1] = reflect.ValueOf(group)
	goArguments[2] = reflect.ValueOf(notification)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "notify_group_flags", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) SetGroupFlags(callFlags int64, group string, property string, value *Variant) {
	log.Println("Calling SceneTree.SetGroupFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(callFlags)
	goArguments[1] = reflect.ValueOf(group)
	goArguments[2] = reflect.ValueOf(property)
	goArguments[3] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_group_flags", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) CallGroup(group string, method string) *Variant {
	log.Println("Calling SceneTree.CallGroup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(group)
	goArguments[1] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "call_group", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *SceneTree) NotifyGroup(group string, notification int64) {
	log.Println("Calling SceneTree.NotifyGroup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(group)
	goArguments[1] = reflect.ValueOf(notification)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "notify_group", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) SetGroup(group string, property string, value *Variant) {
	log.Println("Calling SceneTree.SetGroup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(group)
	goArguments[1] = reflect.ValueOf(property)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_group", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) GetNodesInGroup(group string) *Array {
	log.Println("Calling SceneTree.GetNodesInGroup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(group)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_nodes_in_group", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *SceneTree) SetCurrentScene(childNode *Object) {
	log.Println("Calling SceneTree.SetCurrentScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(childNode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_current_scene", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) GetCurrentScene() *Node {
	log.Println("Calling SceneTree.GetCurrentScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_scene", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*

 */
func (o *SceneTree) ChangeScene(path string) int64 {
	log.Println("Calling SceneTree.ChangeScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "change_scene", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SceneTree) ChangeSceneTo(packedScene *PackedScene) int64 {
	log.Println("Calling SceneTree.ChangeSceneTo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(packedScene)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "change_scene_to", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SceneTree) ReloadCurrentScene() int64 {
	log.Println("Calling SceneTree.ReloadCurrentScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "reload_current_scene", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *SceneTree) X_ChangeScene(arg0 *Object) {
	log.Println("Calling SceneTree.X_ChangeScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_change_scene", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the peer object to handle the RPC system (effectively enabling networking). Depending on the peer itself, the SceneTree will become a network server (check with [method is_network_server()]) and will set root node's network mode to master (see NETWORK_MODE_* constants in [Node]), or it will become a regular peer with root node set to slave. All child nodes are set to inherit the network mode by default. Handling of networking-related events (connection, disconnection, new clients) is done by connecting to SceneTree's signals.
*/
func (o *SceneTree) SetNetworkPeer(peer *NetworkedMultiplayerPeer) {
	log.Println("Calling SceneTree.SetNetworkPeer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(peer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_network_peer", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns true if this SceneTree's [NetworkedMultiplayerPeer] is in server mode (listening for connections).
*/
func (o *SceneTree) IsNetworkServer() bool {
	log.Println("Calling SceneTree.IsNetworkServer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_network_server", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns true if there is a [NetworkedMultiplayerPeer] set (with [method SceneTree.set_network_peer]).
*/
func (o *SceneTree) HasNetworkPeer() bool {
	log.Println("Calling SceneTree.HasNetworkPeer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_network_peer", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *SceneTree) GetNetworkConnectedPeers() *PoolIntArray {
	log.Println("Calling SceneTree.GetNetworkConnectedPeers()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_network_connected_peers", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*

 */
func (o *SceneTree) GetNetworkUniqueId() int64 {
	log.Println("Calling SceneTree.GetNetworkUniqueId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_network_unique_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SceneTree) GetRpcSenderId() int64 {
	log.Println("Calling SceneTree.GetRpcSenderId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rpc_sender_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SceneTree) SetRefuseNewNetworkConnections(refuse bool) {
	log.Println("Calling SceneTree.SetRefuseNewNetworkConnections()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(refuse)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_refuse_new_network_connections", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) IsRefusingNewNetworkConnections() bool {
	log.Println("Calling SceneTree.IsRefusingNewNetworkConnections()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_refusing_new_network_connections", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *SceneTree) X_NetworkPeerConnected(arg0 int64) {
	log.Println("Calling SceneTree.X_NetworkPeerConnected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_network_peer_connected", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *SceneTree) X_NetworkPeerDisconnected(arg0 int64) {
	log.Println("Calling SceneTree.X_NetworkPeerDisconnected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_network_peer_disconnected", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *SceneTree) X_ConnectedToServer() {
	log.Println("Calling SceneTree.X_ConnectedToServer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_connected_to_server", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *SceneTree) X_ConnectionFailed() {
	log.Println("Calling SceneTree.X_ConnectionFailed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_connection_failed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *SceneTree) X_ServerDisconnected() {
	log.Println("Calling SceneTree.X_ServerDisconnected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_server_disconnected", goArguments, "")

	log.Println("Got return value!")

}

/*
   SceneTreeImplementer is an interface for SceneTree objects.
*/
type SceneTreeImplementer interface {
	Class
}

/*

 */
type SceneTreeTimer struct {
	Reference
}

func (o *SceneTreeTimer) baseClass() string {
	return "SceneTreeTimer"
}

/*

 */
func (o *SceneTreeTimer) SetTimeLeft(time float64) {
	log.Println("Calling SceneTreeTimer.SetTimeLeft()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(time)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_time_left", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTreeTimer) GetTimeLeft() float64 {
	log.Println("Calling SceneTreeTimer.GetTimeLeft()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_time_left", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   SceneTreeTimerImplementer is an interface for SceneTreeTimer objects.
*/
type SceneTreeTimerImplementer interface {
	Class
}

/*
   Plugins are used by the editor to extend functionality. The most common types of plugins are those which edit a given node or resource type, import plugins and export plugins.
*/
type EditorPlugin struct {
	Node
}

func (o *EditorPlugin) baseClass() string {
	return "EditorPlugin"
}

/*

 */
func (o *EditorPlugin) ForwardCanvasGuiInput(canvasXform *Transform2D, event *InputEvent) bool {
	log.Println("Calling EditorPlugin.ForwardCanvasGuiInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(canvasXform)
	goArguments[1] = reflect.ValueOf(event)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "forward_canvas_gui_input", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   This function is called every time the 2D canvas editor draws (which overlays over the edited scene). Drawing over the supplied control will draw over the edited scene. To convert from control coordinates to edited scene coordinates (including zoom and offset), a transform is also provided. If you require this control to be redraw, call [method update_canvas].
*/
func (o *EditorPlugin) ForwardDrawOverCanvas(canvasXform *Transform2D, canvas *Control) {
	log.Println("Calling EditorPlugin.ForwardDrawOverCanvas()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(canvasXform)
	goArguments[1] = reflect.ValueOf(canvas)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "forward_draw_over_canvas", goArguments, "")

	log.Println("Got return value!")

}

/*
   Implement this function if you are interested in 3D view screen input events. It will be called only if currently selected node is handled by your plugin. If you would like to always gets those input events then additionally use [method set_input_forwarding_always_enabled].
*/
func (o *EditorPlugin) ForwardSpatialGuiInput(camera *Camera, event *InputEvent) bool {
	log.Println("Calling EditorPlugin.ForwardSpatialGuiInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(camera)
	goArguments[1] = reflect.ValueOf(event)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "forward_spatial_gui_input", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   This is used for plugins that create gizmos used by the spatial editor. Just check that the node passed in the "for_spatial" argument matches your plugin.
*/
func (o *EditorPlugin) CreateSpatialGizmo(forSpatial *Spatial) *EditorSpatialGizmo {
	log.Println("Calling EditorPlugin.CreateSpatialGizmo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(forSpatial)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "create_spatial_gizmo", goArguments, "*EditorSpatialGizmo")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*EditorSpatialGizmo)

	return returnValue

}

/*

 */
func (o *EditorPlugin) GetPluginName() string {
	log.Println("Calling EditorPlugin.GetPluginName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_plugin_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return true if this is a main screen editor plugin (it goes in the main screen selector together with 2D, 3D, Script).
*/
func (o *EditorPlugin) HasMainScreen() bool {
	log.Println("Calling EditorPlugin.HasMainScreen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_main_screen", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   This function will be called when the editor is requested to become visible. It is used for plugins that edit a specific object type. Remember that you have to manage the visibility of all your editor controls manually.
*/
func (o *EditorPlugin) MakeVisible(visible bool) {
	log.Println("Calling EditorPlugin.MakeVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(visible)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "make_visible", goArguments, "")

	log.Println("Got return value!")

}

/*
   This function is used for plugins that edit specific object types (nodes or resources). It requests the editor to edit the given object.
*/
func (o *EditorPlugin) Edit(object *Object) {
	log.Println("Calling EditorPlugin.Edit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(object)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "edit", goArguments, "")

	log.Println("Got return value!")

}

/*
   Implement this function if your plugin edits a specific type of object (Resource or Node). If you return true, then you will get the functions [method EditorPlugin.edit] and [method EditorPlugin.make_visible] called when the editor requests them.
*/
func (o *EditorPlugin) Handles(object *Object) bool {
	log.Println("Calling EditorPlugin.Handles()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(object)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "handles", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Get the state of your plugin editor. This is used when saving the scene (so state is kept when opening it again) and for switching tabs (so state can be restored when the tab returns).
*/
func (o *EditorPlugin) GetState() *Dictionary {
	log.Println("Calling EditorPlugin.GetState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_state", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
   Restore the state saved by [method EditorPlugin.get_state].
*/
func (o *EditorPlugin) SetState(state *Dictionary) {
	log.Println("Calling EditorPlugin.SetState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(state)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_state", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear all the state and reset the object being edited to zero. This ensures your plugin does not keep editing a currently existing node, or a node from the wrong scene.
*/
func (o *EditorPlugin) Clear() {
	log.Println("Calling EditorPlugin.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   This method is called after the editor saves the project or when it's closed. It asks the plugin to save edited external scenes/resources.
*/
func (o *EditorPlugin) SaveExternalData() {
	log.Println("Calling EditorPlugin.SaveExternalData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "save_external_data", goArguments, "")

	log.Println("Got return value!")

}

/*
   This method is called when the editor is about to save the project, switch to another tab, etc. It asks the plugin to apply any pending state changes to ensure consistency. This is used, for example, in shader editors to let the plugin know that it must apply the shader code being written by the user to the object.
*/
func (o *EditorPlugin) ApplyChanges() {
	log.Println("Calling EditorPlugin.ApplyChanges()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "apply_changes", goArguments, "")

	log.Println("Got return value!")

}

/*
   This is for editors that edit script based objects. You can return a list of breakpoints in the format (script:line), for example: res://path_to_script.gd:25
*/
func (o *EditorPlugin) GetBreakpoints() *PoolStringArray {
	log.Println("Calling EditorPlugin.GetBreakpoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_breakpoints", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Restore the plugin GUI layout saved by [method EditorPlugin.get_window_layout].
*/
func (o *EditorPlugin) SetWindowLayout(layout *ConfigFile) {
	log.Println("Calling EditorPlugin.SetWindowLayout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layout)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_window_layout", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the GUI layout of the plugin. This is used to save the project's editor layout when the [method EditorPlugin.queue_save_layout] is called or the editor layout was changed(For example changing the position of a dock).
*/
func (o *EditorPlugin) GetWindowLayout(layout *ConfigFile) {
	log.Println("Calling EditorPlugin.GetWindowLayout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layout)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "get_window_layout", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a custom control to a container (see CONTAINER_* enum). There are many locations where custom controls can be added in the editor UI. Please remember that you have to manage the visibility of your custom controls yourself (and likely hide it after adding it). If your plugin is being removed, also make sure to remove your custom controls too.
*/
func (o *EditorPlugin) AddControlToContainer(container int64, control *Object) {
	log.Println("Calling EditorPlugin.AddControlToContainer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(container)
	goArguments[1] = reflect.ValueOf(control)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_control_to_container", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a control to the bottom panel (together with Output, Debug, Animation, etc). Returns a reference to the button added. It's up to you to hide/show the button when needed. If your plugin is being removed, also make sure to remove your control by calling [method remove_control_from_bottom_panel].
*/
func (o *EditorPlugin) AddControlToBottomPanel(control *Object, title string) *ToolButton {
	log.Println("Calling EditorPlugin.AddControlToBottomPanel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(control)
	goArguments[1] = reflect.ValueOf(title)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "add_control_to_bottom_panel", goArguments, "*ToolButton")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*ToolButton)

	return returnValue

}

/*
   Add the control to a specific dock slot (see DOCK_* enum for options). If the dock is repositioned and as long as the plugin is active, the editor will save the dock position on further sessions. If your plugin is being removed, also make sure to remove your control by calling [method remove_control_from_docks].
*/
func (o *EditorPlugin) AddControlToDock(slot int64, control *Object) {
	log.Println("Calling EditorPlugin.AddControlToDock()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(slot)
	goArguments[1] = reflect.ValueOf(control)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_control_to_dock", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove the control from the dock. Don't forget to call this if you added one, so the editor can save the layout and remove it cleanly.
*/
func (o *EditorPlugin) RemoveControlFromDocks(control *Object) {
	log.Println("Calling EditorPlugin.RemoveControlFromDocks()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(control)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_control_from_docks", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove the control from the bottom panel. Don't forget to call this if you added one, so the editor can remove it cleanly.
*/
func (o *EditorPlugin) RemoveControlFromBottomPanel(control *Object) {
	log.Println("Calling EditorPlugin.RemoveControlFromBottomPanel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(control)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_control_from_bottom_panel", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorPlugin) AddToolSubmenuItem(name string, submenu *Object) {
	log.Println("Calling EditorPlugin.AddToolSubmenuItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(submenu)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_tool_submenu_item", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a custom type, which will appear in the list of nodes or resources. An icon can be optionally passed. When given node or resource is selected, the base type will be instanced (ie, "Spatial", "Control", "Resource"), then the script will be loaded and set to this object. You can use the [method EditorPlugin.handles] to check if your custom object is being edited by checking the script or using 'is' keyword. During run-time, this will be a simple object with a script so this function does not need to be called then.
*/
func (o *EditorPlugin) AddCustomType(aType string, base string, script *Script, icon *Texture) {
	log.Println("Calling EditorPlugin.AddCustomType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(aType)
	goArguments[1] = reflect.ValueOf(base)
	goArguments[2] = reflect.ValueOf(script)
	goArguments[3] = reflect.ValueOf(icon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_custom_type", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove a custom type added by [method EditorPlugin.add_custom_type]
*/
func (o *EditorPlugin) RemoveCustomType(aType string) {
	log.Println("Calling EditorPlugin.RemoveCustomType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_custom_type", goArguments, "")

	log.Println("Got return value!")

}

/*
   Updates the control used to draw the edited scene over the 2D canvas. This is used together with [method forward_canvas_input_event].
*/
func (o *EditorPlugin) UpdateCanvas() {
	log.Println("Calling EditorPlugin.UpdateCanvas()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "update_canvas", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorPlugin) MakeBottomPanelItemVisible(item *Object) {
	log.Println("Calling EditorPlugin.MakeBottomPanelItemVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(item)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "make_bottom_panel_item_visible", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorPlugin) HideBottomPanel() {
	log.Println("Calling EditorPlugin.HideBottomPanel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "hide_bottom_panel", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the undo/redo object. Most actions in the editor can be undoable, so use this object to make sure this happens when it's worth it.
*/
func (o *EditorPlugin) GetUndoRedo() *UndoRedo {
	log.Println("Calling EditorPlugin.GetUndoRedo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_undo_redo", goArguments, "*UndoRedo")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*UndoRedo)

	return returnValue

}

/*
   Queue save the project's editor layout.
*/
func (o *EditorPlugin) QueueSaveLayout() {
	log.Println("Calling EditorPlugin.QueueSaveLayout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "queue_save_layout", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorPlugin) AddImportPlugin(importer *EditorImportPlugin) {
	log.Println("Calling EditorPlugin.AddImportPlugin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(importer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_import_plugin", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorPlugin) RemoveImportPlugin(importer *EditorImportPlugin) {
	log.Println("Calling EditorPlugin.RemoveImportPlugin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(importer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_import_plugin", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorPlugin) AddExportPlugin(exporter *EditorExportPlugin) {
	log.Println("Calling EditorPlugin.AddExportPlugin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(exporter)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_export_plugin", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorPlugin) RemoveExportPlugin(exporter *EditorExportPlugin) {
	log.Println("Calling EditorPlugin.RemoveExportPlugin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(exporter)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_export_plugin", goArguments, "")

	log.Println("Got return value!")

}

/*
   Use this method if you always want to receive inputs from 3D view screen inside [method forward_spatial_gui_input]. It might be especially usable if your plugin will want to use raycast in the scene.
*/
func (o *EditorPlugin) SetInputEventForwardingAlwaysEnabled() {
	log.Println("Calling EditorPlugin.SetInputEventForwardingAlwaysEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_input_event_forwarding_always_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorPlugin) GetEditorInterface() *EditorInterface {
	log.Println("Calling EditorPlugin.GetEditorInterface()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_editor_interface", goArguments, "*EditorInterface")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*EditorInterface)

	return returnValue

}

/*
   EditorPluginImplementer is an interface for EditorPlugin objects.
*/
type EditorPluginImplementer interface {
	Class
}

/*
   EditorImportPlugins provide a way to extend the editor's resource import functionality. Use them to import resources from custom files or to provide alternatives to the editor's existing importers. Register your [EditorPlugin] with [method EditorPlugin.add_import_plugin]. EditorImportPlugins work by associating with specific file extensions and a resource type. See [method get_recognized_extension] and [method get_resource_type]). They may optionally specify some import presets that affect the import process. EditorImportPlugins are responsible for creating the resources and saving them in the [code].import[/code] directory. Below is an example EditorImportPlugin that imports a [Mesh] from a file with the extension ".special" or ".spec": [codeblock] tool extends EditorImportPlugin func get_importer_name(): return "my.special.plugin" func get_visible_name(): return "Special Mesh Importer" func get_recognized_extensions(): return ["special", "spec"] func get_save_extension(): return "mesh" func get_resource_type(): return "Mesh" func get_preset_count(): return 1 func get_preset_name(i): return "Default" func get_import_optons(i): return [{"name": "my_option", "default_value": false}] func load(src, dst, opts, r_platform_variants, r_gen_files): var f = File.new() if f.open(src, File.READ) != OK: return FAILED var mesh = Mesh.new() var save = dst + "." + get_save_extension() ResourceSaver.save(file, mesh) return OK [/codeblock]
*/
type EditorImportPlugin struct {
	Reference
}

func (o *EditorImportPlugin) baseClass() string {
	return "EditorImportPlugin"
}

/*
   Get the unique name of the importer.
*/
func (o *EditorImportPlugin) GetImporterName() string {
	log.Println("Calling EditorImportPlugin.GetImporterName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_importer_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the name to display in the import window.
*/
func (o *EditorImportPlugin) GetVisibleName() string {
	log.Println("Calling EditorImportPlugin.GetVisibleName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_visible_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the number of initial presets defined by the plugin. Use [method get_import_options] to get the default options for the preset and [method get_preset_name] to get the name of the preset.
*/
func (o *EditorImportPlugin) GetPresetCount() int64 {
	log.Println("Calling EditorImportPlugin.GetPresetCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_preset_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the name of the options preset at this index.
*/
func (o *EditorImportPlugin) GetPresetName(preset int64) string {
	log.Println("Calling EditorImportPlugin.GetPresetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(preset)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_preset_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the list of file extensions to associate with this loader (case insensitive). e.g. ["obj"].
*/
func (o *EditorImportPlugin) GetRecognizedExtensions() *Array {
	log.Println("Calling EditorImportPlugin.GetRecognizedExtensions()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_recognized_extensions", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Get the options and default values for the preset at this index. Returns an Array of Dictionaries with the following keys: "name", "default_value", "property_hint" (optional), "hint_string" (optional), "usage" (optional).
*/
func (o *EditorImportPlugin) GetImportOptions(preset int64) *Array {
	log.Println("Calling EditorImportPlugin.GetImportOptions()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(preset)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_import_options", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Get the extension used to save this resource in the [code].import[/code] directory.
*/
func (o *EditorImportPlugin) GetSaveExtension() string {
	log.Println("Calling EditorImportPlugin.GetSaveExtension()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_save_extension", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the godot resource type associated with this loader. e.g. "Mesh" or "Animation".
*/
func (o *EditorImportPlugin) GetResourceType() string {
	log.Println("Calling EditorImportPlugin.GetResourceType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_resource_type", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *EditorImportPlugin) GetOptionVisibility(option string, options *Dictionary) bool {
	log.Println("Calling EditorImportPlugin.GetOptionVisibility()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(option)
	goArguments[1] = reflect.ValueOf(options)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_option_visibility", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *EditorImportPlugin) Import(sourceFile string, savePath string, options *Dictionary, rPlatformVariants *Array, rGenFiles *Array) int64 {
	log.Println("Calling EditorImportPlugin.Import()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(sourceFile)
	goArguments[1] = reflect.ValueOf(savePath)
	goArguments[2] = reflect.ValueOf(options)
	goArguments[3] = reflect.ValueOf(rPlatformVariants)
	goArguments[4] = reflect.ValueOf(rGenFiles)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "import", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   EditorImportPluginImplementer is an interface for EditorImportPlugin objects.
*/
type EditorImportPluginImplementer interface {
	Class
}

/*
   This script can be run from the Scene -> Run Script menu option.
*/
type EditorScript struct {
	Reference
}

func (o *EditorScript) baseClass() string {
	return "EditorScript"
}

/*

 */
func (o *EditorScript) X_Run() {
	log.Println("Calling EditorScript.X_Run()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_run", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorScript) AddRootNode(node *Object) {
	log.Println("Calling EditorScript.AddRootNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_root_node", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorScript) GetScene() *Node {
	log.Println("Calling EditorScript.GetScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scene", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*

 */
func (o *EditorScript) GetEditorInterface() *EditorInterface {
	log.Println("Calling EditorScript.GetEditorInterface()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_editor_interface", goArguments, "*EditorInterface")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*EditorInterface)

	return returnValue

}

/*
   EditorScriptImplementer is an interface for EditorScript objects.
*/
type EditorScriptImplementer interface {
	Class
}

/*
   This object manages the SceneTree selection in the editor.
*/
type EditorSelection struct {
	Object
}

func (o *EditorSelection) baseClass() string {
	return "EditorSelection"
}

/*
   Undocumented
*/
func (o *EditorSelection) X_NodeRemoved(arg0 *Object) {
	log.Println("Calling EditorSelection.X_NodeRemoved()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_node_removed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear the selection.
*/
func (o *EditorSelection) Clear() {
	log.Println("Calling EditorSelection.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a node to the selection.
*/
func (o *EditorSelection) AddNode(node *Object) {
	log.Println("Calling EditorSelection.AddNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_node", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove a node from the selection.
*/
func (o *EditorSelection) RemoveNode(node *Object) {
	log.Println("Calling EditorSelection.RemoveNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_node", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the list of selectes nodes.
*/
func (o *EditorSelection) GetSelectedNodes() *Array {
	log.Println("Calling EditorSelection.GetSelectedNodes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_selected_nodes", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Get the list of selected nodes, optimized for transform operations (ie, moving them, rotating, etc). This list avoids situations where a node is selected and also chid/grandchild.
*/
func (o *EditorSelection) GetTransformableSelectedNodes() *Array {
	log.Println("Calling EditorSelection.GetTransformableSelectedNodes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_transformable_selected_nodes", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   EditorSelectionImplementer is an interface for EditorSelection objects.
*/
type EditorSelectionImplementer interface {
	Class
}

/*

 */
type EditorFileDialog struct {
	ConfirmationDialog
}

func (o *EditorFileDialog) baseClass() string {
	return "EditorFileDialog"
}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_UnhandledInput(arg0 *InputEvent) {
	log.Println("Calling EditorFileDialog.X_UnhandledInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_unhandled_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_ItemSelected(arg0 int64) {
	log.Println("Calling EditorFileDialog.X_ItemSelected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_item_selected", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_ItemDbSelected(arg0 int64) {
	log.Println("Calling EditorFileDialog.X_ItemDbSelected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_item_db_selected", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_DirEntered(arg0 string) {
	log.Println("Calling EditorFileDialog.X_DirEntered()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_dir_entered", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_FileEntered(arg0 string) {
	log.Println("Calling EditorFileDialog.X_FileEntered()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_file_entered", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_ActionPressed() {
	log.Println("Calling EditorFileDialog.X_ActionPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_action_pressed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_CancelPressed() {
	log.Println("Calling EditorFileDialog.X_CancelPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_cancel_pressed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_FilterSelected(arg0 int64) {
	log.Println("Calling EditorFileDialog.X_FilterSelected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_filter_selected", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_SaveConfirmPressed() {
	log.Println("Calling EditorFileDialog.X_SaveConfirmPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_save_confirm_pressed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorFileDialog) ClearFilters() {
	log.Println("Calling EditorFileDialog.ClearFilters()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_filters", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorFileDialog) AddFilter(filter string) {
	log.Println("Calling EditorFileDialog.AddFilter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(filter)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_filter", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorFileDialog) GetCurrentDir() string {
	log.Println("Calling EditorFileDialog.GetCurrentDir()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_dir", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *EditorFileDialog) GetCurrentFile() string {
	log.Println("Calling EditorFileDialog.GetCurrentFile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_file", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *EditorFileDialog) GetCurrentPath() string {
	log.Println("Calling EditorFileDialog.GetCurrentPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *EditorFileDialog) SetCurrentDir(dir string) {
	log.Println("Calling EditorFileDialog.SetCurrentDir()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(dir)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_current_dir", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorFileDialog) SetCurrentFile(file string) {
	log.Println("Calling EditorFileDialog.SetCurrentFile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(file)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_current_file", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorFileDialog) SetCurrentPath(path string) {
	log.Println("Calling EditorFileDialog.SetCurrentPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_current_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorFileDialog) SetMode(mode int64) {
	log.Println("Calling EditorFileDialog.SetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorFileDialog) GetMode() int64 {
	log.Println("Calling EditorFileDialog.GetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *EditorFileDialog) GetVbox() *VBoxContainer {
	log.Println("Calling EditorFileDialog.GetVbox()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vbox", goArguments, "*VBoxContainer")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*VBoxContainer)

	return returnValue

}

/*

 */
func (o *EditorFileDialog) SetAccess(access int64) {
	log.Println("Calling EditorFileDialog.SetAccess()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(access)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_access", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorFileDialog) GetAccess() int64 {
	log.Println("Calling EditorFileDialog.GetAccess()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_access", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *EditorFileDialog) SetShowHiddenFiles(show bool) {
	log.Println("Calling EditorFileDialog.SetShowHiddenFiles()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(show)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_show_hidden_files", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorFileDialog) IsShowingHiddenFiles() bool {
	log.Println("Calling EditorFileDialog.IsShowingHiddenFiles()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_showing_hidden_files", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_SelectDrive(arg0 int64) {
	log.Println("Calling EditorFileDialog.X_SelectDrive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_select_drive", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_MakeDir() {
	log.Println("Calling EditorFileDialog.X_MakeDir()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_make_dir", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_MakeDirConfirm() {
	log.Println("Calling EditorFileDialog.X_MakeDirConfirm()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_make_dir_confirm", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_UpdateFileList() {
	log.Println("Calling EditorFileDialog.X_UpdateFileList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_update_file_list", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_UpdateDir() {
	log.Println("Calling EditorFileDialog.X_UpdateDir()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_update_dir", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_ThumbnailDone(arg0 string, arg1 *Texture, arg2 *Variant) {
	log.Println("Calling EditorFileDialog.X_ThumbnailDone()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(arg0)
	goArguments[1] = reflect.ValueOf(arg1)
	goArguments[2] = reflect.ValueOf(arg2)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_thumbnail_done", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorFileDialog) SetDisplayMode(mode int64) {
	log.Println("Calling EditorFileDialog.SetDisplayMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_display_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorFileDialog) GetDisplayMode() int64 {
	log.Println("Calling EditorFileDialog.GetDisplayMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_display_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_ThumbnailResult(arg0 string, arg1 *Texture, arg2 *Variant) {
	log.Println("Calling EditorFileDialog.X_ThumbnailResult()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(arg0)
	goArguments[1] = reflect.ValueOf(arg1)
	goArguments[2] = reflect.ValueOf(arg2)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_thumbnail_result", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorFileDialog) SetDisableOverwriteWarning(disable bool) {
	log.Println("Calling EditorFileDialog.SetDisableOverwriteWarning()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(disable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_disable_overwrite_warning", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorFileDialog) IsOverwriteWarningDisabled() bool {
	log.Println("Calling EditorFileDialog.IsOverwriteWarningDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_overwrite_warning_disabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_RecentSelected(arg0 int64) {
	log.Println("Calling EditorFileDialog.X_RecentSelected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_recent_selected", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_GoBack() {
	log.Println("Calling EditorFileDialog.X_GoBack()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_go_back", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_GoForward() {
	log.Println("Calling EditorFileDialog.X_GoForward()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_go_forward", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_GoUp() {
	log.Println("Calling EditorFileDialog.X_GoUp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_go_up", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_FavoriteToggled(arg0 bool) {
	log.Println("Calling EditorFileDialog.X_FavoriteToggled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_favorite_toggled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_FavoriteSelected(arg0 int64) {
	log.Println("Calling EditorFileDialog.X_FavoriteSelected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_favorite_selected", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_FavoriteMoveUp() {
	log.Println("Calling EditorFileDialog.X_FavoriteMoveUp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_favorite_move_up", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_FavoriteMoveDown() {
	log.Println("Calling EditorFileDialog.X_FavoriteMoveDown()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_favorite_move_down", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorFileDialog) Invalidate() {
	log.Println("Calling EditorFileDialog.Invalidate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "invalidate", goArguments, "")

	log.Println("Got return value!")

}

/*
   EditorFileDialogImplementer is an interface for EditorFileDialog objects.
*/
type EditorFileDialogImplementer interface {
	Class
}

/*
   Object that holds the project-independent editor settings. These settings are generally visible in the Editor Settings menu. Accessing the settings is done by using the regular [Object] API, such as: [codeblock] settings.set(prop,value) settings.get(prop) list_of_settings = settings.get_property_list() [/codeblock]
*/
type EditorSettings struct {
	Resource
}

func (o *EditorSettings) baseClass() string {
	return "EditorSettings"
}

/*
   Erase a given setting (pass full property path).
*/
func (o *EditorSettings) Erase(property string) {
	log.Println("Calling EditorSettings.Erase()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(property)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "erase", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the global settings path for the engine. Inside this path you can find some standard paths such as: settings/tmp - used for temporary storage of files settings/templates - where export templates are located
*/
func (o *EditorSettings) GetSettingsPath() string {
	log.Println("Calling EditorSettings.GetSettingsPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_settings_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the specific project settings path. Projects all have a unique sub-directory inside the settings path where project specific settings are saved.
*/
func (o *EditorSettings) GetProjectSettingsPath() string {
	log.Println("Calling EditorSettings.GetProjectSettingsPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_project_settings_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Add a custom property info to a property. The dictionary must contain: name:[String](the name of the property) and type:[int](see TYPE_* in [@Global Scope]), and optionally hint:[int](see PROPERTY_HINT_* in [@Global Scope]), hint_string:[String]. Example: [codeblock] editor_settings.set("category/property_name", 0) var property_info = { "name": "category/property_name", "type": TYPE_INT, "hint": PROPERTY_HINT_ENUM, "hint_string": "one,two,three" } editor_settings.add_property_info(property_info) [/codeblock]
*/
func (o *EditorSettings) AddPropertyInfo(info *Dictionary) {
	log.Println("Calling EditorSettings.AddPropertyInfo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(info)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_property_info", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the list of favorite directories for this project.
*/
func (o *EditorSettings) SetFavoriteDirs(dirs *PoolStringArray) {
	log.Println("Calling EditorSettings.SetFavoriteDirs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(dirs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_favorite_dirs", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the list of favorite directories for this project.
*/
func (o *EditorSettings) GetFavoriteDirs() *PoolStringArray {
	log.Println("Calling EditorSettings.GetFavoriteDirs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_favorite_dirs", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Set the list of recently visited folders in the file dialog for this project.
*/
func (o *EditorSettings) SetRecentDirs(dirs *PoolStringArray) {
	log.Println("Calling EditorSettings.SetRecentDirs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(dirs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_recent_dirs", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the list of recently visited folders in the file dialog for this project.
*/
func (o *EditorSettings) GetRecentDirs() *PoolStringArray {
	log.Println("Calling EditorSettings.GetRecentDirs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_recent_dirs", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Undocumented
*/
func (o *EditorSettings) PropertyCanRevert(name string) bool {
	log.Println("Calling EditorSettings.PropertyCanRevert()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "property_can_revert", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *EditorSettings) PropertyGetRevert(name string) *Variant {
	log.Println("Calling EditorSettings.PropertyGetRevert()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "property_get_revert", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Undocumented
*/
func (o *EditorSettings) SetInitialValue(name string, value *Variant) {
	log.Println("Calling EditorSettings.SetInitialValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_initial_value", goArguments, "")

	log.Println("Got return value!")

}

/*
   EditorSettingsImplementer is an interface for EditorSettings objects.
*/
type EditorSettingsImplementer interface {
	Class
}

/*
   Custom gizmo that is used for providing custom visualization and editing (handles) for 3D Spatial objects. These are created by [method EditorPlugin.create_spatial_gizmo].
*/
type EditorSpatialGizmo struct {
	SpatialGizmo
}

func (o *EditorSpatialGizmo) baseClass() string {
	return "EditorSpatialGizmo"
}

/*
   This function is called when the Spatial this gizmo refers to changes (the [method Spatial.update_gizmo] is called).
*/
func (o *EditorSpatialGizmo) Redraw() {
	log.Println("Calling EditorSpatialGizmo.Redraw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "redraw", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the name of an edited handle (handles must have been previously added by [method add_handles]). Handles can be named for reference to the user when editing.
*/
func (o *EditorSpatialGizmo) GetHandleName(index int64) string {
	log.Println("Calling EditorSpatialGizmo.GetHandleName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_handle_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get actual value of a handle. This value can be anything and used for eventually undoing the motion when calling [method commit_handle]
*/
func (o *EditorSpatialGizmo) GetHandleValue(index int64) *Variant {
	log.Println("Calling EditorSpatialGizmo.GetHandleValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_handle_value", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   This function is used when the user drags a gizmo handle (previously added with [method add_handles]) in screen coordinates. The [Camera] is also provided so screen coordinates can be converted to raycasts.
*/
func (o *EditorSpatialGizmo) SetHandle(index int64, camera *Camera, point *Vector2) {
	log.Println("Calling EditorSpatialGizmo.SetHandle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(index)
	goArguments[1] = reflect.ValueOf(camera)
	goArguments[2] = reflect.ValueOf(point)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_handle", goArguments, "")

	log.Println("Got return value!")

}

/*
   Commit a handle being edited (handles must have been prevously added by [method add_handles]). If the cancel parameter is true, an option to restore the edited value to the original is provided.
*/
func (o *EditorSpatialGizmo) CommitHandle(index int64, restore *Variant, cancel bool) {
	log.Println("Calling EditorSpatialGizmo.CommitHandle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(index)
	goArguments[1] = reflect.ValueOf(restore)
	goArguments[2] = reflect.ValueOf(cancel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "commit_handle", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add lines to the gizmo (as sets of 2 points), with a given material. The lines are used for visualizing the gizmo. Call this function during [method redraw].
*/
func (o *EditorSpatialGizmo) AddLines(lines *PoolVector3Array, material *Material, billboard bool) {
	log.Println("Calling EditorSpatialGizmo.AddLines()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(lines)
	goArguments[1] = reflect.ValueOf(material)
	goArguments[2] = reflect.ValueOf(billboard)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_lines", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorSpatialGizmo) AddMesh(mesh *ArrayMesh, billboard bool, skeleton *RID) {
	log.Println("Calling EditorSpatialGizmo.AddMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(mesh)
	goArguments[1] = reflect.ValueOf(billboard)
	goArguments[2] = reflect.ValueOf(skeleton)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_mesh", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorSpatialGizmo) AddCollisionSegments(segments *PoolVector3Array) {
	log.Println("Calling EditorSpatialGizmo.AddCollisionSegments()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(segments)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_collision_segments", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add collision triangles to the gizmo for picking. A [TriangleMesh] can be generated from a regular [Mesh] too. Call this function during [method redraw].
*/
func (o *EditorSpatialGizmo) AddCollisionTriangles(triangles *TriangleMesh, bounds *Rect3) {
	log.Println("Calling EditorSpatialGizmo.AddCollisionTriangles()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(triangles)
	goArguments[1] = reflect.ValueOf(bounds)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_collision_triangles", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add an unscaled billboard for visualization. Call this function during [method redraw].
*/
func (o *EditorSpatialGizmo) AddUnscaledBillboard(material *Material, defaultScale float64) {
	log.Println("Calling EditorSpatialGizmo.AddUnscaledBillboard()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(material)
	goArguments[1] = reflect.ValueOf(defaultScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_unscaled_billboard", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a list of handles (points) which can be used to deform the object being edited. There are virtual functions which will be called upon editing of these handles. Call this function during [method redraw].
*/
func (o *EditorSpatialGizmo) AddHandles(handles *PoolVector3Array, billboard bool, secondary bool) {
	log.Println("Calling EditorSpatialGizmo.AddHandles()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(handles)
	goArguments[1] = reflect.ValueOf(billboard)
	goArguments[2] = reflect.ValueOf(secondary)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_handles", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorSpatialGizmo) SetSpatialNode(node *Object) {
	log.Println("Calling EditorSpatialGizmo.SetSpatialNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_spatial_node", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorSpatialGizmo) Clear() {
	log.Println("Calling EditorSpatialGizmo.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   EditorSpatialGizmoImplementer is an interface for EditorSpatialGizmo objects.
*/
type EditorSpatialGizmoImplementer interface {
	Class
}

/*
   This object is used to generate previews for resources of files.
*/
type EditorResourcePreview struct {
	Node
}

func (o *EditorResourcePreview) baseClass() string {
	return "EditorResourcePreview"
}

/*
   Undocumented
*/
func (o *EditorResourcePreview) X_PreviewReady(arg0 string, arg1 *Texture, arg2 int64, arg3 string, arg4 *Variant) {
	log.Println("Calling EditorResourcePreview.X_PreviewReady()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(arg0)
	goArguments[1] = reflect.ValueOf(arg1)
	goArguments[2] = reflect.ValueOf(arg2)
	goArguments[3] = reflect.ValueOf(arg3)
	goArguments[4] = reflect.ValueOf(arg4)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_preview_ready", goArguments, "")

	log.Println("Got return value!")

}

/*
   Queue a resource file for preview (using a path). Once the preview is ready, your receiver.receiver_func will be called either containing the preview texture or an empty texure (if no preview was possible). Callback must have the format: (path,texture,userdata). Userdata can be anything.
*/
func (o *EditorResourcePreview) QueueResourcePreview(path string, receiver *Object, receiverFunc string, userdata *Variant) {
	log.Println("Calling EditorResourcePreview.QueueResourcePreview()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(path)
	goArguments[1] = reflect.ValueOf(receiver)
	goArguments[2] = reflect.ValueOf(receiverFunc)
	goArguments[3] = reflect.ValueOf(userdata)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "queue_resource_preview", goArguments, "")

	log.Println("Got return value!")

}

/*
   Queue a resource being edited for preview (using an instance). Once the preview is ready, your receiver.receiver_func will be called either containing the preview texture or an empty texure (if no preview was possible). Callback must have the format: (path,texture,userdata). Userdata can be anything.
*/
func (o *EditorResourcePreview) QueueEditedResourcePreview(resource *Resource, receiver *Object, receiverFunc string, userdata *Variant) {
	log.Println("Calling EditorResourcePreview.QueueEditedResourcePreview()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(resource)
	goArguments[1] = reflect.ValueOf(receiver)
	goArguments[2] = reflect.ValueOf(receiverFunc)
	goArguments[3] = reflect.ValueOf(userdata)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "queue_edited_resource_preview", goArguments, "")

	log.Println("Got return value!")

}

/*
   Create an own, custom preview generator.
*/
func (o *EditorResourcePreview) AddPreviewGenerator(generator *EditorResourcePreviewGenerator) {
	log.Println("Calling EditorResourcePreview.AddPreviewGenerator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(generator)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_preview_generator", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove a custom preview generator.
*/
func (o *EditorResourcePreview) RemovePreviewGenerator(generator *EditorResourcePreviewGenerator) {
	log.Println("Calling EditorResourcePreview.RemovePreviewGenerator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(generator)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_preview_generator", goArguments, "")

	log.Println("Got return value!")

}

/*
   Check if the resource changed, if so it will be invalidated and the corresponding signal emitted.
*/
func (o *EditorResourcePreview) CheckForInvalidation(path string) {
	log.Println("Calling EditorResourcePreview.CheckForInvalidation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "check_for_invalidation", goArguments, "")

	log.Println("Got return value!")

}

/*
   EditorResourcePreviewImplementer is an interface for EditorResourcePreview objects.
*/
type EditorResourcePreviewImplementer interface {
	Class
}

/*
   Custom code to generate previews. Please check "file_dialog/thumbnail_size" in EditorSettings to find out the right size to do previews at.
*/
type EditorResourcePreviewGenerator struct {
	Reference
}

func (o *EditorResourcePreviewGenerator) baseClass() string {
	return "EditorResourcePreviewGenerator"
}

/*
   Return if your generator supports this resource type.
*/
func (o *EditorResourcePreviewGenerator) Handles(aType string) bool {
	log.Println("Calling EditorResourcePreviewGenerator.Handles()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "handles", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Generate a preview from a given resource. This must be always implemented. Returning an empty texture is an OK way to fail and let another generator take care. Care must be taken because this function is always called from a thread (not the main thread).
*/
func (o *EditorResourcePreviewGenerator) Generate(from *Resource) *Texture {
	log.Println("Calling EditorResourcePreviewGenerator.Generate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(from)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "generate", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   Generate a preview directly from a path, implementing this is optional, as default code will load and call generate() Returning an empty texture is an OK way to fail and let another generator take care. Care must be taken because this function is always called from a thread (not the main thread).
*/
func (o *EditorResourcePreviewGenerator) GenerateFromPath(path string) *Texture {
	log.Println("Calling EditorResourcePreviewGenerator.GenerateFromPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "generate_from_path", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   EditorResourcePreviewGeneratorImplementer is an interface for EditorResourcePreviewGenerator objects.
*/
type EditorResourcePreviewGeneratorImplementer interface {
	Class
}

/*
   This object holds information of all resources in the filesystem, their types, etc.
*/
type EditorFileSystem struct {
	Node
}

func (o *EditorFileSystem) baseClass() string {
	return "EditorFileSystem"
}

/*
   Get the root directory object.
*/
func (o *EditorFileSystem) GetFilesystem() *EditorFileSystemDirectory {
	log.Println("Calling EditorFileSystem.GetFilesystem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_filesystem", goArguments, "*EditorFileSystemDirectory")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*EditorFileSystemDirectory)

	return returnValue

}

/*
   Return true of the filesystem is being scanned.
*/
func (o *EditorFileSystem) IsScanning() bool {
	log.Println("Calling EditorFileSystem.IsScanning()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_scanning", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Return the scan progress for 0 to 1 if the FS is being scanned.
*/
func (o *EditorFileSystem) GetScanningProgress() float64 {
	log.Println("Calling EditorFileSystem.GetScanningProgress()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scanning_progress", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Scan the filesystem for changes.
*/
func (o *EditorFileSystem) Scan() {
	log.Println("Calling EditorFileSystem.Scan()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "scan", goArguments, "")

	log.Println("Got return value!")

}

/*
   Check if the source of any imported resource changed.
*/
func (o *EditorFileSystem) ScanSources() {
	log.Println("Calling EditorFileSystem.ScanSources()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "scan_sources", goArguments, "")

	log.Println("Got return value!")

}

/*
   Update a file information. Call this if an external program (not Godot) modified the file.
*/
func (o *EditorFileSystem) UpdateFile(path string) {
	log.Println("Calling EditorFileSystem.UpdateFile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "update_file", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorFileSystem) GetFilesystemPath(path string) *EditorFileSystemDirectory {
	log.Println("Calling EditorFileSystem.GetFilesystemPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_filesystem_path", goArguments, "*EditorFileSystemDirectory")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*EditorFileSystemDirectory)

	return returnValue

}

/*
   Get the type of the file, given the full path.
*/
func (o *EditorFileSystem) GetFileType(path string) string {
	log.Println("Calling EditorFileSystem.GetFileType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_file_type", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   EditorFileSystemImplementer is an interface for EditorFileSystem objects.
*/
type EditorFileSystemImplementer interface {
	Class
}

/*

 */
type EditorFileSystemDirectory struct {
	Object
}

func (o *EditorFileSystemDirectory) baseClass() string {
	return "EditorFileSystemDirectory"
}

/*

 */
func (o *EditorFileSystemDirectory) GetSubdirCount() int64 {
	log.Println("Calling EditorFileSystemDirectory.GetSubdirCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_subdir_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *EditorFileSystemDirectory) GetSubdir(idx int64) *EditorFileSystemDirectory {
	log.Println("Calling EditorFileSystemDirectory.GetSubdir()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_subdir", goArguments, "*EditorFileSystemDirectory")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*EditorFileSystemDirectory)

	return returnValue

}

/*

 */
func (o *EditorFileSystemDirectory) GetFileCount() int64 {
	log.Println("Calling EditorFileSystemDirectory.GetFileCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_file_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *EditorFileSystemDirectory) GetFile(idx int64) string {
	log.Println("Calling EditorFileSystemDirectory.GetFile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_file", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *EditorFileSystemDirectory) GetFilePath(idx int64) string {
	log.Println("Calling EditorFileSystemDirectory.GetFilePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_file_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *EditorFileSystemDirectory) GetFileType(idx int64) string {
	log.Println("Calling EditorFileSystemDirectory.GetFileType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_file_type", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *EditorFileSystemDirectory) GetFileImportIsValid(idx int64) bool {
	log.Println("Calling EditorFileSystemDirectory.GetFileImportIsValid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_file_import_is_valid", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *EditorFileSystemDirectory) GetName() string {
	log.Println("Calling EditorFileSystemDirectory.GetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *EditorFileSystemDirectory) GetPath() string {
	log.Println("Calling EditorFileSystemDirectory.GetPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *EditorFileSystemDirectory) GetParent() *EditorFileSystemDirectory {
	log.Println("Calling EditorFileSystemDirectory.GetParent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_parent", goArguments, "*EditorFileSystemDirectory")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*EditorFileSystemDirectory)

	return returnValue

}

/*

 */
func (o *EditorFileSystemDirectory) FindFileIndex(name string) int64 {
	log.Println("Calling EditorFileSystemDirectory.FindFileIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "find_file_index", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *EditorFileSystemDirectory) FindDirIndex(name string) int64 {
	log.Println("Calling EditorFileSystemDirectory.FindDirIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "find_dir_index", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   EditorFileSystemDirectoryImplementer is an interface for EditorFileSystemDirectory objects.
*/
type EditorFileSystemDirectoryImplementer interface {
	Class
}

/*

 */
type ScriptEditor struct {
	PanelContainer
}

func (o *ScriptEditor) baseClass() string {
	return "ScriptEditor"
}

/*
   Undocumented
*/
func (o *ScriptEditor) X_FileDialogAction(arg0 string) {
	log.Println("Calling ScriptEditor.X_FileDialogAction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_file_dialog_action", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_TabChanged(arg0 int64) {
	log.Println("Calling ScriptEditor.X_TabChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_tab_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_MenuOption(arg0 int64) {
	log.Println("Calling ScriptEditor.X_MenuOption()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_menu_option", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_CloseCurrentTab() {
	log.Println("Calling ScriptEditor.X_CloseCurrentTab()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_close_current_tab", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_CloseDiscardCurrentTab(arg0 string) {
	log.Println("Calling ScriptEditor.X_CloseDiscardCurrentTab()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_close_discard_current_tab", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_CloseDocsTab() {
	log.Println("Calling ScriptEditor.X_CloseDocsTab()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_close_docs_tab", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_CloseAllTabs() {
	log.Println("Calling ScriptEditor.X_CloseAllTabs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_close_all_tabs", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_OpenRecentScript(arg0 int64) {
	log.Println("Calling ScriptEditor.X_OpenRecentScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_open_recent_script", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_EditorPlay() {
	log.Println("Calling ScriptEditor.X_EditorPlay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_editor_play", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_EditorPause() {
	log.Println("Calling ScriptEditor.X_EditorPause()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_editor_pause", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_EditorStop() {
	log.Println("Calling ScriptEditor.X_EditorStop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_editor_stop", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_AddCallback(arg0 *Object, arg1 string, arg2 *PoolStringArray) {
	log.Println("Calling ScriptEditor.X_AddCallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(arg0)
	goArguments[1] = reflect.ValueOf(arg1)
	goArguments[2] = reflect.ValueOf(arg2)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_add_callback", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_ReloadScripts() {
	log.Println("Calling ScriptEditor.X_ReloadScripts()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_reload_scripts", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_ResaveScripts(arg0 string) {
	log.Println("Calling ScriptEditor.X_ResaveScripts()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_resave_scripts", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_ResSavedCallback(arg0 *Resource) {
	log.Println("Calling ScriptEditor.X_ResSavedCallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_res_saved_callback", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_GotoScriptLine(arg0 *Reference, arg1 int64) {
	log.Println("Calling ScriptEditor.X_GotoScriptLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(arg0)
	goArguments[1] = reflect.ValueOf(arg1)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_goto_script_line", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_GotoScriptLine2(arg0 int64) {
	log.Println("Calling ScriptEditor.X_GotoScriptLine2()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_goto_script_line2", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_HelpSearch(arg0 string) {
	log.Println("Calling ScriptEditor.X_HelpSearch()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_help_search", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_HelpIndex(arg0 string) {
	log.Println("Calling ScriptEditor.X_HelpIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_help_index", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_SaveHistory() {
	log.Println("Calling ScriptEditor.X_SaveHistory()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_save_history", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_Breaked(arg0 bool, arg1 bool) {
	log.Println("Calling ScriptEditor.X_Breaked()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(arg0)
	goArguments[1] = reflect.ValueOf(arg1)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_breaked", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_ShowDebugger(arg0 bool) {
	log.Println("Calling ScriptEditor.X_ShowDebugger()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_show_debugger", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_GetDebugTooltip(arg0 string, arg1 *Object) string {
	log.Println("Calling ScriptEditor.X_GetDebugTooltip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(arg0)
	goArguments[1] = reflect.ValueOf(arg1)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_debug_tooltip", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_AutosaveScripts() {
	log.Println("Calling ScriptEditor.X_AutosaveScripts()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_autosave_scripts", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_EditorSettingsChanged() {
	log.Println("Calling ScriptEditor.X_EditorSettingsChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_editor_settings_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_UpdateScriptNames() {
	log.Println("Calling ScriptEditor.X_UpdateScriptNames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_update_script_names", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_TreeChanged() {
	log.Println("Calling ScriptEditor.X_TreeChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_tree_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_MembersOverviewSelected(arg0 int64) {
	log.Println("Calling ScriptEditor.X_MembersOverviewSelected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_members_overview_selected", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_HelpOverviewSelected(arg0 int64) {
	log.Println("Calling ScriptEditor.X_HelpOverviewSelected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_help_overview_selected", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_ScriptSelected(arg0 int64) {
	log.Println("Calling ScriptEditor.X_ScriptSelected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_script_selected", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_ScriptCreated(arg0 *Script) {
	log.Println("Calling ScriptEditor.X_ScriptCreated()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_script_created", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_ScriptSplitDragged(arg0 float64) {
	log.Println("Calling ScriptEditor.X_ScriptSplitDragged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_script_split_dragged", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_HelpClassOpen(arg0 string) {
	log.Println("Calling ScriptEditor.X_HelpClassOpen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_help_class_open", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_HelpClassGoto(arg0 string) {
	log.Println("Calling ScriptEditor.X_HelpClassGoto()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_help_class_goto", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_RequestHelp(arg0 string) {
	log.Println("Calling ScriptEditor.X_RequestHelp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_request_help", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_HistoryForward() {
	log.Println("Calling ScriptEditor.X_HistoryForward()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_history_forward", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_HistoryBack() {
	log.Println("Calling ScriptEditor.X_HistoryBack()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_history_back", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_LiveAutoReloadRunningScripts() {
	log.Println("Calling ScriptEditor.X_LiveAutoReloadRunningScripts()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_live_auto_reload_running_scripts", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_UnhandledInput(arg0 *InputEvent) {
	log.Println("Calling ScriptEditor.X_UnhandledInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_unhandled_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_ScriptChanged() {
	log.Println("Calling ScriptEditor.X_ScriptChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_script_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns a [Script] that is currently active in editor.
*/
func (o *ScriptEditor) GetCurrentScript() *Script {
	log.Println("Calling ScriptEditor.GetCurrentScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_script", goArguments, "*Script")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Script)

	return returnValue

}

/*
   Returns an array with all [Script] objects which are currently open in editor.
*/
func (o *ScriptEditor) GetOpenScripts() *Array {
	log.Println("Calling ScriptEditor.GetOpenScripts()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_open_scripts", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   ScriptEditorImplementer is an interface for ScriptEditor objects.
*/
type ScriptEditorImplementer interface {
	Class
}

/*
   A class stored as a resource. The script exends the functionality of all objects that instance it. The 'new' method of a script subclass creates a new instance. [method Object.set_script] extends an existing object, if that object's class matches one of the script's base classes.
*/
type Script struct {
	Resource
}

func (o *Script) baseClass() string {
	return "Script"
}

/*
   Returns true if the script can be instanced.
*/
func (o *Script) CanInstance() bool {
	log.Println("Calling Script.CanInstance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "can_instance", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns true if 'base_object' is an instance of this script.
*/
func (o *Script) InstanceHas(baseObject *Object) bool {
	log.Println("Calling Script.InstanceHas()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(baseObject)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "instance_has", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns true if the script contains non-empty source code.
*/
func (o *Script) HasSourceCode() bool {
	log.Println("Calling Script.HasSourceCode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_source_code", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns the script source code, or an empty string if source code is not available.
*/
func (o *Script) GetSourceCode() string {
	log.Println("Calling Script.GetSourceCode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_source_code", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Sets the script source code. Does not reload the class implementation.
*/
func (o *Script) SetSourceCode(source string) {
	log.Println("Calling Script.SetSourceCode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(source)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_source_code", goArguments, "")

	log.Println("Got return value!")

}

/*
   Reloads the script's class implementation. Returns an error code.
*/
func (o *Script) Reload(keepState bool) int64 {
	log.Println("Calling Script.Reload()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(keepState)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "reload", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns true if the script, or a base class, defines a signal with the given name.
*/
func (o *Script) HasScriptSignal(signalName string) bool {
	log.Println("Calling Script.HasScriptSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(signalName)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_script_signal", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns true if the script is a tool script. A tool script can run in the editor.
*/
func (o *Script) IsTool() bool {
	log.Println("Calling Script.IsTool()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_tool", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *Script) GetNodeType() string {
	log.Println("Calling Script.GetNodeType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_type", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   ScriptImplementer is an interface for Script objects.
*/
type ScriptImplementer interface {
	Class
}

/*

 */
type EditorInterface struct {
	Node
}

func (o *EditorInterface) baseClass() string {
	return "EditorInterface"
}

/*

 */
func (o *EditorInterface) InspectObject(object *Object, forProperty string) {
	log.Println("Calling EditorInterface.InspectObject()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(forProperty)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "inspect_object", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorInterface) GetSelection() *EditorSelection {
	log.Println("Calling EditorInterface.GetSelection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_selection", goArguments, "*EditorSelection")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*EditorSelection)

	return returnValue

}

/*

 */
func (o *EditorInterface) GetEditorSettings() *EditorSettings {
	log.Println("Calling EditorInterface.GetEditorSettings()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_editor_settings", goArguments, "*EditorSettings")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*EditorSettings)

	return returnValue

}

/*

 */
func (o *EditorInterface) GetScriptEditor() *ScriptEditor {
	log.Println("Calling EditorInterface.GetScriptEditor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_script_editor", goArguments, "*ScriptEditor")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*ScriptEditor)

	return returnValue

}

/*

 */
func (o *EditorInterface) GetBaseControl() *Control {
	log.Println("Calling EditorInterface.GetBaseControl()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_control", goArguments, "*Control")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Control)

	return returnValue

}

/*

 */
func (o *EditorInterface) EditResource(resource *Resource) {
	log.Println("Calling EditorInterface.EditResource()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(resource)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "edit_resource", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorInterface) OpenSceneFromPath(sceneFilepath string) {
	log.Println("Calling EditorInterface.OpenSceneFromPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sceneFilepath)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "open_scene_from_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorInterface) ReloadSceneFromPath(sceneFilepath string) {
	log.Println("Calling EditorInterface.ReloadSceneFromPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sceneFilepath)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "reload_scene_from_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorInterface) GetOpenScenes() *Array {
	log.Println("Calling EditorInterface.GetOpenScenes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_open_scenes", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *EditorInterface) GetEditedSceneRoot() *Node {
	log.Println("Calling EditorInterface.GetEditedSceneRoot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_edited_scene_root", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*

 */
func (o *EditorInterface) GetResourcePreviewer() *EditorResourcePreview {
	log.Println("Calling EditorInterface.GetResourcePreviewer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_resource_previewer", goArguments, "*EditorResourcePreview")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*EditorResourcePreview)

	return returnValue

}

/*

 */
func (o *EditorInterface) GetResourceFilesystem() *EditorFileSystem {
	log.Println("Calling EditorInterface.GetResourceFilesystem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_resource_filesystem", goArguments, "*EditorFileSystem")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*EditorFileSystem)

	return returnValue

}

/*

 */
func (o *EditorInterface) GetEditorViewport() *Control {
	log.Println("Calling EditorInterface.GetEditorViewport()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_editor_viewport", goArguments, "*Control")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Control)

	return returnValue

}

/*

 */
func (o *EditorInterface) MakeMeshPreviews(arg0 *Array, arg1 int64) *Array {
	log.Println("Calling EditorInterface.MakeMeshPreviews()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(arg0)
	goArguments[1] = reflect.ValueOf(arg1)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "make_mesh_previews", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *EditorInterface) SaveScene() int64 {
	log.Println("Calling EditorInterface.SaveScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "save_scene", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *EditorInterface) SaveSceneAs(path string, withPreview bool) {
	log.Println("Calling EditorInterface.SaveSceneAs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(path)
	goArguments[1] = reflect.ValueOf(withPreview)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "save_scene_as", goArguments, "")

	log.Println("Got return value!")

}

/*
   EditorInterfaceImplementer is an interface for EditorInterface objects.
*/
type EditorInterfaceImplementer interface {
	Class
}

/*

 */
type EditorExportPlugin struct {
	Reference
}

func (o *EditorExportPlugin) baseClass() string {
	return "EditorExportPlugin"
}

/*

 */
func (o *EditorExportPlugin) X_ExportFile(path string, aType string, features *PoolStringArray) {
	log.Println("Calling EditorExportPlugin.X_ExportFile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(path)
	goArguments[1] = reflect.ValueOf(aType)
	goArguments[2] = reflect.ValueOf(features)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_export_file", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorExportPlugin) X_ExportBegin(features *PoolStringArray) {
	log.Println("Calling EditorExportPlugin.X_ExportBegin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(features)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_export_begin", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorExportPlugin) AddSharedObject(path string) {
	log.Println("Calling EditorExportPlugin.AddSharedObject()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_shared_object", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorExportPlugin) AddFile(path string, file *PoolByteArray, remap bool) {
	log.Println("Calling EditorExportPlugin.AddFile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(path)
	goArguments[1] = reflect.ValueOf(file)
	goArguments[2] = reflect.ValueOf(remap)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_file", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorExportPlugin) Skip() {
	log.Println("Calling EditorExportPlugin.Skip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "skip", goArguments, "")

	log.Println("Got return value!")

}

/*
   EditorExportPluginImplementer is an interface for EditorExportPlugin objects.
*/
type EditorExportPluginImplementer interface {
	Class
}

/*

 */
type EditorResourceConversionPlugin struct {
	Reference
}

func (o *EditorResourceConversionPlugin) baseClass() string {
	return "EditorResourceConversionPlugin"
}

/*

 */
func (o *EditorResourceConversionPlugin) X_Convert(resource *Resource) *Resource {
	log.Println("Calling EditorResourceConversionPlugin.X_Convert()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(resource)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_convert", goArguments, "*Resource")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Resource)

	return returnValue

}

/*

 */
func (o *EditorResourceConversionPlugin) X_ConvertsTo() bool {
	log.Println("Calling EditorResourceConversionPlugin.X_ConvertsTo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_converts_to", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   EditorResourceConversionPluginImplementer is an interface for EditorResourceConversionPlugin objects.
*/
type EditorResourceConversionPluginImplementer interface {
	Class
}

/*

 */
type NetworkedMultiplayerPeer struct {
	PacketPeer
}

func (o *NetworkedMultiplayerPeer) baseClass() string {
	return "NetworkedMultiplayerPeer"
}

/*

 */
func (o *NetworkedMultiplayerPeer) SetTransferMode(mode int64) {
	log.Println("Calling NetworkedMultiplayerPeer.SetTransferMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_transfer_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NetworkedMultiplayerPeer) SetTargetPeer(id int64) {
	log.Println("Calling NetworkedMultiplayerPeer.SetTargetPeer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_target_peer", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NetworkedMultiplayerPeer) GetPacketPeer() int64 {
	log.Println("Calling NetworkedMultiplayerPeer.GetPacketPeer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_packet_peer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *NetworkedMultiplayerPeer) Poll() {
	log.Println("Calling NetworkedMultiplayerPeer.Poll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "poll", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NetworkedMultiplayerPeer) GetConnectionStatus() int64 {
	log.Println("Calling NetworkedMultiplayerPeer.GetConnectionStatus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_status", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *NetworkedMultiplayerPeer) GetUniqueId() int64 {
	log.Println("Calling NetworkedMultiplayerPeer.GetUniqueId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_unique_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   If [code]endable[/code] is true, this [NetworkedMultiplayerPeer] will refuse new connections.
*/
func (o *NetworkedMultiplayerPeer) SetRefuseNewConnections(enable bool) {
	log.Println("Calling NetworkedMultiplayerPeer.SetRefuseNewConnections()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_refuse_new_connections", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether this [NetworkedMultiplayerPeer] is refusing new connections.
*/
func (o *NetworkedMultiplayerPeer) IsRefusingNewConnections() bool {
	log.Println("Calling NetworkedMultiplayerPeer.IsRefusingNewConnections()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_refusing_new_connections", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   NetworkedMultiplayerPeerImplementer is an interface for NetworkedMultiplayerPeer objects.
*/
type NetworkedMultiplayerPeerImplementer interface {
	Class
}

/*
   A connection (or a listening server) that should be passed to [method SceneTree.set_network_peer]. Socket events can be handled by connecting to [SceneTree] signals.
*/
type NetworkedMultiplayerENet struct {
	NetworkedMultiplayerPeer
}

func (o *NetworkedMultiplayerENet) baseClass() string {
	return "NetworkedMultiplayerENet"
}

/*
   Create server that listens to connections via [code]port[/code].
*/
func (o *NetworkedMultiplayerENet) CreateServer(port int64, maxClients int64, inBandwidth int64, outBandwidth int64) int64 {
	log.Println("Calling NetworkedMultiplayerENet.CreateServer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(port)
	goArguments[1] = reflect.ValueOf(maxClients)
	goArguments[2] = reflect.ValueOf(inBandwidth)
	goArguments[3] = reflect.ValueOf(outBandwidth)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "create_server", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Create client that connects to a server at address [code]ip[/code] using specified [code]port[/code].
*/
func (o *NetworkedMultiplayerENet) CreateClient(ip string, port int64, inBandwidth int64, outBandwidth int64) int64 {
	log.Println("Calling NetworkedMultiplayerENet.CreateClient()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(ip)
	goArguments[1] = reflect.ValueOf(port)
	goArguments[2] = reflect.ValueOf(inBandwidth)
	goArguments[3] = reflect.ValueOf(outBandwidth)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "create_client", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *NetworkedMultiplayerENet) CloseConnection() {
	log.Println("Calling NetworkedMultiplayerENet.CloseConnection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "close_connection", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NetworkedMultiplayerENet) SetCompressionMode(mode int64) {
	log.Println("Calling NetworkedMultiplayerENet.SetCompressionMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_compression_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NetworkedMultiplayerENet) GetCompressionMode() int64 {
	log.Println("Calling NetworkedMultiplayerENet.GetCompressionMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_compression_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *NetworkedMultiplayerENet) SetBindIp(ip string) {
	log.Println("Calling NetworkedMultiplayerENet.SetBindIp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ip)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bind_ip", goArguments, "")

	log.Println("Got return value!")

}

/*
   NetworkedMultiplayerENetImplementer is an interface for NetworkedMultiplayerENet objects.
*/
type NetworkedMultiplayerENetImplementer interface {
	Class
}

/*

 */
type GDNativeLibrary struct {
	Resource
}

func (o *GDNativeLibrary) baseClass() string {
	return "GDNativeLibrary"
}

/*

 */
func (o *GDNativeLibrary) SetLibraryPath(platform string, path string) {
	log.Println("Calling GDNativeLibrary.SetLibraryPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(platform)
	goArguments[1] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_library_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GDNativeLibrary) GetLibraryPath(platform string) string {
	log.Println("Calling GDNativeLibrary.GetLibraryPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(platform)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_library_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *GDNativeLibrary) IsSingletonGdnative() bool {
	log.Println("Calling GDNativeLibrary.IsSingletonGdnative()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_singleton_gdnative", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *GDNativeLibrary) SetSingletonGdnative(singleton bool) {
	log.Println("Calling GDNativeLibrary.SetSingletonGdnative()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(singleton)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_singleton_gdnative", goArguments, "")

	log.Println("Got return value!")

}

/*
   GDNativeLibraryImplementer is an interface for GDNativeLibrary objects.
*/
type GDNativeLibraryImplementer interface {
	Class
}

/*

 */
type GDNative struct {
	Reference
}

func (o *GDNative) baseClass() string {
	return "GDNative"
}

/*

 */
func (o *GDNative) SetLibrary(library *GDNativeLibrary) {
	log.Println("Calling GDNative.SetLibrary()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(library)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_library", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GDNative) GetLibrary() *GDNativeLibrary {
	log.Println("Calling GDNative.GetLibrary()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_library", goArguments, "*GDNativeLibrary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*GDNativeLibrary)

	return returnValue

}

/*

 */
func (o *GDNative) Initialize() bool {
	log.Println("Calling GDNative.Initialize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "initialize", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *GDNative) Terminate() bool {
	log.Println("Calling GDNative.Terminate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "terminate", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *GDNative) CallNative(procedureName string, arguments string, arg2 *Array) *Variant {
	log.Println("Calling GDNative.CallNative()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(procedureName)
	goArguments[1] = reflect.ValueOf(arguments)
	goArguments[2] = reflect.ValueOf(arg2)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "call_native", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   GDNativeImplementer is an interface for GDNative objects.
*/
type GDNativeImplementer interface {
	Class
}

/*

 */
type NativeScript struct {
	Script
}

func (o *NativeScript) baseClass() string {
	return "NativeScript"
}

/*

 */
func (o *NativeScript) SetClassName(className string) {
	log.Println("Calling NativeScript.SetClassName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(className)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_class_name", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NativeScript) GetClassName() string {
	log.Println("Calling NativeScript.GetClassName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_class_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *NativeScript) SetLibrary(library *GDNativeLibrary) {
	log.Println("Calling NativeScript.SetLibrary()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(library)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_library", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NativeScript) GetLibrary() *GDNativeLibrary {
	log.Println("Calling NativeScript.GetLibrary()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_library", goArguments, "*GDNativeLibrary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*GDNativeLibrary)

	return returnValue

}

/*

 */
func (o *NativeScript) New() *Object {
	log.Println("Calling NativeScript.New()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "new", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*
   NativeScriptImplementer is an interface for NativeScript objects.
*/
type NativeScriptImplementer interface {
	Class
}

/*
   A script implemented in the GDScript programming language. The script exends the functionality of all objects that instance it. [method new] creates a new instance of the script. [method Object.set_script] extends an existing object, if that object's class matches one of the script's base classes.
*/
type GDScript struct {
	Script
}

func (o *GDScript) baseClass() string {
	return "GDScript"
}

/*
   Returns a new instance of the script. For example: [codeblock] var MyClass = load("myclass.gd") var instance = MyClass.new() assert(instance.get_script() == MyClass) [/codeblock]
*/
func (o *GDScript) New() *Object {
	log.Println("Calling GDScript.New()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "new", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*
   Returns byte code for the script source code.
*/
func (o *GDScript) GetAsByteCode() *PoolByteArray {
	log.Println("Calling GDScript.GetAsByteCode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_as_byte_code", goArguments, "*PoolByteArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolByteArray)

	return returnValue

}

/*
   GDScriptImplementer is an interface for GDScript objects.
*/
type GDScriptImplementer interface {
	Class
}

/*
   Calling [method @GDScript.yield] within a function will cause that function to yield and return its current state as an object of this type. The yielded function call can then be resumed later by calling [method resume] on this state object.
*/
type GDFunctionState struct {
	Reference
}

func (o *GDFunctionState) baseClass() string {
	return "GDFunctionState"
}

/*
   Resume execution of the yielded function call. If handed an argument, return the argument from the [method @GDScript.yield] call in the yielded function call. You can pass e.g. an [Array] to hand multiple arguments. This function returns what the resumed function call returns, possibly another function state if yielded again.
*/
func (o *GDFunctionState) Resume(arg *Variant) *Variant {
	log.Println("Calling GDFunctionState.Resume()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "resume", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Check whether the function call may be resumed. This is not the case if the function state was already resumed. If [code]extended_check[/code] is enabled, it also checks if the associated script and object still exist. The extended check is done in debug mode as part of [method GDFunctionState.resume], but you can use this if you know you may be trying to resume without knowing for sure the object and/or script have survived up to that point.
*/
func (o *GDFunctionState) IsValid(extendedCheck bool) bool {
	log.Println("Calling GDFunctionState.IsValid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(extendedCheck)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_valid", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *GDFunctionState) X_SignalCallback() *Variant {
	log.Println("Calling GDFunctionState.X_SignalCallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_signal_callback", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   GDFunctionStateImplementer is an interface for GDFunctionState objects.
*/
type GDFunctionStateImplementer interface {
	Class
}

/*
   Undocumented
*/
type GridMap struct {
	Spatial
}

func (o *GridMap) baseClass() string {
	return "GridMap"
}

/*
   Undocumented
*/
func (o *GridMap) SetTheme(theme *MeshLibrary) {
	log.Println("Calling GridMap.SetTheme()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(theme)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_theme", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *GridMap) GetTheme() *MeshLibrary {
	log.Println("Calling GridMap.GetTheme()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_theme", goArguments, "*MeshLibrary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*MeshLibrary)

	return returnValue

}

/*
   Undocumented
*/
func (o *GridMap) SetCellSize(size *Vector3) {
	log.Println("Calling GridMap.SetCellSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cell_size", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *GridMap) GetCellSize() *Vector3 {
	log.Println("Calling GridMap.GetCellSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cell_size", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Undocumented
*/
func (o *GridMap) SetOctantSize(size int64) {
	log.Println("Calling GridMap.SetOctantSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_octant_size", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *GridMap) GetOctantSize() int64 {
	log.Println("Calling GridMap.GetOctantSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_octant_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *GridMap) SetCellItem(x int64, y int64, z int64, item int64, orientation int64) {
	log.Println("Calling GridMap.SetCellItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(x)
	goArguments[1] = reflect.ValueOf(y)
	goArguments[2] = reflect.ValueOf(z)
	goArguments[3] = reflect.ValueOf(item)
	goArguments[4] = reflect.ValueOf(orientation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cell_item", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *GridMap) GetCellItem(x int64, y int64, z int64) int64 {
	log.Println("Calling GridMap.GetCellItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(x)
	goArguments[1] = reflect.ValueOf(y)
	goArguments[2] = reflect.ValueOf(z)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cell_item", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *GridMap) GetCellItemOrientation(x int64, y int64, z int64) int64 {
	log.Println("Calling GridMap.GetCellItemOrientation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(x)
	goArguments[1] = reflect.ValueOf(y)
	goArguments[2] = reflect.ValueOf(z)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cell_item_orientation", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *GridMap) X_UpdateOctantsCallback() {
	log.Println("Calling GridMap.X_UpdateOctantsCallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_update_octants_callback", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *GridMap) ResourceChanged(resource *Resource) {
	log.Println("Calling GridMap.ResourceChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(resource)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "resource_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *GridMap) SetCenterX(enable bool) {
	log.Println("Calling GridMap.SetCenterX()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_center_x", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *GridMap) GetCenterX() bool {
	log.Println("Calling GridMap.GetCenterX()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_center_x", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *GridMap) SetCenterY(enable bool) {
	log.Println("Calling GridMap.SetCenterY()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_center_y", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *GridMap) GetCenterY() bool {
	log.Println("Calling GridMap.GetCenterY()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_center_y", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *GridMap) SetCenterZ(enable bool) {
	log.Println("Calling GridMap.SetCenterZ()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_center_z", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *GridMap) GetCenterZ() bool {
	log.Println("Calling GridMap.GetCenterZ()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_center_z", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *GridMap) SetClip(enabled bool, clipabove bool, floor int64, axis int64) {
	log.Println("Calling GridMap.SetClip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(enabled)
	goArguments[1] = reflect.ValueOf(clipabove)
	goArguments[2] = reflect.ValueOf(floor)
	goArguments[3] = reflect.ValueOf(axis)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_clip", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *GridMap) Clear() {
	log.Println("Calling GridMap.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *GridMap) GetMeshes() *Array {
	log.Println("Calling GridMap.GetMeshes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_meshes", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   GridMapImplementer is an interface for GridMap objects.
*/
type GridMapImplementer interface {
	Class
}

/*

 */
type RegExMatch struct {
	Reference
}

func (o *RegExMatch) baseClass() string {
	return "RegExMatch"
}

/*

 */
func (o *RegExMatch) GetSubject() string {
	log.Println("Calling RegExMatch.GetSubject()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_subject", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Returns the number of numeric capturing groups.
*/
func (o *RegExMatch) GetGroupCount() int64 {
	log.Println("Calling RegExMatch.GetGroupCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_group_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns an array of names of named capturing groups.
*/
func (o *RegExMatch) GetNames() *Dictionary {
	log.Println("Calling RegExMatch.GetNames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_names", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*

 */
func (o *RegExMatch) GetStrings() *Array {
	log.Println("Calling RegExMatch.GetStrings()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_strings", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Returns the result of the match in the string. An integer can be specified for numeric groups or a string for named groups. Returns -1 if that group wasn't found or doesn't exist. Defaults to 0 (whole pattern).
*/
func (o *RegExMatch) GetString(name *Variant) string {
	log.Println("Calling RegExMatch.GetString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_string", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Returns the starting position of the match in the string. An integer can be specified for numeric groups or a string for named groups. Returns -1 if that group wasn't found or doesn't exist. Defaults to 0 (whole pattern).
*/
func (o *RegExMatch) GetStart(name *Variant) int64 {
	log.Println("Calling RegExMatch.GetStart()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_start", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the end position of the match in the string. An integer can be specified for numeric groups or a string for named groups. Returns -1 if that group wasn't found or doesn't exist. Defaults to 0 (whole pattern).
*/
func (o *RegExMatch) GetEnd(name *Variant) int64 {
	log.Println("Calling RegExMatch.GetEnd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_end", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   RegExMatchImplementer is an interface for RegExMatch objects.
*/
type RegExMatchImplementer interface {
	Class
}

/*
   Class for finding text patterns in a string using regular expressions. It can not perform replacements. Regular expressions are a way to define patterns of text to be searched. Details on writing patterns are too long to explain here but the Internet is full of tutorials and detailed explanations. Once created, the RegEx object needs to be compiled with the pattern before it can be used. The pattern must be escaped first for gdscript before it is escaped for the expression. For example: [code]var exp = RegEx.new()[/code] [code]exp.compile("\\d+")[/code] would be read by RegEx as [code]\d+[/code] Similarly: [code]exp.compile("\"(?:\\\\.|[^\"])*\"")[/code] would be read as [code]"(?:\\.|[^"])*"[/code] Currently supported features: * Capturing [code]()[/code] and non-capturing [code](?:)[/code] groups * Named capturing groups [code](?P<name>)[/code] * Any character [code].[/code] * Shorthand character classes [code]\w \W \s \S \d \D[/code] * User-defined character classes such as [code][A-Za-z][/code] * Simple quantifiers [code]?[/code], [code]*[/code] and [code]+[/code] * Range quantifiers [code]{x,y}[/code] * Lazy (non-greedy) quantifiers [code]*?[/code] * Beginning [code]^[/code] and end [code]$[/code] anchors * Alternation [code]|[/code] * Backreferences [code]\1[/code], [code]\g{1}[/code], and [code]\g<name>[/code] * POSIX character classes [code][[:alnum:]][/code] * Lookahead [code](?=)[/code], [code](?!)[/code] and lookbehind [code](?<=)[/code], [code](?<!)[/code] * ASCII [code]\xFF[/code] and Unicode [code]\uFFFF[/code] code points (in a style similar to Python) * Word boundaries [code]\b[/code], [code]\B[/code]
*/
type RegEx struct {
	Reference
}

func (o *RegEx) baseClass() string {
	return "RegEx"
}

/*
   This method resets the state of the object, as it was freshly created. Namely, it unassigns the regular expression of this object.
*/
func (o *RegEx) Clear() {
	log.Println("Calling RegEx.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Compiles and assign the regular expression pattern to use.
*/
func (o *RegEx) Compile(pattern string) int64 {
	log.Println("Calling RegEx.Compile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pattern)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "compile", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Searches the text for the compiled pattern. Returns a [RegExMatch] container of the first matching reult if found, otherwise null. The region to search within can be specified without modifying where the start and end anchor would be.
*/
func (o *RegEx) Search(subject string, offset int64, end int64) *RegExMatch {
	log.Println("Calling RegEx.Search()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(subject)
	goArguments[1] = reflect.ValueOf(offset)
	goArguments[2] = reflect.ValueOf(end)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "search", goArguments, "*RegExMatch")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RegExMatch)

	return returnValue

}

/*
   Searches the text for the compiled pattern and replaces it with the specified string. Escapes and backreferences such as [code]\1[/code] and [code]\g<name>[/code] expanded and resolved. By default only the first instance is replaced but it can be changed for all instances (global replacement). The region to search within can be specified without modifying where the start and end anchor would be.
*/
func (o *RegEx) Sub(subject string, replacement string, all bool, offset int64, end int64) string {
	log.Println("Calling RegEx.Sub()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(subject)
	goArguments[1] = reflect.ValueOf(replacement)
	goArguments[2] = reflect.ValueOf(all)
	goArguments[3] = reflect.ValueOf(offset)
	goArguments[4] = reflect.ValueOf(end)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "sub", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Returns whether this object has a valid regular expression assigned.
*/
func (o *RegEx) IsValid() bool {
	log.Println("Calling RegEx.IsValid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_valid", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Returns the expression used to compile the code.
*/
func (o *RegEx) GetPattern() string {
	log.Println("Calling RegEx.GetPattern()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pattern", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Returns the number of numeric capturing groups.
*/
func (o *RegEx) GetGroupCount() int64 {
	log.Println("Calling RegEx.GetGroupCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_group_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns an array of names of named capturing groups.
*/
func (o *RegEx) GetNames() *Array {
	log.Println("Calling RegEx.GetNames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_names", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   RegExImplementer is an interface for RegEx objects.
*/
type RegExImplementer interface {
	Class
}

/*

 */
type ResourceImporterOGGVorbis struct {
	ResourceImporter
}

func (o *ResourceImporterOGGVorbis) baseClass() string {
	return "ResourceImporterOGGVorbis"
}

/*
   ResourceImporterOGGVorbisImplementer is an interface for ResourceImporterOGGVorbis objects.
*/
type ResourceImporterOGGVorbisImplementer interface {
	Class
}

/*

 */
type ResourceImporter struct {
	Reference
}

func (o *ResourceImporter) baseClass() string {
	return "ResourceImporter"
}

/*
   ResourceImporterImplementer is an interface for ResourceImporter objects.
*/
type ResourceImporterImplementer interface {
	Class
}

/*
   OGG Vorbis audio stream driver.
*/
type AudioStreamOGGVorbis struct {
	AudioStream
}

func (o *AudioStreamOGGVorbis) baseClass() string {
	return "AudioStreamOGGVorbis"
}

/*

 */
func (o *AudioStreamOGGVorbis) SetData(data *PoolByteArray) {
	log.Println("Calling AudioStreamOGGVorbis.SetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_data", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamOGGVorbis) GetData() *PoolByteArray {
	log.Println("Calling AudioStreamOGGVorbis.GetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_data", goArguments, "*PoolByteArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolByteArray)

	return returnValue

}

/*

 */
func (o *AudioStreamOGGVorbis) SetLoop(enable bool) {
	log.Println("Calling AudioStreamOGGVorbis.SetLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_loop", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamOGGVorbis) HasLoop() bool {
	log.Println("Calling AudioStreamOGGVorbis.HasLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_loop", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *AudioStreamOGGVorbis) SetLoopOffset(seconds float64) {
	log.Println("Calling AudioStreamOGGVorbis.SetLoopOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(seconds)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_loop_offset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamOGGVorbis) GetLoopOffset() float64 {
	log.Println("Calling AudioStreamOGGVorbis.GetLoopOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_loop_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   AudioStreamOGGVorbisImplementer is an interface for AudioStreamOGGVorbis objects.
*/
type AudioStreamOGGVorbisImplementer interface {
	Class
}

/*

 */
type VisualScript struct {
	Script
}

func (o *VisualScript) baseClass() string {
	return "VisualScript"
}

/*
   Undocumented
*/
func (o *VisualScript) X_NodePortsChanged(arg0 int64) {
	log.Println("Calling VisualScript.X_NodePortsChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_node_ports_changed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) AddFunction(name string) {
	log.Println("Calling VisualScript.AddFunction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_function", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) HasFunction(name string) bool {
	log.Println("Calling VisualScript.HasFunction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_function", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *VisualScript) RemoveFunction(name string) {
	log.Println("Calling VisualScript.RemoveFunction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_function", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) RenameFunction(name string, newName string) {
	log.Println("Calling VisualScript.RenameFunction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(newName)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rename_function", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) SetFunctionScroll(name string, ofs *Vector2) {
	log.Println("Calling VisualScript.SetFunctionScroll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(ofs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_function_scroll", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) GetFunctionScroll(name string) *Vector2 {
	log.Println("Calling VisualScript.GetFunctionScroll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_function_scroll", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *VisualScript) AddNode(function string, id int64, node *VisualScriptNode, position *Vector2) {
	log.Println("Calling VisualScript.AddNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(function)
	goArguments[1] = reflect.ValueOf(id)
	goArguments[2] = reflect.ValueOf(node)
	goArguments[3] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_node", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) RemoveNode(function string, id int64) {
	log.Println("Calling VisualScript.RemoveNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(function)
	goArguments[1] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_node", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) GetFunctionNodeId(name string) int64 {
	log.Println("Calling VisualScript.GetFunctionNodeId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_function_node_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScript) GetNode(function string, id int64) *VisualScriptNode {
	log.Println("Calling VisualScript.GetNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(function)
	goArguments[1] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node", goArguments, "*VisualScriptNode")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*VisualScriptNode)

	return returnValue

}

/*

 */
func (o *VisualScript) HasNode(function string, id int64) bool {
	log.Println("Calling VisualScript.HasNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(function)
	goArguments[1] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_node", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *VisualScript) SetNodePosition(function string, id int64, position *Vector2) {
	log.Println("Calling VisualScript.SetNodePosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(function)
	goArguments[1] = reflect.ValueOf(id)
	goArguments[2] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_node_position", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) GetNodePosition(function string, id int64) *Vector2 {
	log.Println("Calling VisualScript.GetNodePosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(function)
	goArguments[1] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *VisualScript) SequenceConnect(function string, fromNode int64, fromOutput int64, toNode int64) {
	log.Println("Calling VisualScript.SequenceConnect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(function)
	goArguments[1] = reflect.ValueOf(fromNode)
	goArguments[2] = reflect.ValueOf(fromOutput)
	goArguments[3] = reflect.ValueOf(toNode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "sequence_connect", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) SequenceDisconnect(function string, fromNode int64, fromOutput int64, toNode int64) {
	log.Println("Calling VisualScript.SequenceDisconnect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(function)
	goArguments[1] = reflect.ValueOf(fromNode)
	goArguments[2] = reflect.ValueOf(fromOutput)
	goArguments[3] = reflect.ValueOf(toNode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "sequence_disconnect", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) HasSequenceConnection(function string, fromNode int64, fromOutput int64, toNode int64) bool {
	log.Println("Calling VisualScript.HasSequenceConnection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(function)
	goArguments[1] = reflect.ValueOf(fromNode)
	goArguments[2] = reflect.ValueOf(fromOutput)
	goArguments[3] = reflect.ValueOf(toNode)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_sequence_connection", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *VisualScript) DataConnect(function string, fromNode int64, fromPort int64, toNode int64, toPort int64) {
	log.Println("Calling VisualScript.DataConnect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(function)
	goArguments[1] = reflect.ValueOf(fromNode)
	goArguments[2] = reflect.ValueOf(fromPort)
	goArguments[3] = reflect.ValueOf(toNode)
	goArguments[4] = reflect.ValueOf(toPort)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "data_connect", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) DataDisconnect(function string, fromNode int64, fromPort int64, toNode int64, toPort int64) {
	log.Println("Calling VisualScript.DataDisconnect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(function)
	goArguments[1] = reflect.ValueOf(fromNode)
	goArguments[2] = reflect.ValueOf(fromPort)
	goArguments[3] = reflect.ValueOf(toNode)
	goArguments[4] = reflect.ValueOf(toPort)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "data_disconnect", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) HasDataConnection(function string, fromNode int64, fromPort int64, toNode int64, toPort int64) bool {
	log.Println("Calling VisualScript.HasDataConnection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(function)
	goArguments[1] = reflect.ValueOf(fromNode)
	goArguments[2] = reflect.ValueOf(fromPort)
	goArguments[3] = reflect.ValueOf(toNode)
	goArguments[4] = reflect.ValueOf(toPort)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_data_connection", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *VisualScript) AddVariable(name string, defaultValue *Variant, export bool) {
	log.Println("Calling VisualScript.AddVariable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(defaultValue)
	goArguments[2] = reflect.ValueOf(export)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_variable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) HasVariable(name string) bool {
	log.Println("Calling VisualScript.HasVariable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_variable", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *VisualScript) RemoveVariable(name string) {
	log.Println("Calling VisualScript.RemoveVariable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_variable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) SetVariableDefaultValue(name string, value *Variant) {
	log.Println("Calling VisualScript.SetVariableDefaultValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_variable_default_value", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) GetVariableDefaultValue(name string) *Variant {
	log.Println("Calling VisualScript.GetVariableDefaultValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_variable_default_value", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *VisualScript) SetVariableInfo(name string, value *Dictionary) {
	log.Println("Calling VisualScript.SetVariableInfo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_variable_info", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) GetVariableInfo(name string) *Dictionary {
	log.Println("Calling VisualScript.GetVariableInfo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_variable_info", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*

 */
func (o *VisualScript) SetVariableExport(name string, enable bool) {
	log.Println("Calling VisualScript.SetVariableExport()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_variable_export", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) GetVariableExport(name string) bool {
	log.Println("Calling VisualScript.GetVariableExport()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_variable_export", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *VisualScript) RenameVariable(name string, newName string) {
	log.Println("Calling VisualScript.RenameVariable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(newName)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rename_variable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) AddCustomSignal(name string) {
	log.Println("Calling VisualScript.AddCustomSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_custom_signal", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) HasCustomSignal(name string) bool {
	log.Println("Calling VisualScript.HasCustomSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_custom_signal", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *VisualScript) CustomSignalAddArgument(name string, aType int64, argname string, index int64) {
	log.Println("Calling VisualScript.CustomSignalAddArgument()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)
	goArguments[2] = reflect.ValueOf(argname)
	goArguments[3] = reflect.ValueOf(index)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "custom_signal_add_argument", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) CustomSignalSetArgumentType(name string, argidx int64, aType int64) {
	log.Println("Calling VisualScript.CustomSignalSetArgumentType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(argidx)
	goArguments[2] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "custom_signal_set_argument_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) CustomSignalGetArgumentType(name string, argidx int64) int64 {
	log.Println("Calling VisualScript.CustomSignalGetArgumentType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(argidx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "custom_signal_get_argument_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScript) CustomSignalSetArgumentName(name string, argidx int64, argname string) {
	log.Println("Calling VisualScript.CustomSignalSetArgumentName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(argidx)
	goArguments[2] = reflect.ValueOf(argname)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "custom_signal_set_argument_name", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) CustomSignalGetArgumentName(name string, argidx int64) string {
	log.Println("Calling VisualScript.CustomSignalGetArgumentName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(argidx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "custom_signal_get_argument_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScript) CustomSignalRemoveArgument(name string, argidx int64) {
	log.Println("Calling VisualScript.CustomSignalRemoveArgument()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(argidx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "custom_signal_remove_argument", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) CustomSignalGetArgumentCount(name string) int64 {
	log.Println("Calling VisualScript.CustomSignalGetArgumentCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "custom_signal_get_argument_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScript) CustomSignalSwapArgument(name string, argidx int64, withidx int64) {
	log.Println("Calling VisualScript.CustomSignalSwapArgument()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(argidx)
	goArguments[2] = reflect.ValueOf(withidx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "custom_signal_swap_argument", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) RemoveCustomSignal(name string) {
	log.Println("Calling VisualScript.RemoveCustomSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_custom_signal", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) RenameCustomSignal(name string, newName string) {
	log.Println("Calling VisualScript.RenameCustomSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(newName)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rename_custom_signal", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) SetInstanceBaseType(aType string) {
	log.Println("Calling VisualScript.SetInstanceBaseType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_instance_base_type", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *VisualScript) X_SetData(data *Dictionary) {
	log.Println("Calling VisualScript.X_SetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_data", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *VisualScript) X_GetData() *Dictionary {
	log.Println("Calling VisualScript.X_GetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_data", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
   VisualScriptImplementer is an interface for VisualScript objects.
*/
type VisualScriptImplementer interface {
	Class
}

/*

 */
type VisualScriptNode struct {
	Resource
}

func (o *VisualScriptNode) baseClass() string {
	return "VisualScriptNode"
}

/*

 */
func (o *VisualScriptNode) GetVisualScript() *VisualScript {
	log.Println("Calling VisualScriptNode.GetVisualScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_visual_script", goArguments, "*VisualScript")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*VisualScript)

	return returnValue

}

/*

 */
func (o *VisualScriptNode) SetDefaultInputValue(portIdx int64, value *Variant) {
	log.Println("Calling VisualScriptNode.SetDefaultInputValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(portIdx)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_default_input_value", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptNode) GetDefaultInputValue(portIdx int64) *Variant {
	log.Println("Calling VisualScriptNode.GetDefaultInputValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(portIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_default_input_value", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptNode) X_SetDefaultInputValues(values *Array) {
	log.Println("Calling VisualScriptNode.X_SetDefaultInputValues()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(values)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_default_input_values", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *VisualScriptNode) X_GetDefaultInputValues() *Array {
	log.Println("Calling VisualScriptNode.X_GetDefaultInputValues()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_default_input_values", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   VisualScriptNodeImplementer is an interface for VisualScriptNode objects.
*/
type VisualScriptNodeImplementer interface {
	Class
}

/*

 */
type VisualScriptFunctionState struct {
	Reference
}

func (o *VisualScriptFunctionState) baseClass() string {
	return "VisualScriptFunctionState"
}

/*

 */
func (o *VisualScriptFunctionState) ConnectToSignal(obj *Object, signals string, args *Array) {
	log.Println("Calling VisualScriptFunctionState.ConnectToSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(obj)
	goArguments[1] = reflect.ValueOf(signals)
	goArguments[2] = reflect.ValueOf(args)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "connect_to_signal", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptFunctionState) Resume(args *Array) *Variant {
	log.Println("Calling VisualScriptFunctionState.Resume()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(args)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "resume", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *VisualScriptFunctionState) IsValid() bool {
	log.Println("Calling VisualScriptFunctionState.IsValid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_valid", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptFunctionState) X_SignalCallback() *Variant {
	log.Println("Calling VisualScriptFunctionState.X_SignalCallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_signal_callback", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   VisualScriptFunctionStateImplementer is an interface for VisualScriptFunctionState objects.
*/
type VisualScriptFunctionStateImplementer interface {
	Class
}

/*

 */
type VisualScriptFunction struct {
	VisualScriptNode
}

func (o *VisualScriptFunction) baseClass() string {
	return "VisualScriptFunction"
}

/*
   VisualScriptFunctionImplementer is an interface for VisualScriptFunction objects.
*/
type VisualScriptFunctionImplementer interface {
	Class
}

/*

 */
type VisualScriptOperator struct {
	VisualScriptNode
}

func (o *VisualScriptOperator) baseClass() string {
	return "VisualScriptOperator"
}

/*

 */
func (o *VisualScriptOperator) SetOperator(op int64) {
	log.Println("Calling VisualScriptOperator.SetOperator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(op)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_operator", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptOperator) GetOperator() int64 {
	log.Println("Calling VisualScriptOperator.GetOperator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_operator", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptOperator) SetTyped(aType int64) {
	log.Println("Calling VisualScriptOperator.SetTyped()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_typed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptOperator) GetTyped() int64 {
	log.Println("Calling VisualScriptOperator.GetTyped()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_typed", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   VisualScriptOperatorImplementer is an interface for VisualScriptOperator objects.
*/
type VisualScriptOperatorImplementer interface {
	Class
}

/*

 */
type VisualScriptVariableSet struct {
	VisualScriptNode
}

func (o *VisualScriptVariableSet) baseClass() string {
	return "VisualScriptVariableSet"
}

/*

 */
func (o *VisualScriptVariableSet) SetVariable(name string) {
	log.Println("Calling VisualScriptVariableSet.SetVariable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_variable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptVariableSet) GetVariable() string {
	log.Println("Calling VisualScriptVariableSet.GetVariable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_variable", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   VisualScriptVariableSetImplementer is an interface for VisualScriptVariableSet objects.
*/
type VisualScriptVariableSetImplementer interface {
	Class
}

/*

 */
type VisualScriptVariableGet struct {
	VisualScriptNode
}

func (o *VisualScriptVariableGet) baseClass() string {
	return "VisualScriptVariableGet"
}

/*

 */
func (o *VisualScriptVariableGet) SetVariable(name string) {
	log.Println("Calling VisualScriptVariableGet.SetVariable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_variable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptVariableGet) GetVariable() string {
	log.Println("Calling VisualScriptVariableGet.GetVariable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_variable", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   VisualScriptVariableGetImplementer is an interface for VisualScriptVariableGet objects.
*/
type VisualScriptVariableGetImplementer interface {
	Class
}

/*

 */
type VisualScriptConstant struct {
	VisualScriptNode
}

func (o *VisualScriptConstant) baseClass() string {
	return "VisualScriptConstant"
}

/*

 */
func (o *VisualScriptConstant) SetConstantType(aType int64) {
	log.Println("Calling VisualScriptConstant.SetConstantType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_constant_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptConstant) GetConstantType() int64 {
	log.Println("Calling VisualScriptConstant.GetConstantType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_constant_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptConstant) SetConstantValue(value *Variant) {
	log.Println("Calling VisualScriptConstant.SetConstantValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_constant_value", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptConstant) GetConstantValue() *Variant {
	log.Println("Calling VisualScriptConstant.GetConstantValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_constant_value", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   VisualScriptConstantImplementer is an interface for VisualScriptConstant objects.
*/
type VisualScriptConstantImplementer interface {
	Class
}

/*

 */
type VisualScriptIndexGet struct {
	VisualScriptNode
}

func (o *VisualScriptIndexGet) baseClass() string {
	return "VisualScriptIndexGet"
}

/*
   VisualScriptIndexGetImplementer is an interface for VisualScriptIndexGet objects.
*/
type VisualScriptIndexGetImplementer interface {
	Class
}

/*

 */
type VisualScriptIndexSet struct {
	VisualScriptNode
}

func (o *VisualScriptIndexSet) baseClass() string {
	return "VisualScriptIndexSet"
}

/*
   VisualScriptIndexSetImplementer is an interface for VisualScriptIndexSet objects.
*/
type VisualScriptIndexSetImplementer interface {
	Class
}

/*

 */
type VisualScriptGlobalConstant struct {
	VisualScriptNode
}

func (o *VisualScriptGlobalConstant) baseClass() string {
	return "VisualScriptGlobalConstant"
}

/*

 */
func (o *VisualScriptGlobalConstant) SetGlobalConstant(index int64) {
	log.Println("Calling VisualScriptGlobalConstant.SetGlobalConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_global_constant", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptGlobalConstant) GetGlobalConstant() int64 {
	log.Println("Calling VisualScriptGlobalConstant.GetGlobalConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_global_constant", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   VisualScriptGlobalConstantImplementer is an interface for VisualScriptGlobalConstant objects.
*/
type VisualScriptGlobalConstantImplementer interface {
	Class
}

/*

 */
type VisualScriptClassConstant struct {
	VisualScriptNode
}

func (o *VisualScriptClassConstant) baseClass() string {
	return "VisualScriptClassConstant"
}

/*

 */
func (o *VisualScriptClassConstant) SetClassConstant(name string) {
	log.Println("Calling VisualScriptClassConstant.SetClassConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_class_constant", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptClassConstant) GetClassConstant() string {
	log.Println("Calling VisualScriptClassConstant.GetClassConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_class_constant", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptClassConstant) SetBaseType(name string) {
	log.Println("Calling VisualScriptClassConstant.SetBaseType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptClassConstant) GetBaseType() string {
	log.Println("Calling VisualScriptClassConstant.GetBaseType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_type", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   VisualScriptClassConstantImplementer is an interface for VisualScriptClassConstant objects.
*/
type VisualScriptClassConstantImplementer interface {
	Class
}

/*

 */
type VisualScriptMathConstant struct {
	VisualScriptNode
}

func (o *VisualScriptMathConstant) baseClass() string {
	return "VisualScriptMathConstant"
}

/*

 */
func (o *VisualScriptMathConstant) SetMathConstant(which int64) {
	log.Println("Calling VisualScriptMathConstant.SetMathConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(which)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_math_constant", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptMathConstant) GetMathConstant() int64 {
	log.Println("Calling VisualScriptMathConstant.GetMathConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_math_constant", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   VisualScriptMathConstantImplementer is an interface for VisualScriptMathConstant objects.
*/
type VisualScriptMathConstantImplementer interface {
	Class
}

/*

 */
type VisualScriptBasicTypeConstant struct {
	VisualScriptNode
}

func (o *VisualScriptBasicTypeConstant) baseClass() string {
	return "VisualScriptBasicTypeConstant"
}

/*

 */
func (o *VisualScriptBasicTypeConstant) SetBasicType(name int64) {
	log.Println("Calling VisualScriptBasicTypeConstant.SetBasicType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_basic_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptBasicTypeConstant) GetBasicType() int64 {
	log.Println("Calling VisualScriptBasicTypeConstant.GetBasicType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_basic_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptBasicTypeConstant) SetBasicTypeConstant(name string) {
	log.Println("Calling VisualScriptBasicTypeConstant.SetBasicTypeConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_basic_type_constant", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptBasicTypeConstant) GetBasicTypeConstant() string {
	log.Println("Calling VisualScriptBasicTypeConstant.GetBasicTypeConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_basic_type_constant", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   VisualScriptBasicTypeConstantImplementer is an interface for VisualScriptBasicTypeConstant objects.
*/
type VisualScriptBasicTypeConstantImplementer interface {
	Class
}

/*

 */
type VisualScriptEngineSingleton struct {
	VisualScriptNode
}

func (o *VisualScriptEngineSingleton) baseClass() string {
	return "VisualScriptEngineSingleton"
}

/*

 */
func (o *VisualScriptEngineSingleton) SetSingleton(name string) {
	log.Println("Calling VisualScriptEngineSingleton.SetSingleton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_singleton", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptEngineSingleton) GetSingleton() string {
	log.Println("Calling VisualScriptEngineSingleton.GetSingleton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_singleton", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   VisualScriptEngineSingletonImplementer is an interface for VisualScriptEngineSingleton objects.
*/
type VisualScriptEngineSingletonImplementer interface {
	Class
}

/*

 */
type VisualScriptSceneNode struct {
	VisualScriptNode
}

func (o *VisualScriptSceneNode) baseClass() string {
	return "VisualScriptSceneNode"
}

/*

 */
func (o *VisualScriptSceneNode) SetNodePath(path *NodePath) {
	log.Println("Calling VisualScriptSceneNode.SetNodePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_node_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptSceneNode) GetNodePath() *NodePath {
	log.Println("Calling VisualScriptSceneNode.GetNodePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_path", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*
   VisualScriptSceneNodeImplementer is an interface for VisualScriptSceneNode objects.
*/
type VisualScriptSceneNodeImplementer interface {
	Class
}

/*

 */
type VisualScriptSceneTree struct {
	VisualScriptNode
}

func (o *VisualScriptSceneTree) baseClass() string {
	return "VisualScriptSceneTree"
}

/*
   VisualScriptSceneTreeImplementer is an interface for VisualScriptSceneTree objects.
*/
type VisualScriptSceneTreeImplementer interface {
	Class
}

/*

 */
type VisualScriptResourcePath struct {
	VisualScriptNode
}

func (o *VisualScriptResourcePath) baseClass() string {
	return "VisualScriptResourcePath"
}

/*

 */
func (o *VisualScriptResourcePath) SetResourcePath(path string) {
	log.Println("Calling VisualScriptResourcePath.SetResourcePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_resource_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptResourcePath) GetResourcePath() string {
	log.Println("Calling VisualScriptResourcePath.GetResourcePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_resource_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   VisualScriptResourcePathImplementer is an interface for VisualScriptResourcePath objects.
*/
type VisualScriptResourcePathImplementer interface {
	Class
}

/*

 */
type VisualScriptSelf struct {
	VisualScriptNode
}

func (o *VisualScriptSelf) baseClass() string {
	return "VisualScriptSelf"
}

/*
   VisualScriptSelfImplementer is an interface for VisualScriptSelf objects.
*/
type VisualScriptSelfImplementer interface {
	Class
}

/*

 */
type VisualScriptCustomNode struct {
	VisualScriptNode
}

func (o *VisualScriptCustomNode) baseClass() string {
	return "VisualScriptCustomNode"
}

/*

 */
func (o *VisualScriptCustomNode) X_GetOutputSequencePortCount() int64 {
	log.Println("Calling VisualScriptCustomNode.X_GetOutputSequencePortCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_output_sequence_port_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptCustomNode) X_HasInputSequencePort() bool {
	log.Println("Calling VisualScriptCustomNode.X_HasInputSequencePort()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_has_input_sequence_port", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*

 */
func (o *VisualScriptCustomNode) X_GetOutputSequencePortText(idx int64) string {
	log.Println("Calling VisualScriptCustomNode.X_GetOutputSequencePortText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_output_sequence_port_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptCustomNode) X_GetInputValuePortCount() int64 {
	log.Println("Calling VisualScriptCustomNode.X_GetInputValuePortCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_input_value_port_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptCustomNode) X_GetOutputValuePortCount() int64 {
	log.Println("Calling VisualScriptCustomNode.X_GetOutputValuePortCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_output_value_port_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptCustomNode) X_GetInputValuePortType(idx int64) int64 {
	log.Println("Calling VisualScriptCustomNode.X_GetInputValuePortType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_input_value_port_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptCustomNode) X_GetInputValuePortName(idx int64) string {
	log.Println("Calling VisualScriptCustomNode.X_GetInputValuePortName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_input_value_port_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptCustomNode) X_GetOutputValuePortType(idx int64) int64 {
	log.Println("Calling VisualScriptCustomNode.X_GetOutputValuePortType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_output_value_port_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptCustomNode) X_GetOutputValuePortName(idx int64) string {
	log.Println("Calling VisualScriptCustomNode.X_GetOutputValuePortName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_output_value_port_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptCustomNode) X_GetCaption() string {
	log.Println("Calling VisualScriptCustomNode.X_GetCaption()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_caption", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptCustomNode) X_GetText() string {
	log.Println("Calling VisualScriptCustomNode.X_GetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptCustomNode) X_GetCategory() string {
	log.Println("Calling VisualScriptCustomNode.X_GetCategory()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_category", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptCustomNode) X_GetWorkingMemorySize() int64 {
	log.Println("Calling VisualScriptCustomNode.X_GetWorkingMemorySize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_working_memory_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptCustomNode) X_Step(inputs *Array, outputs *Array, startMode int64, workingMem *Array) *Variant {
	log.Println("Calling VisualScriptCustomNode.X_Step()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(inputs)
	goArguments[1] = reflect.ValueOf(outputs)
	goArguments[2] = reflect.ValueOf(startMode)
	goArguments[3] = reflect.ValueOf(workingMem)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_step", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptCustomNode) X_ScriptChanged() {
	log.Println("Calling VisualScriptCustomNode.X_ScriptChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_script_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptCustomNodeImplementer is an interface for VisualScriptCustomNode objects.
*/
type VisualScriptCustomNodeImplementer interface {
	Class
}

/*

 */
type VisualScriptSubCall struct {
	VisualScriptNode
}

func (o *VisualScriptSubCall) baseClass() string {
	return "VisualScriptSubCall"
}

/*

 */
func (o *VisualScriptSubCall) X_Subcall(arguments *Variant) *Variant {
	log.Println("Calling VisualScriptSubCall.X_Subcall()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arguments)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_subcall", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   VisualScriptSubCallImplementer is an interface for VisualScriptSubCall objects.
*/
type VisualScriptSubCallImplementer interface {
	Class
}

/*

 */
type VisualScriptComment struct {
	VisualScriptNode
}

func (o *VisualScriptComment) baseClass() string {
	return "VisualScriptComment"
}

/*

 */
func (o *VisualScriptComment) SetTitle(title string) {
	log.Println("Calling VisualScriptComment.SetTitle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(title)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_title", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptComment) GetTitle() string {
	log.Println("Calling VisualScriptComment.GetTitle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_title", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptComment) SetDescription(description string) {
	log.Println("Calling VisualScriptComment.SetDescription()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(description)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_description", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptComment) GetDescription() string {
	log.Println("Calling VisualScriptComment.GetDescription()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_description", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptComment) SetSize(size *Vector2) {
	log.Println("Calling VisualScriptComment.SetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptComment) GetSize() *Vector2 {
	log.Println("Calling VisualScriptComment.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   VisualScriptCommentImplementer is an interface for VisualScriptComment objects.
*/
type VisualScriptCommentImplementer interface {
	Class
}

/*

 */
type VisualScriptConstructor struct {
	VisualScriptNode
}

func (o *VisualScriptConstructor) baseClass() string {
	return "VisualScriptConstructor"
}

/*

 */
func (o *VisualScriptConstructor) SetConstructorType(aType int64) {
	log.Println("Calling VisualScriptConstructor.SetConstructorType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_constructor_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptConstructor) GetConstructorType() int64 {
	log.Println("Calling VisualScriptConstructor.GetConstructorType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_constructor_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptConstructor) SetConstructor(constructor *Dictionary) {
	log.Println("Calling VisualScriptConstructor.SetConstructor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(constructor)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_constructor", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptConstructor) GetConstructor() *Dictionary {
	log.Println("Calling VisualScriptConstructor.GetConstructor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_constructor", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
   VisualScriptConstructorImplementer is an interface for VisualScriptConstructor objects.
*/
type VisualScriptConstructorImplementer interface {
	Class
}

/*

 */
type VisualScriptLocalVar struct {
	VisualScriptNode
}

func (o *VisualScriptLocalVar) baseClass() string {
	return "VisualScriptLocalVar"
}

/*

 */
func (o *VisualScriptLocalVar) SetVarName(name string) {
	log.Println("Calling VisualScriptLocalVar.SetVarName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_var_name", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptLocalVar) GetVarName() string {
	log.Println("Calling VisualScriptLocalVar.GetVarName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_var_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptLocalVar) SetVarType(aType int64) {
	log.Println("Calling VisualScriptLocalVar.SetVarType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_var_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptLocalVar) GetVarType() int64 {
	log.Println("Calling VisualScriptLocalVar.GetVarType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_var_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   VisualScriptLocalVarImplementer is an interface for VisualScriptLocalVar objects.
*/
type VisualScriptLocalVarImplementer interface {
	Class
}

/*

 */
type VisualScriptLocalVarSet struct {
	VisualScriptNode
}

func (o *VisualScriptLocalVarSet) baseClass() string {
	return "VisualScriptLocalVarSet"
}

/*

 */
func (o *VisualScriptLocalVarSet) SetVarName(name string) {
	log.Println("Calling VisualScriptLocalVarSet.SetVarName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_var_name", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptLocalVarSet) GetVarName() string {
	log.Println("Calling VisualScriptLocalVarSet.GetVarName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_var_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptLocalVarSet) SetVarType(aType int64) {
	log.Println("Calling VisualScriptLocalVarSet.SetVarType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_var_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptLocalVarSet) GetVarType() int64 {
	log.Println("Calling VisualScriptLocalVarSet.GetVarType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_var_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   VisualScriptLocalVarSetImplementer is an interface for VisualScriptLocalVarSet objects.
*/
type VisualScriptLocalVarSetImplementer interface {
	Class
}

/*

 */
type VisualScriptInputAction struct {
	VisualScriptNode
}

func (o *VisualScriptInputAction) baseClass() string {
	return "VisualScriptInputAction"
}

/*

 */
func (o *VisualScriptInputAction) SetActionName(name string) {
	log.Println("Calling VisualScriptInputAction.SetActionName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_action_name", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptInputAction) GetActionName() string {
	log.Println("Calling VisualScriptInputAction.GetActionName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_action_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptInputAction) SetActionMode(mode int64) {
	log.Println("Calling VisualScriptInputAction.SetActionMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_action_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptInputAction) GetActionMode() int64 {
	log.Println("Calling VisualScriptInputAction.GetActionMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_action_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   VisualScriptInputActionImplementer is an interface for VisualScriptInputAction objects.
*/
type VisualScriptInputActionImplementer interface {
	Class
}

/*

 */
type VisualScriptDeconstruct struct {
	VisualScriptNode
}

func (o *VisualScriptDeconstruct) baseClass() string {
	return "VisualScriptDeconstruct"
}

/*

 */
func (o *VisualScriptDeconstruct) SetDeconstructType(aType int64) {
	log.Println("Calling VisualScriptDeconstruct.SetDeconstructType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_deconstruct_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptDeconstruct) GetDeconstructType() int64 {
	log.Println("Calling VisualScriptDeconstruct.GetDeconstructType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_deconstruct_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptDeconstruct) X_SetElemCache(cache *Array) {
	log.Println("Calling VisualScriptDeconstruct.X_SetElemCache()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(cache)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_elem_cache", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *VisualScriptDeconstruct) X_GetElemCache() *Array {
	log.Println("Calling VisualScriptDeconstruct.X_GetElemCache()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_elem_cache", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   VisualScriptDeconstructImplementer is an interface for VisualScriptDeconstruct objects.
*/
type VisualScriptDeconstructImplementer interface {
	Class
}

/*

 */
type VisualScriptPreload struct {
	VisualScriptNode
}

func (o *VisualScriptPreload) baseClass() string {
	return "VisualScriptPreload"
}

/*

 */
func (o *VisualScriptPreload) SetPreload(resource *Resource) {
	log.Println("Calling VisualScriptPreload.SetPreload()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(resource)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_preload", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPreload) GetPreload() *Resource {
	log.Println("Calling VisualScriptPreload.GetPreload()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_preload", goArguments, "*Resource")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Resource)

	return returnValue

}

/*
   VisualScriptPreloadImplementer is an interface for VisualScriptPreload objects.
*/
type VisualScriptPreloadImplementer interface {
	Class
}

/*

 */
type VisualScriptTypeCast struct {
	VisualScriptNode
}

func (o *VisualScriptTypeCast) baseClass() string {
	return "VisualScriptTypeCast"
}

/*

 */
func (o *VisualScriptTypeCast) SetBaseType(aType string) {
	log.Println("Calling VisualScriptTypeCast.SetBaseType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptTypeCast) GetBaseType() string {
	log.Println("Calling VisualScriptTypeCast.GetBaseType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_type", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptTypeCast) SetBaseScript(path string) {
	log.Println("Calling VisualScriptTypeCast.SetBaseScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_script", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptTypeCast) GetBaseScript() string {
	log.Println("Calling VisualScriptTypeCast.GetBaseScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_script", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   VisualScriptTypeCastImplementer is an interface for VisualScriptTypeCast objects.
*/
type VisualScriptTypeCastImplementer interface {
	Class
}

/*

 */
type VisualScriptFunctionCall struct {
	VisualScriptNode
}

func (o *VisualScriptFunctionCall) baseClass() string {
	return "VisualScriptFunctionCall"
}

/*

 */
func (o *VisualScriptFunctionCall) SetBaseType(baseType string) {
	log.Println("Calling VisualScriptFunctionCall.SetBaseType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(baseType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptFunctionCall) GetBaseType() string {
	log.Println("Calling VisualScriptFunctionCall.GetBaseType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_type", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptFunctionCall) SetBaseScript(baseScript string) {
	log.Println("Calling VisualScriptFunctionCall.SetBaseScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(baseScript)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_script", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptFunctionCall) GetBaseScript() string {
	log.Println("Calling VisualScriptFunctionCall.GetBaseScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_script", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptFunctionCall) SetBasicType(basicType int64) {
	log.Println("Calling VisualScriptFunctionCall.SetBasicType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(basicType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_basic_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptFunctionCall) GetBasicType() int64 {
	log.Println("Calling VisualScriptFunctionCall.GetBasicType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_basic_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptFunctionCall) SetSingleton(singleton string) {
	log.Println("Calling VisualScriptFunctionCall.SetSingleton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(singleton)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_singleton", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptFunctionCall) GetSingleton() string {
	log.Println("Calling VisualScriptFunctionCall.GetSingleton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_singleton", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptFunctionCall) SetFunction(function string) {
	log.Println("Calling VisualScriptFunctionCall.SetFunction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(function)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_function", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptFunctionCall) GetFunction() string {
	log.Println("Calling VisualScriptFunctionCall.GetFunction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_function", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptFunctionCall) SetCallMode(mode int64) {
	log.Println("Calling VisualScriptFunctionCall.SetCallMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_call_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptFunctionCall) GetCallMode() int64 {
	log.Println("Calling VisualScriptFunctionCall.GetCallMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_call_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptFunctionCall) SetBasePath(basePath *NodePath) {
	log.Println("Calling VisualScriptFunctionCall.SetBasePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(basePath)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptFunctionCall) GetBasePath() *NodePath {
	log.Println("Calling VisualScriptFunctionCall.GetBasePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_path", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *VisualScriptFunctionCall) SetUseDefaultArgs(amount int64) {
	log.Println("Calling VisualScriptFunctionCall.SetUseDefaultArgs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_default_args", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptFunctionCall) GetUseDefaultArgs() int64 {
	log.Println("Calling VisualScriptFunctionCall.GetUseDefaultArgs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_use_default_args", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptFunctionCall) X_SetArgumentCache(argumentCache *Dictionary) {
	log.Println("Calling VisualScriptFunctionCall.X_SetArgumentCache()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(argumentCache)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_argument_cache", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *VisualScriptFunctionCall) X_GetArgumentCache() *Dictionary {
	log.Println("Calling VisualScriptFunctionCall.X_GetArgumentCache()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_argument_cache", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*

 */
func (o *VisualScriptFunctionCall) SetRpcCallMode(mode int64) {
	log.Println("Calling VisualScriptFunctionCall.SetRpcCallMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rpc_call_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptFunctionCall) GetRpcCallMode() int64 {
	log.Println("Calling VisualScriptFunctionCall.GetRpcCallMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rpc_call_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptFunctionCall) SetValidate(enable bool) {
	log.Println("Calling VisualScriptFunctionCall.SetValidate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_validate", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptFunctionCall) GetValidate() bool {
	log.Println("Calling VisualScriptFunctionCall.GetValidate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_validate", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   VisualScriptFunctionCallImplementer is an interface for VisualScriptFunctionCall objects.
*/
type VisualScriptFunctionCallImplementer interface {
	Class
}

/*

 */
type VisualScriptPropertySet struct {
	VisualScriptNode
}

func (o *VisualScriptPropertySet) baseClass() string {
	return "VisualScriptPropertySet"
}

/*

 */
func (o *VisualScriptPropertySet) SetBaseType(baseType string) {
	log.Println("Calling VisualScriptPropertySet.SetBaseType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(baseType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertySet) GetBaseType() string {
	log.Println("Calling VisualScriptPropertySet.GetBaseType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_type", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertySet) SetBaseScript(baseScript string) {
	log.Println("Calling VisualScriptPropertySet.SetBaseScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(baseScript)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_script", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertySet) GetBaseScript() string {
	log.Println("Calling VisualScriptPropertySet.GetBaseScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_script", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertySet) SetBasicType(basicType int64) {
	log.Println("Calling VisualScriptPropertySet.SetBasicType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(basicType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_basic_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertySet) GetBasicType() int64 {
	log.Println("Calling VisualScriptPropertySet.GetBasicType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_basic_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptPropertySet) X_SetTypeCache(typeCache *Dictionary) {
	log.Println("Calling VisualScriptPropertySet.X_SetTypeCache()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(typeCache)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_type_cache", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *VisualScriptPropertySet) X_GetTypeCache() *Dictionary {
	log.Println("Calling VisualScriptPropertySet.X_GetTypeCache()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_type_cache", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertySet) SetProperty(property string) {
	log.Println("Calling VisualScriptPropertySet.SetProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(property)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_property", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertySet) GetProperty() string {
	log.Println("Calling VisualScriptPropertySet.GetProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_property", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertySet) SetCallMode(mode int64) {
	log.Println("Calling VisualScriptPropertySet.SetCallMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_call_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertySet) GetCallMode() int64 {
	log.Println("Calling VisualScriptPropertySet.GetCallMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_call_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertySet) SetBasePath(basePath *NodePath) {
	log.Println("Calling VisualScriptPropertySet.SetBasePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(basePath)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertySet) GetBasePath() *NodePath {
	log.Println("Calling VisualScriptPropertySet.GetBasePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_path", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertySet) SetIndex(index string) {
	log.Println("Calling VisualScriptPropertySet.SetIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_index", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertySet) GetIndex() string {
	log.Println("Calling VisualScriptPropertySet.GetIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_index", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertySet) SetAssignOp(assignOp int64) {
	log.Println("Calling VisualScriptPropertySet.SetAssignOp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(assignOp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_assign_op", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertySet) GetAssignOp() int64 {
	log.Println("Calling VisualScriptPropertySet.GetAssignOp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_assign_op", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   VisualScriptPropertySetImplementer is an interface for VisualScriptPropertySet objects.
*/
type VisualScriptPropertySetImplementer interface {
	Class
}

/*

 */
type VisualScriptPropertyGet struct {
	VisualScriptNode
}

func (o *VisualScriptPropertyGet) baseClass() string {
	return "VisualScriptPropertyGet"
}

/*

 */
func (o *VisualScriptPropertyGet) SetBaseType(baseType string) {
	log.Println("Calling VisualScriptPropertyGet.SetBaseType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(baseType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertyGet) GetBaseType() string {
	log.Println("Calling VisualScriptPropertyGet.GetBaseType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_type", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertyGet) SetBaseScript(baseScript string) {
	log.Println("Calling VisualScriptPropertyGet.SetBaseScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(baseScript)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_script", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertyGet) GetBaseScript() string {
	log.Println("Calling VisualScriptPropertyGet.GetBaseScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_script", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertyGet) SetBasicType(basicType int64) {
	log.Println("Calling VisualScriptPropertyGet.SetBasicType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(basicType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_basic_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertyGet) GetBasicType() int64 {
	log.Println("Calling VisualScriptPropertyGet.GetBasicType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_basic_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptPropertyGet) X_SetTypeCache(typeCache int64) {
	log.Println("Calling VisualScriptPropertyGet.X_SetTypeCache()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(typeCache)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_type_cache", goArguments, "")

	log.Println("Got return value!")

}

/*
   Undocumented
*/
func (o *VisualScriptPropertyGet) X_GetTypeCache() int64 {
	log.Println("Calling VisualScriptPropertyGet.X_GetTypeCache()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_type_cache", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertyGet) SetProperty(property string) {
	log.Println("Calling VisualScriptPropertyGet.SetProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(property)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_property", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertyGet) GetProperty() string {
	log.Println("Calling VisualScriptPropertyGet.GetProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_property", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertyGet) SetCallMode(mode int64) {
	log.Println("Calling VisualScriptPropertyGet.SetCallMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_call_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertyGet) GetCallMode() int64 {
	log.Println("Calling VisualScriptPropertyGet.GetCallMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_call_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertyGet) SetBasePath(basePath *NodePath) {
	log.Println("Calling VisualScriptPropertyGet.SetBasePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(basePath)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertyGet) GetBasePath() *NodePath {
	log.Println("Calling VisualScriptPropertyGet.GetBasePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_path", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertyGet) SetIndex(index string) {
	log.Println("Calling VisualScriptPropertyGet.SetIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_index", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertyGet) GetIndex() string {
	log.Println("Calling VisualScriptPropertyGet.GetIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_index", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   VisualScriptPropertyGetImplementer is an interface for VisualScriptPropertyGet objects.
*/
type VisualScriptPropertyGetImplementer interface {
	Class
}

/*

 */
type VisualScriptEmitSignal struct {
	VisualScriptNode
}

func (o *VisualScriptEmitSignal) baseClass() string {
	return "VisualScriptEmitSignal"
}

/*

 */
func (o *VisualScriptEmitSignal) SetSignal(name string) {
	log.Println("Calling VisualScriptEmitSignal.SetSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_signal", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptEmitSignal) GetSignal() string {
	log.Println("Calling VisualScriptEmitSignal.GetSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_signal", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   VisualScriptEmitSignalImplementer is an interface for VisualScriptEmitSignal objects.
*/
type VisualScriptEmitSignalImplementer interface {
	Class
}

/*

 */
type VisualScriptReturn struct {
	VisualScriptNode
}

func (o *VisualScriptReturn) baseClass() string {
	return "VisualScriptReturn"
}

/*

 */
func (o *VisualScriptReturn) SetReturnType(aType int64) {
	log.Println("Calling VisualScriptReturn.SetReturnType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_return_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptReturn) GetReturnType() int64 {
	log.Println("Calling VisualScriptReturn.GetReturnType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_return_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptReturn) SetEnableReturnValue(enable bool) {
	log.Println("Calling VisualScriptReturn.SetEnableReturnValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enable_return_value", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptReturn) IsReturnValueEnabled() bool {
	log.Println("Calling VisualScriptReturn.IsReturnValueEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_return_value_enabled", goArguments, "bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(bool)

	return returnValue

}

/*
   VisualScriptReturnImplementer is an interface for VisualScriptReturn objects.
*/
type VisualScriptReturnImplementer interface {
	Class
}

/*

 */
type VisualScriptIterator struct {
	VisualScriptNode
}

func (o *VisualScriptIterator) baseClass() string {
	return "VisualScriptIterator"
}

/*
   VisualScriptIteratorImplementer is an interface for VisualScriptIterator objects.
*/
type VisualScriptIteratorImplementer interface {
	Class
}

/*

 */
type VisualScriptCondition struct {
	VisualScriptNode
}

func (o *VisualScriptCondition) baseClass() string {
	return "VisualScriptCondition"
}

/*
   VisualScriptConditionImplementer is an interface for VisualScriptCondition objects.
*/
type VisualScriptConditionImplementer interface {
	Class
}

/*

 */
type VisualScriptWhile struct {
	VisualScriptNode
}

func (o *VisualScriptWhile) baseClass() string {
	return "VisualScriptWhile"
}

/*
   VisualScriptWhileImplementer is an interface for VisualScriptWhile objects.
*/
type VisualScriptWhileImplementer interface {
	Class
}

/*

 */
type VisualScriptSequence struct {
	VisualScriptNode
}

func (o *VisualScriptSequence) baseClass() string {
	return "VisualScriptSequence"
}

/*

 */
func (o *VisualScriptSequence) SetSteps(steps int64) {
	log.Println("Calling VisualScriptSequence.SetSteps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(steps)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_steps", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptSequence) GetSteps() int64 {
	log.Println("Calling VisualScriptSequence.GetSteps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_steps", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   VisualScriptSequenceImplementer is an interface for VisualScriptSequence objects.
*/
type VisualScriptSequenceImplementer interface {
	Class
}

/*

 */
type VisualScriptSwitch struct {
	VisualScriptNode
}

func (o *VisualScriptSwitch) baseClass() string {
	return "VisualScriptSwitch"
}

/*
   VisualScriptSwitchImplementer is an interface for VisualScriptSwitch objects.
*/
type VisualScriptSwitchImplementer interface {
	Class
}

/*

 */
type VisualScriptSelect struct {
	VisualScriptNode
}

func (o *VisualScriptSelect) baseClass() string {
	return "VisualScriptSelect"
}

/*

 */
func (o *VisualScriptSelect) SetTyped(aType int64) {
	log.Println("Calling VisualScriptSelect.SetTyped()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_typed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptSelect) GetTyped() int64 {
	log.Println("Calling VisualScriptSelect.GetTyped()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_typed", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   VisualScriptSelectImplementer is an interface for VisualScriptSelect objects.
*/
type VisualScriptSelectImplementer interface {
	Class
}

/*

 */
type VisualScriptYield struct {
	VisualScriptNode
}

func (o *VisualScriptYield) baseClass() string {
	return "VisualScriptYield"
}

/*

 */
func (o *VisualScriptYield) SetYieldMode(mode int64) {
	log.Println("Calling VisualScriptYield.SetYieldMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_yield_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptYield) GetYieldMode() int64 {
	log.Println("Calling VisualScriptYield.GetYieldMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_yield_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptYield) SetWaitTime(sec float64) {
	log.Println("Calling VisualScriptYield.SetWaitTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_wait_time", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptYield) GetWaitTime() float64 {
	log.Println("Calling VisualScriptYield.GetWaitTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_wait_time", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   VisualScriptYieldImplementer is an interface for VisualScriptYield objects.
*/
type VisualScriptYieldImplementer interface {
	Class
}

/*

 */
type VisualScriptYieldSignal struct {
	VisualScriptNode
}

func (o *VisualScriptYieldSignal) baseClass() string {
	return "VisualScriptYieldSignal"
}

/*

 */
func (o *VisualScriptYieldSignal) SetBaseType(baseType string) {
	log.Println("Calling VisualScriptYieldSignal.SetBaseType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(baseType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptYieldSignal) GetBaseType() string {
	log.Println("Calling VisualScriptYieldSignal.GetBaseType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_type", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptYieldSignal) SetSignal(signal string) {
	log.Println("Calling VisualScriptYieldSignal.SetSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(signal)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_signal", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptYieldSignal) GetSignal() string {
	log.Println("Calling VisualScriptYieldSignal.GetSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_signal", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptYieldSignal) SetCallMode(mode int64) {
	log.Println("Calling VisualScriptYieldSignal.SetCallMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_call_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptYieldSignal) GetCallMode() int64 {
	log.Println("Calling VisualScriptYieldSignal.GetCallMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_call_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptYieldSignal) SetBasePath(basePath *NodePath) {
	log.Println("Calling VisualScriptYieldSignal.SetBasePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(basePath)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptYieldSignal) GetBasePath() *NodePath {
	log.Println("Calling VisualScriptYieldSignal.GetBasePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_path", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*
   VisualScriptYieldSignalImplementer is an interface for VisualScriptYieldSignal objects.
*/
type VisualScriptYieldSignalImplementer interface {
	Class
}

/*

 */
type VisualScriptBuiltinFunc struct {
	VisualScriptNode
}

func (o *VisualScriptBuiltinFunc) baseClass() string {
	return "VisualScriptBuiltinFunc"
}

/*

 */
func (o *VisualScriptBuiltinFunc) SetFunc(which int64) {
	log.Println("Calling VisualScriptBuiltinFunc.SetFunc()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(which)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_func", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptBuiltinFunc) GetFunc() int64 {
	log.Println("Calling VisualScriptBuiltinFunc.GetFunc()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_func", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   VisualScriptBuiltinFuncImplementer is an interface for VisualScriptBuiltinFunc objects.
*/
type VisualScriptBuiltinFuncImplementer interface {
	Class
}

/*

 */
type VisualScriptExpression struct {
	VisualScriptNode
}

func (o *VisualScriptExpression) baseClass() string {
	return "VisualScriptExpression"
}

/*
   VisualScriptExpressionImplementer is an interface for VisualScriptExpression objects.
*/
type VisualScriptExpressionImplementer interface {
	Class
}

// godotToGoConverter is a function that will convert a Godot object into
// a Go object.
type godotToGoConverter func(gdObject unsafe.Pointer) reflect.Value

// godotToGoConversionMap is an internal mapping of Godot types to functions that can
// convert to Go types. This mapping is essentially a more optimal case/switch
// system for converting Godot types to Go types.
var godotToGoConversionMap = map[string]godotToGoConverter{
	"bool": func(gdObject unsafe.Pointer) reflect.Value {
		converted := (*C.godot_bool)(gdObject)
		return reflect.ValueOf(godotBoolAsBool(*converted))
	},
	"int64": func(gdObject unsafe.Pointer) reflect.Value {
		converted := (*C.godot_int)(gdObject)
		return reflect.ValueOf(godotIntAsInt(*converted))
	},
	"uint64": func(gdObject unsafe.Pointer) reflect.Value {
		converted := (*C.uint64_t)(gdObject)
		return reflect.ValueOf(uint64(*converted))
	},
	"float64": func(gdObject unsafe.Pointer) reflect.Value {
		converted := (*C.godot_real)(gdObject)
		return reflect.ValueOf(float64(*converted))
	},
	"string": func(gdObject unsafe.Pointer) reflect.Value {
		converted := (*C.godot_string)(gdObject)
		return reflect.ValueOf(godotStringAsString(converted))
	},
	"*Array": func(gdObject unsafe.Pointer) reflect.Value {
		converted := &Array{}
		converted.array = (*C.godot_array)(gdObject)
		return reflect.ValueOf(converted)
	},
	"*Basis": func(gdObject unsafe.Pointer) reflect.Value {
		converted := &Basis{}
		converted.basis = (*C.godot_basis)(gdObject)
		return reflect.ValueOf(converted)
	},
	"*Color": func(gdObject unsafe.Pointer) reflect.Value {
		converted := &Color{}
		converted.color = (*C.godot_color)(gdObject)
		return reflect.ValueOf(converted)
	},
	"*Dictionary": func(gdObject unsafe.Pointer) reflect.Value {
		converted := &Dictionary{}
		converted.dictionary = (*C.godot_dictionary)(gdObject)
		return reflect.ValueOf(converted)
	},
	"*NodePath": func(gdObject unsafe.Pointer) reflect.Value {
		converted := &NodePath{}
		converted.nodePath = (*C.godot_node_path)(gdObject)
		return reflect.ValueOf(converted)
	},
	"*Plane": func(gdObject unsafe.Pointer) reflect.Value {
		converted := &Plane{}
		converted.plane = (*C.godot_plane)(gdObject)
		return reflect.ValueOf(converted)
	},
	"*Quat": func(gdObject unsafe.Pointer) reflect.Value {
		converted := &Quat{}
		converted.quat = (*C.godot_quat)(gdObject)
		return reflect.ValueOf(converted)
	},
	"*Rect2": func(gdObject unsafe.Pointer) reflect.Value {
		converted := &Rect2{}
		converted.rect2 = (*C.godot_rect2)(gdObject)
		return reflect.ValueOf(converted)
	},
	"*Rect3": func(gdObject unsafe.Pointer) reflect.Value {
		converted := &Rect3{}
		converted.rect3 = (*C.godot_rect3)(gdObject)
		return reflect.ValueOf(converted)
	},
	"*RID": func(gdObject unsafe.Pointer) reflect.Value {
		converted := &RID{}
		converted.rid = (*C.godot_rid)(gdObject)
		return reflect.ValueOf(converted)
	},
	"*Transform": func(gdObject unsafe.Pointer) reflect.Value {
		converted := &Transform{}
		converted.transform = (*C.godot_transform)(gdObject)
		return reflect.ValueOf(converted)
	},
	"*Transform2D": func(gdObject unsafe.Pointer) reflect.Value {
		converted := &Transform2D{}
		converted.transform2d = (*C.godot_transform2d)(gdObject)
		return reflect.ValueOf(converted)
	},
	"*Variant": func(gdObject unsafe.Pointer) reflect.Value {
		converted := &Variant{}
		converted.variant = (*C.godot_variant)(gdObject)
		return reflect.ValueOf(converted)
	},
	"*Vector2": func(gdObject unsafe.Pointer) reflect.Value {
		converted := &Vector2{}
		converted.vector2 = (*C.godot_vector2)(gdObject)
		return reflect.ValueOf(converted)
	},
	"*Vector3": func(gdObject unsafe.Pointer) reflect.Value {
		converted := &Vector3{}
		converted.vector3 = (*C.godot_vector3)(gdObject)
		return reflect.ValueOf(converted)
	},

	"*Object": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Object{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Reference": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Reference{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*WeakRef": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &WeakRef{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Resource": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Resource{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Image": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Image{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*InputEvent": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &InputEvent{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*InputEventWithModifiers": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &InputEventWithModifiers{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*InputEventKey": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &InputEventKey{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*InputEventMouse": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &InputEventMouse{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*InputEventMouseButton": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &InputEventMouseButton{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*InputEventMouseMotion": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &InputEventMouseMotion{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*InputEventJoypadButton": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &InputEventJoypadButton{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*InputEventJoypadMotion": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &InputEventJoypadMotion{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*InputEventScreenDrag": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &InputEventScreenDrag{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*InputEventScreenTouch": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &InputEventScreenTouch{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*InputEventAction": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &InputEventAction{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*FuncRef": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &FuncRef{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*StreamPeer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &StreamPeer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*StreamPeerBuffer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &StreamPeerBuffer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*StreamPeerTCP": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &StreamPeerTCP{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*TCP_Server": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &TCP_Server{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PacketPeer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PacketPeer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PacketPeerUDP": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PacketPeerUDP{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*StreamPeerSSL": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &StreamPeerSSL{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ip": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ip{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PacketPeerStream": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PacketPeerStream{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*MainLoop": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &MainLoop{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Translation": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Translation{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PHashTranslation": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PHashTranslation{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*UndoRedo": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &UndoRedo{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*HTTPClient": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &HTTPClient{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ResourceInteractiveLoader": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ResourceInteractiveLoader{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*TriangleMesh": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &TriangleMesh{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*_File": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &_File{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*_Directory": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &_Directory{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*_Thread": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &_Thread{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*_Mutex": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &_Mutex{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*_Semaphore": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &_Semaphore{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*XMLParser": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &XMLParser{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ConfigFile": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ConfigFile{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PCKPacker": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PCKPacker{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PackedDataContainer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PackedDataContainer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PackedDataContainerRef": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PackedDataContainerRef{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AStar": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AStar{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*EncodedObjectAsID": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &EncodedObjectAsID{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*JSONParseResult": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &JSONParseResult{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*IP_Unix": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &IP_Unix{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*geometry": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &geometry{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*resourceLoader": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &resourceLoader{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*resourceSaver": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &resourceSaver{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*os": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &os{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*engine": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &engine{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*classDb": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &classDb{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*marshalls": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &marshalls{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*json": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &json{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*projectSettings": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &projectSettings{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*inputMap": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &inputMap{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*translationServer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &translationServer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*performance": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &performance{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*visualServer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &visualServer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PhysicsServerSW": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PhysicsServerSW{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*physicsServer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &physicsServer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PhysicsDirectBodyStateSW": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PhysicsDirectBodyStateSW{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PhysicsDirectBodyState": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PhysicsDirectBodyState{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Physics2DServerSW": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Physics2DServerSW{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*physics2DServer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &physics2DServer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Physics2DDirectBodyStateSW": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Physics2DDirectBodyStateSW{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Physics2DDirectBodyState": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Physics2DDirectBodyState{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*audioServer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &audioServer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*InputDefault": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &InputDefault{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*input": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &input{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*arvrServer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &arvrServer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ARVRInterface": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ARVRInterface{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ARVRPositionalTracker": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ARVRPositionalTracker{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ARVRScriptInterface": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ARVRScriptInterface{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioStream": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioStream{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioStreamPlayback": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioStreamPlayback{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioStreamRandomPitch": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioStreamRandomPitch{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioEffect": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioEffect{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioBusLayout": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioBusLayout{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioEffectAmplify": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioEffectAmplify{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioEffectReverb": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioEffectReverb{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioEffectFilter": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioEffectFilter{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioEffectEQ": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioEffectEQ{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioEffectLowPassFilter": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioEffectLowPassFilter{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioEffectHighPassFilter": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioEffectHighPassFilter{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioEffectBandPassFilter": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioEffectBandPassFilter{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioEffectNotchFilter": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioEffectNotchFilter{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioEffectBandLimitFilter": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioEffectBandLimitFilter{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioEffectLowShelfFilter": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioEffectLowShelfFilter{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioEffectHighShelfFilter": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioEffectHighShelfFilter{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioEffectEQ6": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioEffectEQ6{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioEffectEQ10": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioEffectEQ10{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioEffectEQ21": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioEffectEQ21{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioEffectDistortion": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioEffectDistortion{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioEffectStereoEnhance": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioEffectStereoEnhance{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioEffectPanner": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioEffectPanner{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioEffectChorus": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioEffectChorus{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioEffectDelay": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioEffectDelay{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioEffectCompressor": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioEffectCompressor{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioEffectLimiter": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioEffectLimiter{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioEffectPitchShift": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioEffectPitchShift{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioEffectPhaser": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioEffectPhaser{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Physics2DDirectSpaceState": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Physics2DDirectSpaceState{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Physics2DShapeQueryResult": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Physics2DShapeQueryResult{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Physics2DTestMotionResult": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Physics2DTestMotionResult{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Physics2DShapeQueryParameters": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Physics2DShapeQueryParameters{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PhysicsShapeQueryParameters": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PhysicsShapeQueryParameters{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PhysicsDirectSpaceState": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PhysicsDirectSpaceState{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PhysicsShapeQueryResult": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PhysicsShapeQueryResult{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*BitmapFont": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &BitmapFont{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Theme": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Theme{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Font": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Font{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ImageTexture": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ImageTexture{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Texture": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Texture{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*StyleBoxTexture": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &StyleBoxTexture{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Panel": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Panel{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Button": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Button{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*StyleBox": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &StyleBox{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*LinkButton": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &LinkButton{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ColorPickerButton": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ColorPickerButton{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*StyleBoxEmpty": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &StyleBoxEmpty{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ToolButton": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ToolButton{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*OptionButton": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &OptionButton{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*MenuButton": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &MenuButton{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ButtonGroup": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ButtonGroup{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*CheckBox": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &CheckBox{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*CheckButton": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &CheckButton{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Label": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Label{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ProgressBar": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ProgressBar{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*LineEdit": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &LineEdit{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*TextEdit": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &TextEdit{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*HScrollBar": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &HScrollBar{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VScrollBar": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VScrollBar{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*HSlider": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &HSlider{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VSlider": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VSlider{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*GraphEdit": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &GraphEdit{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*SpinBox": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &SpinBox{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*WindowDialog": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &WindowDialog{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*FileDialog": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &FileDialog{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PopupMenu": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PopupMenu{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PopupPanel": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PopupPanel{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*GraphNode": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &GraphNode{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Tree": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Tree{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ItemList": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ItemList{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*TabContainer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &TabContainer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Tabs": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Tabs{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*HSeparator": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &HSeparator{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VSeparator": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VSeparator{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ColorPicker": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ColorPicker{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*RichTextLabel": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &RichTextLabel{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VSplitContainer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VSplitContainer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*HSplitContainer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &HSplitContainer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VBoxContainer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VBoxContainer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*MarginContainer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &MarginContainer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*HBoxContainer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &HBoxContainer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*GridContainer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &GridContainer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ReferenceRect": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ReferenceRect{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PanelContainer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PanelContainer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Node": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Node{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*InstancePlaceholder": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &InstancePlaceholder{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Viewport": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Viewport{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*World": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &World{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ViewportTexture": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ViewportTexture{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*HTTPRequest": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &HTTPRequest{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Timer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Timer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*CanvasLayer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &CanvasLayer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*CanvasItem": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &CanvasItem{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Node2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Node2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*CanvasModulate": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &CanvasModulate{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ResourcePreloader": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ResourcePreloader{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Control": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Control{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*BaseButton": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &BaseButton{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ShortCut": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ShortCut{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Range": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Range{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ScrollBar": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ScrollBar{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Slider": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Slider{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Popup": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Popup{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*TextureRect": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &TextureRect{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ColorRect": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ColorRect{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*NinePatchRect": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &NinePatchRect{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*TextureButton": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &TextureButton{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Separator": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Separator{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*BitMap": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &BitMap{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Container": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Container{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*BoxContainer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &BoxContainer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*CenterContainer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &CenterContainer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ScrollContainer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ScrollContainer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*SplitContainer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &SplitContainer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*TextureProgress": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &TextureProgress{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AcceptDialog": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AcceptDialog{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ConfirmationDialog": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ConfirmationDialog{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*TreeItem": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &TreeItem{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VideoPlayer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VideoPlayer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PopupDialog": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PopupDialog{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VideoStream": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VideoStream{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ViewportContainer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ViewportContainer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Spatial": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Spatial{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*SpatialGizmo": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &SpatialGizmo{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Skeleton": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Skeleton{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AnimationPlayer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AnimationPlayer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Tween": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Tween{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*BoneAttachment": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &BoneAttachment{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualInstance": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualInstance{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Camera": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Camera{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Listener": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Listener{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ARVRCamera": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ARVRCamera{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ARVRController": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ARVRController{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ARVRAnchor": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ARVRAnchor{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ARVROrigin": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ARVROrigin{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*InterpolatedCamera": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &InterpolatedCamera{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*GeometryInstance": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &GeometryInstance{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*MeshInstance": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &MeshInstance{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Mesh": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Mesh{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ImmediateGeometry": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ImmediateGeometry{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*SpriteBase3D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &SpriteBase3D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Sprite3D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Sprite3D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AnimatedSprite3D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AnimatedSprite3D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*SpriteFrames": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &SpriteFrames{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Light": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Light{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*DirectionalLight": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &DirectionalLight{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*OmniLight": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &OmniLight{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*SpotLight": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &SpotLight{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ReflectionProbe": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ReflectionProbe{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*GIProbe": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &GIProbe{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*GIProbeData": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &GIProbeData{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AnimationTreePlayer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AnimationTreePlayer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Particles": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Particles{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Position3D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Position3D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*NavigationMeshInstance": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &NavigationMeshInstance{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*NavigationMesh": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &NavigationMesh{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Navigation": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Navigation{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*CollisionObject": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &CollisionObject{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PhysicsBody": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PhysicsBody{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*StaticBody": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &StaticBody{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*RigidBody": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &RigidBody{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*KinematicCollision": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &KinematicCollision{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*KinematicBody": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &KinematicBody{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VehicleBody": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VehicleBody{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VehicleWheel": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VehicleWheel{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Area": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Area{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ProximityGroup": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ProximityGroup{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*CollisionShape": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &CollisionShape{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Shape": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Shape{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*CollisionPolygon": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &CollisionPolygon{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*RayCast": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &RayCast{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*MultiMeshInstance": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &MultiMeshInstance{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*MultiMesh": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &MultiMesh{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Curve3D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Curve3D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Path": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Path{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PathFollow": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PathFollow{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisibilityNotifier": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisibilityNotifier{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisibilityEnabler": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisibilityEnabler{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*WorldEnvironment": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &WorldEnvironment{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Environment": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Environment{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*RemoteTransform": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &RemoteTransform{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Joint": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Joint{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PinJoint": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PinJoint{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*HingeJoint": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &HingeJoint{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*SliderJoint": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &SliderJoint{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Generic6DOFJoint": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Generic6DOFJoint{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ConeTwistJoint": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ConeTwistJoint{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*MeshLibrary": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &MeshLibrary{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Shader": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Shader{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Material": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Material{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ShaderMaterial": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ShaderMaterial{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*CanvasItemMaterial": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &CanvasItemMaterial{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Particles2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Particles2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Sprite": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Sprite{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AnimatedSprite": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AnimatedSprite{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Position2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Position2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Line2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Line2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Gradient": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Gradient{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*CollisionObject2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &CollisionObject2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PhysicsBody2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PhysicsBody2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*StaticBody2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &StaticBody2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*RigidBody2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &RigidBody2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*KinematicBody2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &KinematicBody2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*KinematicCollision2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &KinematicCollision2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Area2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Area2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*CollisionShape2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &CollisionShape2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Shape2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Shape2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*CollisionPolygon2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &CollisionPolygon2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*RayCast2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &RayCast2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisibilityNotifier2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisibilityNotifier2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisibilityEnabler2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisibilityEnabler2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Polygon2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Polygon2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Light2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Light2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*LightOccluder2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &LightOccluder2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*OccluderPolygon2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &OccluderPolygon2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*YSort": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &YSort{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*BackBufferCopy": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &BackBufferCopy{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Camera2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Camera2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Joint2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Joint2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PinJoint2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PinJoint2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*GrooveJoint2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &GrooveJoint2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*DampedSpringJoint2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &DampedSpringJoint2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*TileSet": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &TileSet{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*TileMap": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &TileMap{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ParallaxBackground": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ParallaxBackground{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ParallaxLayer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ParallaxLayer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*TouchScreenButton": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &TouchScreenButton{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*RemoteTransform2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &RemoteTransform2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ArrayMesh": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ArrayMesh{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PrimitiveMesh": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PrimitiveMesh{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*CapsuleMesh": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &CapsuleMesh{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*CubeMesh": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &CubeMesh{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*CylinderMesh": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &CylinderMesh{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PlaneMesh": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PlaneMesh{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PrismMesh": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PrismMesh{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*QuadMesh": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &QuadMesh{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*SphereMesh": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &SphereMesh{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*SpatialMaterial": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &SpatialMaterial{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ParticlesMaterial": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ParticlesMaterial{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*CurveTexture": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &CurveTexture{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*GradientTexture": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &GradientTexture{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*RayShape": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &RayShape{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*SphereShape": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &SphereShape{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*BoxShape": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &BoxShape{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*CapsuleShape": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &CapsuleShape{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PlaneShape": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PlaneShape{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ConvexPolygonShape": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ConvexPolygonShape{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ConcavePolygonShape": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ConcavePolygonShape{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*SurfaceTool": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &SurfaceTool{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*MeshDataTool": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &MeshDataTool{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*SpatialVelocityTracker": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &SpatialVelocityTracker{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Sky": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Sky{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*World2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &World2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PanoramaSky": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PanoramaSky{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ProceduralSky": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ProceduralSky{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*StreamTexture": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &StreamTexture{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AtlasTexture": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AtlasTexture{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*LargeTexture": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &LargeTexture{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Curve": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Curve{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*CubeMap": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &CubeMap{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Animation": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Animation{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*DynamicFontData": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &DynamicFontData{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*DynamicFont": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &DynamicFont{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*StyleBoxFlat": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &StyleBoxFlat{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PolygonPathFinder": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PolygonPathFinder{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioStreamPlayer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioStreamPlayer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioStreamPlayer2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioStreamPlayer2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioStreamPlayer3D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioStreamPlayer3D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioStreamSample": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioStreamSample{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*LineShape2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &LineShape2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*SegmentShape2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &SegmentShape2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*RayShape2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &RayShape2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*CircleShape2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &CircleShape2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*RectangleShape2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &RectangleShape2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*CapsuleShape2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &CapsuleShape2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ConvexPolygonShape2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ConvexPolygonShape2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ConcavePolygonShape2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ConcavePolygonShape2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Curve2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Curve2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Path2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Path2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PathFollow2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PathFollow2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Navigation2D": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Navigation2D{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*NavigationPolygon": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &NavigationPolygon{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*NavigationPolygonInstance": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &NavigationPolygonInstance{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*SceneState": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &SceneState{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*PackedScene": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &PackedScene{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*SceneTree": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &SceneTree{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*SceneTreeTimer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &SceneTreeTimer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*EditorPlugin": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &EditorPlugin{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*EditorImportPlugin": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &EditorImportPlugin{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*EditorScript": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &EditorScript{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*EditorSelection": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &EditorSelection{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*EditorFileDialog": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &EditorFileDialog{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*EditorSettings": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &EditorSettings{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*EditorSpatialGizmo": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &EditorSpatialGizmo{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*EditorResourcePreview": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &EditorResourcePreview{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*EditorResourcePreviewGenerator": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &EditorResourcePreviewGenerator{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*EditorFileSystem": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &EditorFileSystem{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*EditorFileSystemDirectory": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &EditorFileSystemDirectory{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ScriptEditor": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ScriptEditor{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*Script": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &Script{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*EditorInterface": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &EditorInterface{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*EditorExportPlugin": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &EditorExportPlugin{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*EditorResourceConversionPlugin": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &EditorResourceConversionPlugin{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*NetworkedMultiplayerPeer": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &NetworkedMultiplayerPeer{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*NetworkedMultiplayerENet": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &NetworkedMultiplayerENet{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*GDNativeLibrary": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &GDNativeLibrary{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*GDNative": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &GDNative{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*NativeScript": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &NativeScript{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*GDScript": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &GDScript{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*GDFunctionState": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &GDFunctionState{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*GridMap": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &GridMap{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*RegExMatch": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &RegExMatch{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*RegEx": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &RegEx{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ResourceImporterOGGVorbis": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ResourceImporterOGGVorbis{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*ResourceImporter": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &ResourceImporter{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*AudioStreamOGGVorbis": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &AudioStreamOGGVorbis{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScript": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScript{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptNode": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptNode{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptFunctionState": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptFunctionState{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptFunction": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptFunction{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptOperator": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptOperator{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptVariableSet": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptVariableSet{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptVariableGet": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptVariableGet{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptConstant": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptConstant{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptIndexGet": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptIndexGet{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptIndexSet": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptIndexSet{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptGlobalConstant": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptGlobalConstant{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptClassConstant": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptClassConstant{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptMathConstant": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptMathConstant{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptBasicTypeConstant": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptBasicTypeConstant{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptEngineSingleton": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptEngineSingleton{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptSceneNode": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptSceneNode{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptSceneTree": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptSceneTree{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptResourcePath": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptResourcePath{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptSelf": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptSelf{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptCustomNode": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptCustomNode{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptSubCall": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptSubCall{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptComment": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptComment{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptConstructor": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptConstructor{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptLocalVar": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptLocalVar{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptLocalVarSet": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptLocalVarSet{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptInputAction": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptInputAction{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptDeconstruct": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptDeconstruct{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptPreload": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptPreload{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptTypeCast": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptTypeCast{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptFunctionCall": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptFunctionCall{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptPropertySet": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptPropertySet{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptPropertyGet": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptPropertyGet{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptEmitSignal": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptEmitSignal{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptReturn": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptReturn{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptIterator": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptIterator{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptCondition": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptCondition{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptWhile": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptWhile{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptSequence": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptSequence{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptSwitch": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptSwitch{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptSelect": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptSelect{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptYield": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptYield{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptYieldSignal": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptYieldSignal{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptBuiltinFunc": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptBuiltinFunc{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},

	"*VisualScriptExpression": func(gdObject unsafe.Pointer) reflect.Value {
		owner := (*C.godot_object)(gdObject)
		goObject := &VisualScriptExpression{}
		goObject.setOwner(owner)

		return reflect.ValueOf(goObject)
	},
}
