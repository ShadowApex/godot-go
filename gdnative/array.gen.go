package gdnative

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "types.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

/*
#include "gdnative.gen.h"
#include <gdnative/array.h>
// Include all headers for now. TODO: Look up all the required
// headers we need to import based on the method arguments and return types.
#include <gdnative/aabb.h>
#include <gdnative/array.h>
#include <gdnative/basis.h>
#include <gdnative/color.h>
#include <gdnative/dictionary.h>
#include <gdnative/gdnative.h>
#include <gdnative/node_path.h>
#include <gdnative/plane.h>
#include <gdnative/pool_arrays.h>
#include <gdnative/quat.h>
#include <gdnative/rect2.h>
#include <gdnative/rid.h>
#include <gdnative/string.h>
#include <gdnative/string_name.h>
#include <gdnative/transform.h>
#include <gdnative/transform2d.h>
#include <gdnative/variant.h>
#include <gdnative/vector2.h>
#include <gdnative/vector3.h>
#include <gdnative_api_struct.gen.h>
*/
import "C"
import "unsafe"

// NewEmptyArray will return a pointer to an empty
// initialized Array. This is primarily used in
// conjunction with MethodBindPtrCall.
func NewEmptyArray() Pointer {
	var obj C.godot_array
	return Pointer{base: unsafe.Pointer(&obj)}
}

// NewPointerFromArray will return an unsafe pointer to the given
// object. This is primarily used in conjunction with MethodBindPtrCall.
func NewPointerFromArray(obj Array) Pointer {
	return Pointer{base: unsafe.Pointer(obj.getBase())}
}

// NewArrayFromPointer will return a Array from the
// given unsafe pointer. This is primarily used in conjunction with MethodBindPtrCall.
func NewArrayFromPointer(ptr Pointer) Array {

	return Array{base: (*C.godot_array)(ptr.getBase())}
}

type Array struct {
	base *C.godot_array
}

func (gdt Array) getBase() *C.godot_array {
	return gdt.base
}

// NewArray godot_array_new [[godot_array * r_dest]] void
func NewArray() Array {
	var dest C.godot_array
	C.go_godot_array_new(GDNative.api, &dest)
	return Array{base: &dest}
}

// NewArrayCopy godot_array_new_copy [[godot_array * r_dest] [const godot_array * p_src]] void
func NewArrayCopy(src Array) Array {
	var dest C.godot_array
	arg1 := src.getBase()
	C.go_godot_array_new_copy(GDNative.api, &dest, arg1)
	return Array{base: &dest}
}

// NewArrayPoolColorArray godot_array_new_pool_color_array [[godot_array * r_dest] [const godot_pool_color_array * p_pca]] void
func NewArrayPoolColorArray(pca PoolColorArray) Array {
	var dest C.godot_array
	arg1 := pca.getBase()
	C.go_godot_array_new_pool_color_array(GDNative.api, &dest, arg1)
	return Array{base: &dest}
}

// NewArrayPoolVector3Array godot_array_new_pool_vector3_array [[godot_array * r_dest] [const godot_pool_vector3_array * p_pv3a]] void
func NewArrayPoolVector3Array(pv3A PoolVector3Array) Array {
	var dest C.godot_array
	arg1 := pv3A.getBase()
	C.go_godot_array_new_pool_vector3_array(GDNative.api, &dest, arg1)
	return Array{base: &dest}
}

// NewArrayPoolVector2Array godot_array_new_pool_vector2_array [[godot_array * r_dest] [const godot_pool_vector2_array * p_pv2a]] void
func NewArrayPoolVector2Array(pv2A PoolVector2Array) Array {
	var dest C.godot_array
	arg1 := pv2A.getBase()
	C.go_godot_array_new_pool_vector2_array(GDNative.api, &dest, arg1)
	return Array{base: &dest}
}

// NewArrayPoolStringArray godot_array_new_pool_string_array [[godot_array * r_dest] [const godot_pool_string_array * p_psa]] void
func NewArrayPoolStringArray(psa PoolStringArray) Array {
	var dest C.godot_array
	arg1 := psa.getBase()
	C.go_godot_array_new_pool_string_array(GDNative.api, &dest, arg1)
	return Array{base: &dest}
}

// NewArrayPoolRealArray godot_array_new_pool_real_array [[godot_array * r_dest] [const godot_pool_real_array * p_pra]] void
func NewArrayPoolRealArray(pra PoolRealArray) Array {
	var dest C.godot_array
	arg1 := pra.getBase()
	C.go_godot_array_new_pool_real_array(GDNative.api, &dest, arg1)
	return Array{base: &dest}
}

// NewArrayPoolIntArray godot_array_new_pool_int_array [[godot_array * r_dest] [const godot_pool_int_array * p_pia]] void
func NewArrayPoolIntArray(pia PoolIntArray) Array {
	var dest C.godot_array
	arg1 := pia.getBase()
	C.go_godot_array_new_pool_int_array(GDNative.api, &dest, arg1)
	return Array{base: &dest}
}

// NewArrayPoolByteArray godot_array_new_pool_byte_array [[godot_array * r_dest] [const godot_pool_byte_array * p_pba]] void
func NewArrayPoolByteArray(pba PoolByteArray) Array {
	var dest C.godot_array
	arg1 := pba.getBase()
	C.go_godot_array_new_pool_byte_array(GDNative.api, &dest, arg1)
	return Array{base: &dest}
}

// Set godot_array_set [[godot_array * p_self] [const godot_int p_idx] [const godot_variant * p_value]] void
func (gdt *Array) Set(idx Int, value Variant) {
	arg0 := gdt.getBase()
	arg1 := idx.getBase()
	arg2 := value.getBase()

	C.go_godot_array_set(GDNative.api, arg0, arg1, arg2)
}

// Get godot_array_get [[const godot_array * p_self] [const godot_int p_idx]] godot_variant
func (gdt *Array) Get(idx Int) Variant {
	arg0 := gdt.getBase()
	arg1 := idx.getBase()

	ret := C.go_godot_array_get(GDNative.api, arg0, arg1)

	return Variant{base: &ret}

}

// OperatorIndex godot_array_operator_index [[godot_array * p_self] [const godot_int p_idx]] godot_variant *
func (gdt *Array) OperatorIndex(idx Int) Variant {
	arg0 := gdt.getBase()
	arg1 := idx.getBase()

	ret := C.go_godot_array_operator_index(GDNative.api, arg0, arg1)

	return Variant{base: ret}

}

// OperatorIndexConst godot_array_operator_index_const [[const godot_array * p_self] [const godot_int p_idx]] const godot_variant *
func (gdt *Array) OperatorIndexConst(idx Int) Variant {
	arg0 := gdt.getBase()
	arg1 := idx.getBase()

	ret := C.go_godot_array_operator_index_const(GDNative.api, arg0, arg1)

	return Variant{base: ret}

}

// Append godot_array_append [[godot_array * p_self] [const godot_variant * p_value]] void
func (gdt *Array) Append(value Variant) {
	arg0 := gdt.getBase()
	arg1 := value.getBase()

	C.go_godot_array_append(GDNative.api, arg0, arg1)
}

// Clear godot_array_clear [[godot_array * p_self]] void
func (gdt *Array) Clear() {
	arg0 := gdt.getBase()

	C.go_godot_array_clear(GDNative.api, arg0)
}

// Count godot_array_count [[const godot_array * p_self] [const godot_variant * p_value]] godot_int
func (gdt *Array) Count(value Variant) Int {
	arg0 := gdt.getBase()
	arg1 := value.getBase()

	ret := C.go_godot_array_count(GDNative.api, arg0, arg1)

	return Int(ret)
}

// Empty godot_array_empty [[const godot_array * p_self]] godot_bool
func (gdt *Array) Empty() Bool {
	arg0 := gdt.getBase()

	ret := C.go_godot_array_empty(GDNative.api, arg0)

	return Bool(ret)
}

// Erase godot_array_erase [[godot_array * p_self] [const godot_variant * p_value]] void
func (gdt *Array) Erase(value Variant) {
	arg0 := gdt.getBase()
	arg1 := value.getBase()

	C.go_godot_array_erase(GDNative.api, arg0, arg1)
}

// Front godot_array_front [[const godot_array * p_self]] godot_variant
func (gdt *Array) Front() Variant {
	arg0 := gdt.getBase()

	ret := C.go_godot_array_front(GDNative.api, arg0)

	return Variant{base: &ret}

}

// Back godot_array_back [[const godot_array * p_self]] godot_variant
func (gdt *Array) Back() Variant {
	arg0 := gdt.getBase()

	ret := C.go_godot_array_back(GDNative.api, arg0)

	return Variant{base: &ret}

}

// Find godot_array_find [[const godot_array * p_self] [const godot_variant * p_what] [const godot_int p_from]] godot_int
func (gdt *Array) Find(what Variant, from Int) Int {
	arg0 := gdt.getBase()
	arg1 := what.getBase()
	arg2 := from.getBase()

	ret := C.go_godot_array_find(GDNative.api, arg0, arg1, arg2)

	return Int(ret)
}

// FindLast godot_array_find_last [[const godot_array * p_self] [const godot_variant * p_what]] godot_int
func (gdt *Array) FindLast(what Variant) Int {
	arg0 := gdt.getBase()
	arg1 := what.getBase()

	ret := C.go_godot_array_find_last(GDNative.api, arg0, arg1)

	return Int(ret)
}

// Has godot_array_has [[const godot_array * p_self] [const godot_variant * p_value]] godot_bool
func (gdt *Array) Has(value Variant) Bool {
	arg0 := gdt.getBase()
	arg1 := value.getBase()

	ret := C.go_godot_array_has(GDNative.api, arg0, arg1)

	return Bool(ret)
}

// Hash godot_array_hash [[const godot_array * p_self]] godot_int
func (gdt *Array) Hash() Int {
	arg0 := gdt.getBase()

	ret := C.go_godot_array_hash(GDNative.api, arg0)

	return Int(ret)
}

// Insert godot_array_insert [[godot_array * p_self] [const godot_int p_pos] [const godot_variant * p_value]] void
func (gdt *Array) Insert(pos Int, value Variant) {
	arg0 := gdt.getBase()
	arg1 := pos.getBase()
	arg2 := value.getBase()

	C.go_godot_array_insert(GDNative.api, arg0, arg1, arg2)
}

// Invert godot_array_invert [[godot_array * p_self]] void
func (gdt *Array) Invert() {
	arg0 := gdt.getBase()

	C.go_godot_array_invert(GDNative.api, arg0)
}

// PopBack godot_array_pop_back [[godot_array * p_self]] godot_variant
func (gdt *Array) PopBack() Variant {
	arg0 := gdt.getBase()

	ret := C.go_godot_array_pop_back(GDNative.api, arg0)

	return Variant{base: &ret}

}

// PopFront godot_array_pop_front [[godot_array * p_self]] godot_variant
func (gdt *Array) PopFront() Variant {
	arg0 := gdt.getBase()

	ret := C.go_godot_array_pop_front(GDNative.api, arg0)

	return Variant{base: &ret}

}

// PushBack godot_array_push_back [[godot_array * p_self] [const godot_variant * p_value]] void
func (gdt *Array) PushBack(value Variant) {
	arg0 := gdt.getBase()
	arg1 := value.getBase()

	C.go_godot_array_push_back(GDNative.api, arg0, arg1)
}

// PushFront godot_array_push_front [[godot_array * p_self] [const godot_variant * p_value]] void
func (gdt *Array) PushFront(value Variant) {
	arg0 := gdt.getBase()
	arg1 := value.getBase()

	C.go_godot_array_push_front(GDNative.api, arg0, arg1)
}

// Remove godot_array_remove [[godot_array * p_self] [const godot_int p_idx]] void
func (gdt *Array) Remove(idx Int) {
	arg0 := gdt.getBase()
	arg1 := idx.getBase()

	C.go_godot_array_remove(GDNative.api, arg0, arg1)
}

// Resize godot_array_resize [[godot_array * p_self] [const godot_int p_size]] void
func (gdt *Array) Resize(size Int) {
	arg0 := gdt.getBase()
	arg1 := size.getBase()

	C.go_godot_array_resize(GDNative.api, arg0, arg1)
}

// Rfind godot_array_rfind [[const godot_array * p_self] [const godot_variant * p_what] [const godot_int p_from]] godot_int
func (gdt *Array) Rfind(what Variant, from Int) Int {
	arg0 := gdt.getBase()
	arg1 := what.getBase()
	arg2 := from.getBase()

	ret := C.go_godot_array_rfind(GDNative.api, arg0, arg1, arg2)

	return Int(ret)
}

// Size godot_array_size [[const godot_array * p_self]] godot_int
func (gdt *Array) Size() Int {
	arg0 := gdt.getBase()

	ret := C.go_godot_array_size(GDNative.api, arg0)

	return Int(ret)
}

// Sort godot_array_sort [[godot_array * p_self]] void
func (gdt *Array) Sort() {
	arg0 := gdt.getBase()

	C.go_godot_array_sort(GDNative.api, arg0)
}

// SortCustom godot_array_sort_custom [[godot_array * p_self] [godot_object * p_obj] [const godot_string * p_func]] void
func (gdt *Array) SortCustom(obj Object, function String) {
	arg0 := gdt.getBase()
	arg1 := unsafe.Pointer(obj.getBase())
	arg2 := function.getBase()

	C.go_godot_array_sort_custom(GDNative.api, arg0, arg1, arg2)
}

// Bsearch godot_array_bsearch [[godot_array * p_self] [const godot_variant * p_value] [const godot_bool p_before]] godot_int
func (gdt *Array) Bsearch(value Variant, before Bool) Int {
	arg0 := gdt.getBase()
	arg1 := value.getBase()
	arg2 := before.getBase()

	ret := C.go_godot_array_bsearch(GDNative.api, arg0, arg1, arg2)

	return Int(ret)
}

// BsearchCustom godot_array_bsearch_custom [[godot_array * p_self] [const godot_variant * p_value] [godot_object * p_obj] [const godot_string * p_func] [const godot_bool p_before]] godot_int
func (gdt *Array) BsearchCustom(value Variant, obj Object, function String, before Bool) Int {
	arg0 := gdt.getBase()
	arg1 := value.getBase()
	arg2 := unsafe.Pointer(obj.getBase())
	arg3 := function.getBase()
	arg4 := before.getBase()

	ret := C.go_godot_array_bsearch_custom(GDNative.api, arg0, arg1, arg2, arg3, arg4)

	return Int(ret)
}

// Destroy godot_array_destroy [[godot_array * p_self]] void
func (gdt *Array) Destroy() {
	arg0 := gdt.getBase()

	C.go_godot_array_destroy(GDNative.api, arg0)
}
